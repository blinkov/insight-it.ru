<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Insight IT</title><link>https://www.insight-it.ru/</link><description></description><atom:link href="https://www.insight-it.ru/tag/protocol-buffers/feed/index.xml" rel="self"></atom:link><lastBuildDate>Tue, 13 Nov 2012 02:09:00 +0400</lastBuildDate><item><title>Обзор Riak</title><link>https://www.insight-it.ru//storage/2012/obzor-riak/</link><description>&lt;p&gt;&lt;a href="https://www.insight-it.ru/goto/187746b6/" rel="nofollow" target="_blank" title="http://basho.com/products/riak-overview/"&gt;Riak&lt;/a&gt; - распределенная
&lt;em&gt;opensource&lt;/em&gt;&amp;nbsp;база данных, разработанная на &lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt; и
спроектированная в расчете на:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Высокую доступность и устойчивость к сбоям;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Масштабируемость и простоту обслуживания;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Универсальность.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;У проекта отличная&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/5083ec33/" rel="nofollow" target="_blank" title="http://docs.basho.com/riak/latest"&gt;официальная документация&lt;/a&gt;&amp;nbsp;на английском, далее же в этой статье я расскажу об основных её особенностях чуть подробнее, а также хитростях и подводных камнях, выявленных в процессе применения на практике (с перспективы веб-разработки).&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="vysokaia-dostupnost-i-ustoichivost-k-sboiam"&gt;Высокая доступность и устойчивость к сбоям&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Все данные в кластере&amp;nbsp;&lt;em&gt;реплицируются&lt;/em&gt; по принципу соседей на хэш
    кольце (см. логотип для иллюстрации) и даже в случае сбоев
    &lt;em&gt;доступны&lt;/em&gt; посредством интеллектуального перенаправления запросов
    внутри кластера.&lt;/li&gt;
&lt;li&gt;В случае возникновения коллизий из-за разрыва сетевого соединения
    или просто одновременной записи, на запрос получения данных &lt;em&gt;может
    вернуться несколько версий&lt;/em&gt; и приложение само может решить как их
    объединить или какую версию использовать.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="masshtabiruemost-i-prostota-obsluzhivaniia"&gt;Масштабируемость и простота обслуживания&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Добавление нового сервера тривиально путем копирования конфига и
    одной команды.&lt;/li&gt;
&lt;li&gt;Перераспределение данных и все остальное прозрачно происходит за
    сценой.&lt;/li&gt;
&lt;li&gt;Минимальный рекомендуемый размер Riak кластера - 5 серверов, меньшее
    количество не дает раскрыть весь потенциал.&lt;/li&gt;
&lt;li&gt;Одинаково легко обслуживать как маленький, так и большой кластер.&lt;/li&gt;
&lt;li&gt;Есть коммерческая &lt;em&gt;Enterprise&lt;/em&gt; версия с поддержкой от &lt;strong&gt;Basho&lt;/strong&gt;,
    компании-разработчика Riak (изначально выходцы из Akamai),
    равноправной зашифрованной репликацией между датацентрами и
    поддержкой &lt;em&gt;SNMP&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Есть встроенный веб-интерфейс для мониторинга и управления
    кластером, у меня правда так и не дошли руки его освоить:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="video-container"&gt;
&lt;iframe allowfullscreen="" frameborder="0" height="480" src="//www.youtube.com/embed/R0_PLMCrtZw?rel=0" width="853"&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;h2 id="universalnost"&gt;Универсальность&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Схема отсутствует, ключи и данные - произвольные бинарные строки.
    Ключи располагаются в пространствах имен &lt;em&gt;(bucket)&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Сериализация - на усмотрение разработчика, популярные варианты -
    Erlang'овский &lt;em&gt;BERT&lt;/em&gt;, &lt;em&gt;JSON&lt;/em&gt; для других платформ, можно использовать
    просто как &lt;em&gt;файловую систему&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Модульная система хранилищ данных, альтернатив много, основная -
    &lt;a href="/tag/google/"&gt;Google&lt;/a&gt; &lt;a href="/tag/leveldb/"&gt;LevelDB&lt;/a&gt;;&amp;nbsp;еще интересный
    вариант с хранением полностью в оперативной памяти - получается
    продвинутый распределенный кэш с репликацией, поиском и пр.&lt;/li&gt;
&lt;li&gt;Гибко настраиваемое количество узлов кластера, которые должны
    подтвердить успешность операции, чтобы она считалась успешной: можно
    указывать для всего кластера, пространства имен и даже конкретного
    запроса. Riak в любом случае остается eventually consistent базой
    данных (AP из CAP теоремы), но с возможностью управлять балансом
    производительности операций и надежностью выполнения запросов.&lt;/li&gt;
&lt;li&gt;Три интерфейса доступа &lt;em&gt;(API)&lt;/em&gt;:&lt;ul&gt;
&lt;li&gt;&lt;a href="/tag/protocol-buffers/"&gt;Google ProtocolBuffers&lt;/a&gt; - для основного
    использования в боевых условиях.&lt;/li&gt;
&lt;li&gt;&lt;a href="/tag/http/"&gt;HTTP&lt;/a&gt; &lt;a href="/tag/rest/"&gt;REST&lt;/a&gt; - для использования в
    языках, где нет готового клиента на ProtocolBuffers и для того,
    чтобы по-быстрому что-то посмотреть из консоли через curl. Хотя
    по факту клиенты для большинства языков программирования есть и
    проще делать запросы через интерпретатор.&lt;/li&gt;
&lt;li&gt;Еще есть прямой интерфейс Erlang-сообщений, но даже из самого
    Erlang им пользоваться не рекомендуют, не говоря уже о
    реализациях Erlang node (BERT) на других платформах.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Вместе с данными хранятся метаданные для разных целей, которые
    используются в соответствующих типах запросов:&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/3d61cc81/" rel="nofollow" target="_blank" title="http://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B5_%D1%87%D0%B0%D1%81%D1%8B"&gt;Векторные часы&lt;/a&gt;
    для разрешения конфликтов версий данных&amp;nbsp;&lt;em&gt;(обязательно, есть
    автоматическое разрешение);&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Индекс для полнотекстного поиска &lt;em&gt;(концептуально позаимствован у
    &lt;a href="/tag/lucene/"&gt;Lucene&lt;/a&gt;/&lt;a href="/tag/solr/"&gt;Solr&lt;/a&gt;, опционально);&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Индекс для простых выборок &lt;em&gt;(по бинарным и числовым полям,
    опционально);&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Связанные ключи &lt;em&gt;(отдаленный аналог внешних ключей,
    опционально).&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Встроенная поддержка &lt;a href="/tag/mapreduce/"&gt;MapReduce&lt;/a&gt;, фазы можно
    реализовывать на &lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt; или
    &lt;a href="/tag/javascript/"&gt;JavaScript&lt;/a&gt;;&amp;nbsp;для обоих языков есть библиотека с
    наиболее популярными случаями, которые можно использовать для
    образца.&lt;/li&gt;
&lt;li&gt;Есть поддержка выполнения операций до/после операций записи/чтения
    &lt;em&gt;(hooks)&lt;/em&gt;, чаще всего используются для построения полнотекстного
    индекса, но можно реализовать и свои, специфичные для приложения.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="nedokumentirovannye-vozmozhnosti"&gt;Недокументированные возможности&lt;/h2&gt;
&lt;p&gt;Пока я их нашел всего две:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Счетчики:&lt;/strong&gt;&amp;nbsp;как такового API в для&amp;nbsp;увеличения/уменьшения числовых
    значений &lt;em&gt;(increment/decrement)&lt;/em&gt; в Riak нет, так как он не лезет
    внутрь хранящихся данных. Зато есть векторные часы, которые растут с
    каждой операцией записи по ключу. Чтобы реализовать увеличение
    &lt;em&gt;(increment)&lt;/em&gt; необходимо записать в Riak пустую бинарную строку с
    опцией &lt;em&gt;return_body,&amp;nbsp;&lt;/em&gt;и у вернувшегося значения сложить все поля в
    векторных часах. &lt;a href="https://www.insight-it.ru/goto/6a894d09/" rel="nofollow" target="_blank" title="https://gist.github.com/4061705"&gt;Пример на
    Erlang&lt;/a&gt;. Если нужно еще и
    уменьшение (decrement) этого можно добиться с помощью пары счетчиков
    "плюс и минус" и вычитать второе значение из первого. Для&amp;nbsp;авто
    инкремента&amp;nbsp;основных ключей не самый лучший вариант, но для не особо
    критичных случаев вполне себе работает.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Выборка по списку ключей &lt;em&gt;(multiget)&lt;/em&gt;:&amp;nbsp;&lt;/strong&gt;такого API тоже нет, но
    здесь на выручку приходит &lt;em&gt;MapReduce&lt;/em&gt;. Это, пожалуй, наиболее
    популярное его применение. На вход подаем имеющийся список ключей и
    используем фазы из готовой библиотеки: &lt;em&gt;reduce_set_union&lt;/em&gt; и
    &lt;em&gt;map_identity&lt;/em&gt;. Данные возвращаются&amp;nbsp;неотсортированные &amp;nbsp;и требуют
    небольшой обертки на выходе, но все равно это намного быстрее, чем
    последовательно проходить по списку ключей и делать для каждого
    обычный &lt;em&gt;get&lt;/em&gt;. &lt;a href="https://www.insight-it.ru/goto/d557f797/" rel="nofollow" target="_blank" title="https://gist.github.com/4061784"&gt;Пример на Erlang&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="card blue lighten-4"&gt;
&lt;p&gt;&lt;div class="card-content"&gt;
Буду рад, если Вы поможете мне дополнить этот список, оставив известные
Вам подобные трюки в комментариях.
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="podvodnye-kamni"&gt;Подводные камни&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Если в Вашем приложении необходима функциональность &lt;strong&gt;постраничного
    просмотра отсортированных данных&lt;/strong&gt; &lt;em&gt;(pagination)&lt;/em&gt;, то будьте готовы
    реализовать её на клиенте. То есть Riak быстро сделал нужную выборку
    всех "страниц" и уже на клиенте её придется отсортировать и выкинуть
    лишнее. Вообще в большинстве случаев результаты запросов к Riak
    приходят в произвольном порядке из-за его распределенной природы.&lt;/li&gt;
&lt;li&gt;В продолжение к предыдущему: в &lt;a href="https://www.insight-it.ru/goto/cb1ee41b/" rel="nofollow" target="_blank" title="http://docs.basho.com/riak/latest/cookbooks/Riak-Search---Querying/#Querying-via%20the%20Solr%20Interface"&gt;REST Solr интерфейсе&lt;/a&gt;&amp;nbsp;есть
    аргументы (в ProtoBuf это тоже добавили в одной из последних
    версий), которые, казалось бы, достаточны для реализации
    постраничного просмотра: &lt;strong&gt;sort&lt;/strong&gt;, &lt;strong&gt;start&lt;/strong&gt;, &lt;strong&gt;rows&lt;/strong&gt; - что еще
    нужно? На практике оно работает не так, как было бы логично.
    Сортировка по значению (заданная в sort) применяется ПОСЛЕ того, как
    была отсчитана страница по start и rows. Они отмеряются по ключам
    или рейтингу значения в полнотекстном поиске и никак иначе. С тем же
    успехом эти 5-10 значений можно очень быстро отсортировать и на
    клиенте. Зачем-то это может быть и нужно, но в моем случае оказалось
    совершенно бесполезно.&lt;/li&gt;
&lt;li&gt;У Riak есть 4 основных типа запросов: простой
    get/set,&amp;nbsp;полнотекстовый&amp;nbsp;поиск, вторичные ключи &lt;em&gt;(secondary
    indices)&lt;/em&gt;, МapReduce и проход по связанным ключам &lt;em&gt;(link walking)&lt;/em&gt;.&lt;ul&gt;
&lt;li&gt;Если Ваши данные являются сериализованным JSON, BERT или XML, то
    в большинстве случаев Вам нужны лишь первые два из них,
    исключение - упомянутая выше выборка по списку ключей через
    MapReduce.&lt;/li&gt;
&lt;li&gt;Основной сценарий использования вторичных индексов - метаданные
    к произвольным неструктурированным бинарным данным, например в
    случае с аналогом файловой системы. Либо совсем примитивные
    случаи, когда правда нужно сделать простую выборку по одному
    целочисленному полю, что бывает редко.&lt;/li&gt;
&lt;li&gt;Если данные сериализованы, то связанные ключи проще хранить
    внутри данных, а не средствами СУБД. Разницы в
    производительности нет, в итоге делается тот же MapReduce с теми
    же фазами.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Хоть Riak "из коробки" и правда надежнее многих других СУБД и 1-2
    упавших/отключенных сервера в кластере внешне практически не
    заметны, есть одно но. Если один узел упал - соединения всех
    подключенных к нему клиентов теряются. Два основных
    пути&amp;nbsp;преодоления&amp;nbsp;этого момента:&lt;ul&gt;
&lt;li&gt;Если кластер клиентов и кластер Riak расположены на разных
    серверах, то между ними можно поставить отказоустойчивый TCP
    балансировщик нагрузки, в частности &lt;a href="/tag/haproxy/"&gt;HAProxy&lt;/a&gt; или
    &lt;a href="/tag/ipvs/"&gt;IPVS&lt;/a&gt; здесь наиболее органично вписываются.&lt;/li&gt;
&lt;li&gt;Если на одних и тех же, то есть вариант поставить балансировщик
    нагрузки перед клиентами (для веба возможно и в HTTP/HTTPS
    режиме), а каждый клиент подключается к своему локальному
    серверу Riak и если один, другой или оба сразу упали, то
    отрубать весь физический сервер целиком.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="vyvody"&gt;Выводы&lt;/h2&gt;
&lt;p&gt;Riak отлично подходит для многих вариантов использования, как в Интернет
среде, так и в смежных вроде телекома. Обладает отличным набором
положительных "черт характера", о которых шла речь в начале статьи.
Прекрасно справляется с большим потоком как операций записи, так и
операций чтения.&lt;/p&gt;
&lt;p&gt;Как уже упоминалось, практически единственный сценарий, где Riak совсем
не справляется, это выборки по большим объемам данных с сортировкой и
постраничным выводом. Но даже в этом случае никто не мешает использовать
отдельный сервис, который будет индексировать нужным образом данные и
подготавливать список идентификаторов для последующей multiget выборки
из Riak. К слову, проекты по этой части уже появляются, например
&lt;a href="https://www.insight-it.ru/goto/1232aa05/" rel="nofollow" target="_blank" title="https://github.com/rzezeski/yokozuna"&gt;Yokozuna&lt;/a&gt; - интеграция
полноценного Solr с Riak &lt;em&gt;(Riak Search - лишь частичный порт Solr+Lucene
на Erlang)&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id="dopolnitelnaia-informatsiia-po-teme"&gt;Дополнительная информация по теме&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/432a7a72/" rel="nofollow" target="_blank" title="http://basho.com/community/ricon2012"&gt;Riakcon 2012&lt;/a&gt; - свежая
    конференция от Basho, рассказывают о различных сферах применения
    Riak в реальных проектах&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/a6b96b20/" rel="nofollow" target="_blank" title="http://basho.com/company/production-users"&gt;Список компаний, использующих Riak&lt;/a&gt;&amp;nbsp;- можно увидеть очень солидные известные имена&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/b011dd8d/" rel="nofollow" target="_blank" title="http://docs.basho.com/riak/latest/references/appendices/comparisons"&gt;Сравнение Riak с другими NoSQL СУБД&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/c29f125e/" rel="nofollow" target="_blank" title="http://docs.basho.com/riak/latest/references/apis"&gt;Документация по API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/5f671db1/" rel="nofollow" target="_blank" title="https://github.com/basho"&gt;Официальный GitHub&lt;/a&gt; и &lt;a href="https://www.insight-it.ru/goto/b59384fb/" rel="nofollow" target="_blank" title="http://docs.basho.com/riak/latest/references/Community-Developed-Libraries-and-Projects"&gt;список сторонних opensource проектов&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/4ec186ad/" rel="nofollow" target="_blank" title="http://docs.basho.com/riak/latest/tutorials/querying"&gt;Сравнительная таблица MapReduce, Secondary Indices и Link Walking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Tue, 13 Nov 2012 02:09:00 +0400</pubDate><guid>tag:www.insight-it.ru,2012-11-13:storage/2012/obzor-riak/</guid><category>Basho</category><category>Erlang</category><category>LevelDB</category><category>Protocol Buffers</category><category>REST</category><category>Riak</category><category>БД</category><category>обзор</category><category>СУБД</category></item><item><title>Оптимизация интерактивных сайтов</title><link>https://www.insight-it.ru//interactive/2012/optimizaciya-interaktivnykh-sajjtov/</link><description>&lt;p&gt;Возвращаясь к теме&amp;nbsp;&lt;a href="https://www.insight-it.ru/interactive/"&gt;"Интерактивных сайтов"&lt;/a&gt;,&amp;nbsp;сегодня я хотел бы обсудить заключительную часть повествования, их
&lt;strong&gt;оптимизацию&lt;/strong&gt;. Возможно вы уже успели реализовать все или часть
обсуждавшихся в предыдущих статьях приемов, в этой статье я "подкину"
Вам еще несколько.&amp;nbsp;Настоятельно рекомендую прежде чем читать дальше
ознакомиться хотя бы с первой статьей про общую архитектуру, а лучше,
конечно, со всеми предыдущими статьями серии. В этот раз мы пройдемся по
всем обсуждавшимся в отдельных статьях компонентам, правда в другом
порядке, и будем обсуждать возможные пути их улучшения.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="oglavlenie-serii-interaktivnye-saity"&gt;Оглавление серии "Интерактивные сайты"&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://www.insight-it.ru/interactive/2012/arkhitektura-interaktivnykh-sajjtov/"&gt;Общая архитектура&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.insight-it.ru/interactive/2012/klientskaya-chast-interaktivnogo-sajjta/"&gt;Организация клиентской части&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.insight-it.ru/interactive/2012/postoyannoe-soedinenie-mezhdu-brauzerom-i-serverom/"&gt;Постоянное соединение между браузером и сервером&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.insight-it.ru/interactive/2012/povtornoe-ispolzovanie-shablonov/"&gt;Повторное использование шаблонов&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.insight-it.ru/interactive/2012/servernaya-chast-interaktivnogo-sajjta-i-potoki-soobshhenijj/"&gt;Серверная часть интерактивного сайта и потоки сообщений&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.insight-it.ru/interactive/2012/optimizaciya-interaktivnykh-sajjtov/"&gt;Оптимизация&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="servernaia-chast"&gt;Серверная часть&lt;/h2&gt;
&lt;p&gt;На серверной стороне есть масса простора для оптимизации, но, чтобы не
распыляться, постараюсь сосредоточиться лишь на том, что напрямую
связано с темой &lt;em&gt;интерактивных сайтов&lt;/em&gt;. В частности на процессе
маршрутизации сообщений и уведомлений между пользователями.&lt;/p&gt;
&lt;p&gt;Когда разрабатывается первая версия сайта, то многие части функционала
проще всего реализовать в виде массовых рассылок, как-то так: произошло
какое-то публично-доступное событие, допустим кто-то куда-то поставил
"мне нравится", отправляем его в брокер сообщений с пометкой "доставить
всем" &lt;em&gt;(fanout)&lt;/em&gt;. В итоге все подключенные на данный момент клиенты
получают это уведомление и каждый сам решает что с ним делать - что-то
менять на текущей странице или просто проигнорировать.&lt;/p&gt;
&lt;p&gt;Но при большом количестве соединений и потоке событий такой подход
становится роскошью. Большинство подобных ситуаций можно реализовать
подпиской на тематические &lt;em&gt;(topic)&lt;/em&gt; рассылки для каждого пользователя
индивидуально, то есть когда пользователь открывает ту или иную
страницу - серверная сторона должна подписать его на уведомления,
связанные именно с тем контентом, который находится у него на экране.
Это позволит свести к минимуму количество&amp;nbsp;доставленных&amp;nbsp;зря сообщений.&lt;/p&gt;
&lt;p&gt;Ситуации, когда правда нужны массовые рассылки по всем пользователям,
хоть и редки, но все же бывают. Если есть возможность их избежать, то
лучшей ей воспользоваться.&lt;/p&gt;
&lt;p&gt;Чтобы реализовать индивидуальные подписки как изложено выше, вероятно
понадобится еще и изменить принцип установления соединений между
брокером сообщений и сервером, поддерживающим постоянное соединение. Для
схемы массовых рассылок достаточно одного такого соединения на сервер.
Каждый сервер хранит список активных соединений с браузерами и, получив
новое сообщение от брокера, просто итеративно проходится по нему,
ретранслируя сообщение в каждое соединение. В таком случае для
последнего соединения в списке задержка может достигать нескольких
секунд, что не всегда приемлемо. Для схемы индивидуальных подписок есть
два основных варианта:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Реализовать мини-брокер внутри каждого такого сервера, т.е. сам
    сервер по-прежнему держит лишь одно соединение с настоящим брокером
    и получает все подряд сообщения, но прежде чем ретранслировать
    анализирует его и отправляет лишь части соединений.&lt;/li&gt;
&lt;li&gt;Либо держать создавать много примитивных процессов, которые с одной
    стороны держат соединение с браузером, с другой - с брокером. Каждый
    из них подписан именно на те сообщения, которые нужны данному
    пользователю, и ретранслируют их все без анализа.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="card blue lighten-4"&gt;
&lt;p&gt;&lt;div class="card-content"&gt;
Оба варианта имеют право на существование, какой окажется лучше -
зависит от многих факторов, нужно тестировать. Лично мне больше по душе
второй, но далеко не на каждой платформе его удастся эффективно
реализовать - настоящих системных процессов для такого использования
не&amp;nbsp;напасешься.
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="postoiannoe-soedinenie-mezhdu-brauzerom-i-serverom"&gt;Постоянное соединение между браузером и сервером&lt;/h2&gt;
&lt;p&gt;Помимо выбора удачной библиотеки абстракции протоколов для различных
браузеров, о чем я уже довольно подробно писал в соответствующей статье
серии, здесь я могу предложить еще два момента для значительного
улучшения производительности.&lt;/p&gt;
&lt;h3 id="mezhvkladochnoe-vzaimodeistvie-cross-tab-communication"&gt;Межвкладочное взаимодействие &lt;em&gt;(cross-tab communication)&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;На эту тему в Интернете ходит масса слухов и разговоров, но адекватной
инструкции о том как это можно кроссбраузерно организовать в разумные
сроки я не встречал, если кто знает - дайте в ссылку в комментариях,
пожалуйста. А я пока попробую поделиться своим опытом.&lt;/p&gt;
&lt;p&gt;Вкратце для тех, кто не в курсе: в самой простой реализации постоянное
соединение между браузером и сервером устанавливается для каждой вновь
открытой вкладки заново. Так как каждое такое соединение ресурсоемко, то
этого хотелось бы избежать. Помочь в этом может организация
&lt;strong&gt;межвкладочного взаимодействия&lt;/strong&gt; или, другими словами, общения между
вкладками/окнами браузера: одна вкладка избирается &lt;em&gt;главной&lt;/em&gt; и
устанавливает соединение с сервером, когда она получает новое
сообщение - она переправляет его конкретной открытой вкладке или же всем
сразу; те же, в свою очередь, когда хотят отправить сообщение на сервер,
отправляют его сначала &lt;em&gt;главной&lt;/em&gt; вкладке, а та уже пересылает на сервер.
В итоге все работает как и раньше, но соединений не больше одного на
браузер.&lt;/p&gt;
&lt;p&gt;Вообще в явном виде общение между вкладками браузера, как Вы, вероятно,
знаете, не предусмотрено. Именно из-за этого реализовать это все
кроссбраузерно не просто. Для начала приведу список технологий, которые
так или иначе можно для этого приспособить, большинство из них принято
относить к нынче модному &lt;a href="/tag/html5/"&gt;HTML5&lt;/a&gt;, в порядке возрастания
моих симпатий:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/704e1f8a/" rel="nofollow" target="_blank" title="http://en.wikipedia.org/wiki/Local_shared_object"&gt;Flash Local Shared Cookies&lt;/a&gt; - даже не рассматривал как вариант, так как требуется Adobe Flash, плюс, кажется, постоянно всплывает окно вроде
    &lt;a href="https://www.insight-it.ru/goto/e9a669cc/" rel="nofollow" target="_blank" title="http://www.macromedia.com/support/documentation/en/flashplayer/help/help06.html"&gt;этого&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/732af670/" rel="nofollow" target="_blank" title="http://caniuse.com/#feat=x-doc-messaging"&gt;postMessage&lt;/a&gt;&amp;nbsp;-&amp;nbsp;отправка
    сообщения указанному окну по его идентификатору. Поддержка
    браузерами хорошая, но большинство примеров показывают общение с
    iframe, а сопутствующего API для получения списка всех открытых
    окон/вкладок я не нашел, может быть плохо искал.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/86256a54/" rel="nofollow" target="_blank" title="http://caniuse.com/#feat=webworkers"&gt;Web Workers&lt;/a&gt; - в браузере
    создается не зависящий от вкладок поток, с которым можно общаться из
    вкладок. Поддержка браузерами хромает, а там где её нет -
    polyfill'ов пока не придумали.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/fc6c98e9/" rel="nofollow" target="_blank" title="http://caniuse.com/#feat=namevalue-storage"&gt;Web Storage&lt;/a&gt; -
    локальное хранилище пар ключ-значение с ограничением в 5-10Мб на
    домен. Хорошая поддержка браузерами, а там где её нет - есть
    polyfill'ы. Еще бывает &lt;a href="https://www.insight-it.ru/goto/71a12fd0/" rel="nofollow" target="_blank" title="http://caniuse.com/#feat=sql-storage"&gt;Web SQL&lt;/a&gt;, но для данной задачи это уже перебор.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В общем рекомендую последний вариант, из дополнительных плюсов хранилище
можно использовать и для других целей, но об этом в следующих разделах.&lt;/p&gt;
&lt;p&gt;Если есть желание и время можно работать напрямую с API хранилища, но
все же самостоятельно разбираться с особенностями браузеров - занятие не
благодарное, так что могу посоветовать взглянуть на имеющиеся opensource
библиотеки-обертки. Из тех, что я пробовал, мне больше всего нравится
&lt;strong&gt;&lt;a href="https://www.insight-it.ru/goto/288f4119/" rel="nofollow" target="_blank" title="http://www.jstorage.info/"&gt;jStorage&lt;/a&gt;&lt;/strong&gt;&amp;nbsp;из-за своей "зеленой" таблицы
поддержки браузерами и готовому publish/subscribe API.&lt;/p&gt;
&lt;p&gt;Итак, вкратце пройдемся по ориентировочному алгоритму реализации
межвкладочного взаимодействия:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Каждая вкладка при своем открытии придумывает себе уникальный
    идентификатор (проще всего на основе &lt;em&gt;Math.random&lt;/em&gt;), будем называть
    его &lt;strong&gt;tab_id&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;В хранилище будут храниться список всех активных tab_id, допустим,
    &lt;strong&gt;tabs&lt;/strong&gt; и tab_id &lt;em&gt;главной&lt;/em&gt; &lt;em&gt;вкладки&lt;/em&gt;, допустим,&amp;nbsp;&lt;strong&gt;master&lt;/strong&gt;. Каждая
    новая вкладка смотрит есть ли другие открытые вкладки. Если есть -
    просто дописывает себя в tabs, если нет - то еще и объявляет себя
    главной и открывает соединение с браузером.&lt;/li&gt;
&lt;li&gt;Далее она подписывается на сообщения отправленные лично ей (по её
    tab_id) и на различные типы сообщений, которые могут быть интересны
    всем вкладкам.&lt;/li&gt;
&lt;li&gt;В обработчике события &lt;em&gt;window.onbeforeunload&lt;/em&gt;&amp;nbsp;(происходит сразу же
    перед закрытием вкладки) каждая вкладка убирает себя из &lt;strong&gt;tabs&lt;/strong&gt;&amp;nbsp;и
    если она была главной, то и из &lt;strong&gt;master&lt;/strong&gt; тоже. Альтернативный
    вариант: &lt;strong&gt;master&lt;/strong&gt; сразу может выбирать себе "преемника". Так как
    это событие срабатывает не всегда (когда компьютер жестко вырубился
    питанием, фатальный сбой в браузере, плюс оно не поддерживается
    неоправданно популярной в рунете Оперой и мобильным Safari), то
    придется создать альтернативный механизм проверки активности
    &lt;strong&gt;master&lt;/strong&gt; и очистки &lt;strong&gt;tabs&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Так как какого-либо API для проверки открыта ли вкладка по её
    &lt;strong&gt;tab_id&amp;nbsp;&lt;/strong&gt;по очевидным причинам нет, нужно придумать свою схему.
    Самый простой рабочий вариант, пришедший мне в голову:&lt;ul&gt;
&lt;li&gt;Главная вкладка пишет каждые несколько сотен&amp;nbsp;миллисекунд&amp;nbsp;в
    хранилище текущую дату/время, теоретически так как все
    происходит на одном компьютере, то текущее время во всех
    вкладках должно быть одно и то же;&lt;/li&gt;
&lt;li&gt;Не-главные вкладки каждые 1-3 секунд читают значение из того же
    места в хранилище и если оно отстает от текущего на, допустим,
    больше чем секунду, то главную вкладку, вероятно, закрыли и надо
    её "свергнуть" - удалить из &lt;strong&gt;tabs&lt;/strong&gt; и &lt;strong&gt;master&lt;/strong&gt;&amp;nbsp;и назначить,
    например, первую или последнюю запись из списка&amp;nbsp;&lt;strong&gt;tabs&lt;/strong&gt; новой
    главной вкладкой;&lt;/li&gt;
&lt;li&gt;Если выбранная новая вкладка тоже оказалась уже закрыта, не
    беда - во всех случаях, кроме совсем неадекватных, этот не
    хитрый механизм переберет все&amp;nbsp;&lt;strong&gt;tabs&lt;/strong&gt; и найдет-таки нормальную
    открытую;&lt;/li&gt;
&lt;li&gt;Каждая вкладка подписывается на изменения значения &lt;strong&gt;master&lt;/strong&gt;,
    чтобы если новое значение совпадет с её tab_id открыть
    соединение с сервером.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Отправка сообщений происходит по простому publish/subscribe, где
    master подписывается и ретранслирует в соединение с сервером, а
    отправляют все остальные вкладки. Если вкладка отправляет запрос,
    ответ на который хочет получить только она сама (чаще всего переход
    на другую страницу сайта или отправка формы), то она указывает в
    отправляемом запросе свой "обратный адрес" в виде tab_id. Master,
    получив ответ на такое сообщение с указанным обратным адресом,
    перенаправляет его отправителю.&lt;/li&gt;
&lt;li&gt;Также в хранилище полезно иметь переменную-флаг (также с подпиской
    на изменения), обозначающую открыто ли сейчас где-то постоянное
    соединение, чтобы вместо того, чтобы отправлять сообщения&amp;nbsp;в
    никуда&amp;nbsp;вкладки использовали какой-то альтернативный способ (AJAX или
    переход по ссылке / отправка формы средствами браузера). В качестве
    альтернативы можно реализовать очередь неотправленных сообщений, но
    по факту когда с соединением проблемы, то неизвестно когда они
    устранятся и устранятся ли вообще, так что смысла в ней чаще всего
    мало.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Надеюсь вышеизложенное окажется кому-то полезным, если нужны какие-то
уточнения - не стесняйтесь спрашивать в комментариях.&lt;/p&gt;
&lt;h3 id="minimizatsiia-razmera-soobshchenii"&gt;Минимизация размера сообщений&lt;/h3&gt;
&lt;p&gt;&lt;a href="/tag/json/"&gt;JSON&lt;/a&gt; хоть и сильно выигрывает у &lt;a href="/tag/xml/"&gt;XML&lt;/a&gt;&amp;nbsp;по объему
сериализованных сообщений, но все же является текстовым форматом с
указанием схемы (название для каждого значения) внутри самого сообщения.
Почему минимизация объема передаваемых по постоянному соединению
данных - дело полезное, объяснять, думаю, не стоит.&lt;/p&gt;
&lt;p&gt;Первое, что приходит в голову, чтобы уменьшить объем сообщений -
избавиться от включенной в них схемы, оставив только чистые данные.
Изобретать свой формат ни к чему, есть неплохой&amp;nbsp;широко
распространенный&amp;nbsp;кандидат в виде &lt;a href="/tag/google/"&gt;Google&lt;/a&gt;&amp;nbsp;&lt;a href="/tag/protocol-buffers/"&gt;Protocol
Buffers&lt;/a&gt;. Кстати, недавно нашел библиотеку с
&lt;a href="/tag/javascript/"&gt;JavaScript&lt;/a&gt; реализацией Protocol Buffers с хорошими
отзывами, в ближайшее время думаю сам опробую:
&lt;a href="https://www.insight-it.ru/goto/a420ea/" rel="nofollow" target="_blank" title="https://github.com/sirikata/protojs"&gt;protojs&lt;/a&gt;. Если кто уже работал с
ней - буду рад, если поделитесь впечатлениями.&lt;/p&gt;
&lt;p&gt;Но на практике оказалось, что эта самая схема обычно занимает максимум
10-20% от сообщения, так как большинство данных все же текстовые.
Использование Protocol Buffers было бы намного более выгодным, если бы
было необходимо "упаковать" много чисел или флагов, для текстовых данных
выигрыш намного меньше.&lt;/p&gt;
&lt;p&gt;Экономии в разы можно добиться используя обычные алгоритмы компрессии
(или, если так привычнее, архивации) данных.
&lt;a href="/tag/javascript/"&gt;JavaScrtipt&lt;/a&gt; "из коробки" этого делать не умеет, но
есть полно библиотек на любой вкус и цвет, правда все хромают и чаще
всего не кроссбраузерные. Приведу несколько, которые запомнились после
вечера, проведенного за изучением данного вопроса:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/be52f434/" rel="nofollow" target="_blank" title="http://rosettacode.org/wiki/LZW_compression"&gt;LZW&lt;/a&gt; - есть реализации
    на большинстве языков программирования, но компрессия не очень
    сильная (раза в полтора-два в лучшем случае), плюс реализация под
    интересующий меня &lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt; оказалась дико неэффективна
    по памяти, а на бинарных строках сходу не нашлась.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/49c64f8e/" rel="nofollow" target="_blank" title="https://github.com/imaya/zlib.js"&gt;zlib.js&lt;/a&gt; - умеет &lt;em&gt;zlib (deflate)&lt;/em&gt;
    и &lt;em&gt;gzip&lt;/em&gt;, но, к сожалению, в моем браузере не могла разжать обратно
    то, что сжала, плюс объем кода библиотеки очень большой.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/730dabaf/" rel="nofollow" target="_blank" title="https://github.com/dankogai/js-deflate"&gt;js-deflate&lt;/a&gt; - не
    обновлялась уже 4 года, отсутствует документация, но зато в целом
    работает. Подбирать метод компрессии для серверной стороны пришлось
    почти экспериментально, оказался &lt;em&gt;zlib (deflate)&lt;/em&gt; без заголовков и
    контрольной суммы (в &lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt; встроенная функция zlib:zip). Компрессия примерно в 3-4 раза.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Если все же решите использовать компрессию, то рекомендую реализовать
флаг для ситуаций когда в клиенте все же декомпрессия по каким-то
причинам сломана. Достаточно просто сжать-разжать короткую строку и
сравнить с оригиналом, если не совпало или выскочило исключение -
просить сервер отвечать без компрессии.&lt;/p&gt;
&lt;p&gt;По поводу дополнительных вычислительных ресурсов, которые будут
потребляться на компрессию/декомпрессию, вопрос, конечно, спорный, в
целом надо все мерять и делать выводы. Но если учесть, что почти во всех
современных устройствах, даже телефонах, как минимум 1Ггц процессор, а
на сервере можно кэшировать уже сжатые данные, то это не особо большая
проблема. К слову объем сообщений уменьшается тоже не гарантированно,
бывает что "сжатая" версия оказывается такой же или даже чуть больше,
чем оригинал. В общем, использовать компрессию нужно осторожно :)&lt;/p&gt;
&lt;h2 id="povtornoe-ispolzovanie-shablonov_1"&gt;Повторное использование шаблонов&lt;/h2&gt;
&lt;p&gt;Сообщение со списком шаблонов для использование на клиентской части,
вероятно, будет самым большим по объему и больше других выиграет от
компрессии. Но есть возможность легко минимизировать и количество таких
сообщений. Помните, я писал, что локальное хранилище в браузере можно и
для других целей использовать?&lt;/p&gt;
&lt;p&gt;Кэширование шаблонов - идеальный пример. Получив от сервера шаблоны он
кладет их не только в объект-обертку, но и в локальное хранилище. На
сервере помимо самого JSON'а с шаблонами генерируем хэш (md5, sha или
crc - не важно) текущей версии. Клиент, когда открывает соединение,
сообщает серверу есть ли у него какая-то версия и если есть, то какая,
сервер отправляет новую версию в ответ только если хэши не совпали.&lt;/p&gt;
&lt;p&gt;Аналогичным образом можно кэшировать и другую редко меняющуюся объемную
информацию, например данные для автодополнения в текстовых полях
&lt;em&gt;(autocomplete)&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id="zakliuchenie"&gt;Заключение&lt;/h2&gt;
&lt;p&gt;Надеюсь предложенные в этой статье приемы окажутся Вам полезны. Буду
рад, если Вы поделитесь своим опытом и приемами по данной теме в
комментариях, а также с удовольствием обсужу подробности.&lt;/p&gt;
&lt;div class="card green"&gt;
&lt;p&gt;&lt;div class="card-content white-text"&gt;
Эта статья - шестая и заключительная в &lt;a class="green-text text-lighten-4" href="https://www.insight-it.ru/interactive/"&gt;серии про Интерактивные сайты&lt;/a&gt;, автор - &lt;a class="green-text text-lighten-4" href="https://www.insight-it.ru/goto/b03d9116/" rel="nofollow" target="_blank" title="http://blinkov.ru"&gt;Иван&amp;nbsp;Блинков&lt;/a&gt;, основано на личном опыте.
До встречи &lt;a class="green-text text-lighten-4" href="/feed/"&gt;на страницах Insight IT&lt;/a&gt;!
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sat, 20 Oct 2012 12:32:00 +0400</pubDate><guid>tag:www.insight-it.ru,2012-10-20:interactive/2012/optimizaciya-interaktivnykh-sajjtov/</guid><category>deflate</category><category>html5</category><category>JavaScript</category><category>JSON</category><category>jStorage</category><category>Protocol Buffers</category><category>Web Storage</category><category>zlib</category><category>клиентская оптимизация</category><category>компрессия</category><category>кэширование</category><category>оптимизация</category></item><item><title>Архитектура Google 2011</title><link>https://www.insight-it.ru//highload/2011/arkhitektura-google-2011/</link><description>&lt;p&gt;&lt;a href="https://www.insight-it.ru/highload/2008/arkhitektura-google/"&gt;Архитектура Google&lt;/a&gt;
была одной из первых статьей на &lt;strong class="trebuchet"&gt;Insight IT&lt;/strong&gt;. Именно она дала толчок развитию проекта: после её публикации посещаемость блога увеличилась в десятки раз и появились первые сотни подписчиков. Прошли годы, информация устаревает стремительно, так что пришло время взглянуть на Google еще раз, теперь уже с позиции конца 2011 года. Что мы увидим нового в архитектуре интернет-гиганта?
&lt;!--more--&gt;&lt;/p&gt;
&lt;h2 id="statistika"&gt;Статистика&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Общее&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Ежедневная аудитория Google составляет около 1 миллиарда
    человек&lt;/em&gt;&lt;ul&gt;
&lt;li&gt;По данным Alexa больше половины аудитории интернета каждый
    день пользуются Google&lt;/li&gt;
&lt;li&gt;По данным IWS аудитория интернета составляет 2.1 миллиарда
    человек&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Используется более 900 тысяч серверов&lt;/em&gt;&lt;ul&gt;
&lt;li&gt;Планируется расширение до 10 миллионов серверов в обозримом
    будущем&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/4cb67b65/" rel="nofollow" target="_blank" title="http://www.google.com/about/datacenters/locations/index.html"&gt;12 основных датацентров в США&lt;/a&gt;,
    присутствие в большом количестве точек по всему миру (более 38)&lt;/li&gt;
&lt;li&gt;Около 32 тысяч сотрудников в 76 офисах по всему миру&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Поиск&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;За последние 14 лет среднее время обработки одного поискового
    запроса уменьшилось с 3 секунд до менее 100 миллисекунд, то есть
    в 30 раз&lt;/li&gt;
&lt;li&gt;Более 40 миллиардов страниц в индексе, если приравнять каждую к
    листу А4 они бы покрыли территорию США в 5 слоев&lt;/li&gt;
&lt;li&gt;Более 1 квинтиллиона уникальных URL (10 в 18 степени); если
    распечатать их в одну строку, её длина составит 51 миллион
    километров, треть расстояния от Земли до Солнца&lt;/li&gt;
&lt;li&gt;В интернете встречается примерно 100 квинтиллионов слов, чтобы
    набрать их на клавиатуре одному человеку потребовалось бы
    примерно 5 миллионов лет&lt;/li&gt;
&lt;li&gt;Проиндексировано более 1.5 миллиардов изображений, чтобы их
    сохранить потребовалось бы 112 миллионов дискет, которые можно
    сложить в стопку высотой 391 километр&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gmail&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;Активных пользователей более 170 миллионов&lt;/li&gt;
&lt;li&gt;Второй по популярности почтовый сервис в США, третий в мире (по
    данным comScore)&lt;/li&gt;
&lt;li&gt;При текущем темпе роста аудитории GMail и конкурентов, он станет
    лидером рынка через 2-3 года&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Google+&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;Более 40 миллионов пользователей на октябрь 2011, при запуске в
    июне 2011&lt;/li&gt;
&lt;li&gt;25 миллионов пользователей за первый месяц&lt;/li&gt;
&lt;li&gt;70:30 примерное соотношение мужчин и женщин&lt;/li&gt;
&lt;li&gt;Себестоимость разработки больше полумиллиарда долларов&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;YouTube&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;Загружается более 13 миллионов часов видео в год&lt;/li&gt;
&lt;li&gt;Каждую минуту загружается 48 часов видео, что соответствует
    почти 8 годам контента или 52 тысячам полнометражных фильмов в
    день&lt;/li&gt;
&lt;li&gt;Более 700 миллиардов просмотров видео в год&lt;/li&gt;
&lt;li&gt;Месячная аудитория составляет 800 миллионов уникальных
    посетителей&lt;/li&gt;
&lt;li&gt;Несколько тысяч полнометражных фильмов в &lt;a href="https://www.insight-it.ru/goto/18cd7d94/" rel="nofollow" target="_blank" title="http://www.youtube.com/movies"&gt;YouTube Movies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Более 10% всех видео в формате HD&lt;/li&gt;
&lt;li&gt;13% просмотров (400 миллионов в день) происходит с мобильных
    устройств&lt;/li&gt;
&lt;li&gt;До сих пор работает в убыток, лишь 14% просмотров видео приносят
    выручку с рекламы&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Финансы&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;Выручка порядка 36 миллиардов долларов в год&lt;/li&gt;
&lt;li&gt;Прибыль после налогов порядка 10 миллиардов долларов в год&lt;/li&gt;
&lt;li&gt;Капитализация порядка 200 миллиардов долларов&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="arkhitektura"&gt;Архитектура&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Google&lt;/strong&gt; - огромная интернет-компания, неоспоримый лидер на рынке
поиска в Интернет и владелец большого количества продуктов, многие из
которых также добились определенного успеха в своей нише.&lt;/p&gt;
&lt;p&gt;В отличии от большинства интернет-компаний, которые занимаются лишь
одним продуктом (проектом), архитектура Google не может быть
представлена как единое конкретное техническое решение. Сегодня мы
скорее будем рассматривать общую стратегию технической реализации
интернет-проектов в Google, возможно слегка затрагивая и другие аспекты
ведения бизнеса в Интернет.&lt;/p&gt;
&lt;p&gt;Все продукты Google основываются на постоянно развивающейся программной
платформе, которая спроектирована с учетом работы на миллионах серверов,
находящихся в разных датацентрах по всему миру.&lt;/p&gt;
&lt;h3 id="oborudovanie"&gt;Оборудование&lt;/h3&gt;
&lt;p&gt;Обеспечение работы миллиона серверов и расширение их парка - одна из
ключевых статей расходов Google. Для минимизации этих издержек очень
большое внимание уделяется эффективности используемого серверного,
сетевого и инфраструктурного оборудования.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Использование энергии" class="right" src="https://www.insight-it.ru/images/dc-home-energy-use.png" title="Использование энергии"/&gt;&lt;/p&gt;
&lt;p&gt;В традиционных датацентрах потребление электричества серверами примерно
равно его потреблению остальной инфраструктурой, Google же удалось
снизить процент использования дополнительной электроэнергии до 14%.
Таким образом суммарное энергопотребление датацентром Google сравнимо с
потреблением только серверов в типичном датацентре и вдвое меньше его
общего энергопотребления. Основные концепции, которые используются для
достижения этого результата:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Точное измерение потребления электроэнергии всеми компонентами
    позволяет определить возможности по его уменьшению;&lt;/li&gt;
&lt;li&gt;В датацентрах Google тепло, что позволяет экономить на охлаждении;&lt;/li&gt;
&lt;li&gt;При проектировании датацентра уделяется внимание даже незначительным
    деталям, позволяющим сэкономить даже немного - при таком масштабе
    это окупается;&lt;/li&gt;
&lt;li&gt;Google умеет охлаждать датацентры практически без кондиционеров, с
    использованием воды и её испарения &lt;em&gt;(см. &lt;a href="https://www.insight-it.ru/goto/d1cf5d6b/" rel="nofollow" target="_blank" title="http://www.youtube.com/watch?v=VChOEvKicQQ"&gt;как это реализовано&lt;/a&gt; в Финляндии)&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В Google активно&amp;nbsp;пропагандируют максимальное использование
возобновляемой энергии. Для этого заключаются долгосрочные соглашения с
её поставщиками (на 20 и более лет), что позволяет отрасли активно
развиваться и наращивать мощности. Проекты по генерации возобновляемой
энергии, спонсируемые Google, имеют суммарную мощность более 1.7
гигаватт, что существенно больше, чем используется для работы Google.
Этой мощности хватило бы для обеспечения электричеством 350 тысяч домов.&lt;/p&gt;
&lt;p&gt;Если говорить о жизненном цикле оборудования, то используются следующие
принципы:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Уменьшение транспортировки:&lt;/strong&gt; там, где это возможно, тяжелые
    компоненты (вроде серверных стоек) закупаются у местных поставщиков,
    даже если в других местах аналогичный товар можно было бы купить
    дешевле.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Повторное использование:&lt;/strong&gt; прежде, чем покупать новое оборудование
    и материалы, рассматриваются возможности по использованию уже
    имеющихся. Этот принцип помог избежать покупки более 90 тысяч новых
    серверов.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Утилизация&lt;/strong&gt;: в тех случаях, когда повторное использование
    невозможно, оборудование полностью очищается от данных и продается
    на вторичном рынке. То, что не удается продать, разбирается на
    материалы (медь, сталь, алюминий, пластик и.т.п.) для последующей
    правильной утилизации специализированными компаниями.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Google известны за свои эксперименты и необычные решения в области
серверного оборудования и инфраструктуры. Некоторые запатентованы;
какие-то прижились, какие-то - нет. Подробно останавливаться на них не
буду, лишь вкратце о некоторых:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Резервное питание, интегрированное в блок питания
    &lt;a href="https://www.insight-it.ru/goto/ca5b8b43/" rel="nofollow" target="_blank" title="http://www.youtube.com/watch?v=xgRWURIxgbU"&gt;сервера&lt;/a&gt;, обеспеченное
    стандартными 12V батарейками;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/c7f3ff41/" rel="nofollow" target="_blank" title="http://www.datacenterknowledge.com/closer-look-googles-server-sandwich-design/"&gt;"Серверный сендвич"&lt;/a&gt;,
    где материнские платы с двух сторон окружают водяную систему
    теплоотвода в центре стойки;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/8dc33e81/" rel="nofollow" target="_blank" title="http://www.youtube.com/watch?v=zRwPSFpLX8I"&gt;Датацентр из контейнеров&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В заключении этого раздела хотелось бы взглянуть правде в глаза:
&lt;strong&gt;идеального оборудования не бывает&lt;/strong&gt;. У любого современного устройства,
будь то сервер, коммутатор или маршрутизатор, есть шанс прийти в
негодность из-за производственного брака, случайного стечения
обстоятельств или других внешних факторов. Если умножить этот, казалось
бы, небольшой шанс на количество оборудования, которое используется в
Google, то окажется, что чуть ли не каждую минуту из строя выходит одно,
или несколько, устройств в системе. На оборудование полагаться нельзя,
по-этому вопрос отказоустойчивости переносится на плечи программной
платформы, которую мы сейчас и рассмотрим.&lt;/p&gt;
&lt;h3 id="platforma"&gt;Платформа&lt;/h3&gt;
&lt;p&gt;В Google очень рано столкнулись с проблемами ненадежности оборудования и
работы с огромными массивами данных. Программная платформа,
спроектированная для работы на многих недорогих серверах, позволила им
абстрагироваться от сбоев и ограничений одного сервера.&lt;/p&gt;
&lt;p&gt;Основными задачами в ранние годы была минимизация точек отказа и
обработка больших объемов слабоструктурированных данных. Решением этих
задач стали три основных слоя платформы Google, работающие один поверх
другого:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://www.insight-it.ru/goto/479dfa95/" rel="nofollow" target="_blank" title="http://research.google.com/archive/gfs.html"&gt;Google File System&lt;/a&gt;:&lt;/strong&gt;
    распределенная файловая система, состоящая из сервера с метаданными
    и теоретически неограниченного количества серверов, хранящих
    произвольные данные в блоках фиксированного размера.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://www.insight-it.ru/goto/f56e059a/" rel="nofollow" target="_blank" title="http://research.google.com/archive/bigtable.html"&gt;BigTable&lt;/a&gt;:&lt;/strong&gt;
    распределенная база данных, использующая для доступа к данным две
    произвольных байтовых строки-ключа (обозначающие строку и столбец) и
    дату/время (обеспечивающие версионность).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://www.insight-it.ru/goto/dbd8fea6/" rel="nofollow" target="_blank" title="http://research.google.com/archive/mapreduce.html"&gt;MapReduce&lt;/a&gt;:&lt;/strong&gt;
    механизм распределенной обработки больших объемов данных,
    оперирующий парами ключ-значение для получения требуемой информации.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Такая комбинация, дополненная другими технологиями, довольно долгое
время позволяла справляться с индексацией Интернета, пока... скорость
появления информации в Интернете не начала расти огромными темпами из-за
"бума социальных сетей". Информация, добавленная в индекс даже через
полчаса, уже зачастую становилась устаревшей.&amp;nbsp;В дополнение к этому в
рамках самого Google стало появляться все больше продуктов,
предназначенных для работы в реальном времени.&lt;/p&gt;
&lt;p&gt;Спроектированные с учетом совершенно других требований Интернета
пятилетней давности компоненты, составляющие ядро платформы Google,
потребовали фундаментальной смены архитектуры индексации и поиска,
который около года назад был представлен публике&amp;nbsp;под кодовым названием
&lt;strong&gt;Google Caffeine&lt;/strong&gt;. Новые, переработанные, версии старых "слоев" также
окрестили броскими именами, но резонанса у технической публики они
вызвали намного меньше, чем новый поисковый алгоритм в SEO-индустрии.&lt;/p&gt;
&lt;h4&gt;Google Colossus&lt;/h4&gt;
&lt;p&gt;Новая архитектура GFS была спроектирована для минимизации задержек при
доступе к данным (что критично для приложений вроде GMail и YouTube), не
в ущерб основным свойствам старой версии: отказоустойчивости и
прозрачной масштабируемости.&lt;/p&gt;
&lt;p&gt;В оригинальной же реализации упор был сделан на повышение общей
пропускной способности: операции объединялись в очереди и выполнялись
разом, при таком подходе можно было прождать пару секунд еще до того,
как первая операция в очереди начнет выполняться. Помимо этого в старой
версии было большое слабое место в виде единственно мастер-сервера с
метаданными, сбой в котором грозил недоступностью всей файловой системы
в течении небольшого промежутка времени (пока другой сервер не подхватит
его функции, изначально это занимало около 5 минут, в последних версиях
порядка 10 секунд) - это также было вполне допустимо при отсутствии
требования работы в реальном времени, но для приложений, напрямую
взаимодействующих с пользователями, это было неприемлемо с точки зрения
возможных задержек.&lt;/p&gt;
&lt;p&gt;Основным нововведением в Colossus стали распределенные мастер-сервера,
что позволило избавиться не только от единственной точки отказа, но и
существенно уменьшить размер одного блока с данными (с 64 до 1
мегабайта), что в целом очень положительно сказалось на работе с
небольшими объемами данных. В качестве бонуса исчез теоретический предел
количества файлов в одной системе.&lt;/p&gt;
&lt;p&gt;Детали распределения ответственности между мастер-серверами, сценариев
реакции на сбои, а также сравнение по задержкам и пропускной
способности обоих версий, к сожалению, по-прежнему конфиденциальны. Могу
предположить, что используется вариация на тему хэш-кольца с репликацией
метаданных на ~3 мастер-серверах, с созданием дополнительной копии на
следующем по кругу сервере в случае в случае сбоев, но это лишь догадки.
Если у кого-то есть относительно официальная информация на этот счет -
буду рад увидеть в комментариях.&lt;/p&gt;
&lt;p&gt;По прогнозам Google текущий вариант реализации распределенной файловой
системы "уйдет на пенсию" в 2014 году из-за популяризации твердотельных
накопителей и существенного скачка в области вычислительных технологий
(процессоров).&lt;/p&gt;
&lt;h4&gt;Google Percolator&lt;/h4&gt;
&lt;p&gt;MapReduce отлично справлялся с задачей полной перестройки поискового
индекса, но не предусматривал небольшие изменения, затрагивающие лишь
часть страниц. Из-за потоковой, последовательной природы MapReduce для
внесения изменений в небольшую часть документов все равно пришлось бы
обновлять весь индекс, так как новые страницы непременно будут каким-то
образом связаны со старыми. Таким образом задержка между появлением
страницы в Интернете и в поисковом индексе при использовании MapReduce
была пропорциональна общему размеру индекса (а значит и Интернета,
который постоянно растет), а не размеру набора измененных документов.&lt;/p&gt;
&lt;p&gt;Ключевые архитектурные решения, лежащие в основе MapReduce, не позволяли
повлиять на эту особенность и в итоге система индексации была построена
заново с нуля, а MapReduce продолжает использоваться в других проектах
Google для аналитики и прочих задач, по прежнему не связанных с реальным
временем.&lt;/p&gt;
&lt;p&gt;Новая система получила довольно своеобразное название &lt;strong&gt;Percolator&lt;/strong&gt;,
попытки узнать что оно значит приводит к различным устройствам по
фильтрации дыма, кофеваркам и непойми чему еще. Но наиболее адекватное
объяснение мне пришло в голову, когда я прочитал его по слогам: per
col - &lt;em&gt;по колонкам&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Percolator представляет собой надстройку над BigTable, позволяющую
выполнять комплексные вычисления на основе имеющихся данных,
затрагивающие много строк и даже таблиц одновременно (в стандартном API
BigTable это не предусмотрено).&lt;/p&gt;
&lt;p&gt;Веб-документы или любые другие данные изменяются/добавляются в систему
посредством модифицированного API BigTable, а дальнейшие изменения в
остальной базе осуществляются посредством механизма&amp;nbsp;"обозревателей".
Если говорить в терминах реляционных СУБД, то обозреватели - что-то
среднее между триггерами и хранимыми процедурами. Обозреватели
представляют собой подключаемый к базе данных код (на &lt;a href="/tag/c/"&gt;C++&lt;/a&gt;),
который исполняется в случае возникновении изменений в определенных
&lt;em&gt;колонках&lt;/em&gt; BigTable (откуда, видимо, и пошло название). Все используемые
системой метаданные также хранятся в специальных колонках BigTable. При
использовании Percolator все изменения происходят в транзакциях,
удовлетворяющих принципу ACID, каждая из которых затрагивает именно те
сервера в кластере, на которых необходимо внести изменения. Механизм
транзакций на основе BigTable разрабатывался в рамках отдельного проекта
под названием &lt;a href="https://www.insight-it.ru/storage/2011/google-megastore/"&gt;Google Megastore&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Таким образом, при добавлении нового документа (или его версии) в
поисковый индекс, вызывается цепная реакция изменений в старых
документах, скорее всего ограниченная по своей рекурсивности. Эта
система при осуществлении случайного доступа поддерживает индекс в
актуальном состоянии.&lt;/p&gt;
&lt;p&gt;В качестве бонуса в этой схеме удалось избежать еще двух недостатков
MapReduce:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Проблемы "отстающих":&lt;/strong&gt; когда один из серверов (или одна из
    конкретных подзадач) оказывался существенно медленнее остальных, что
    также значительно задерживало общее время завершения работы
    кластера.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Пиковая нагрузка:&lt;/strong&gt; MapReduce не является непрерывным процессом, а
    разделяется на работы с ограниченной целью и временем исполнения.
    Таким образом помимо необходимости ручной настройки работ и их
    типов, кластер имеет очевидные периоды простоя и пиковой нагрузки,
    что ведет к неэффективному использованию вычислительных ресурсов.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Но все это оказалось не бесплатно: при переходе на новую систему удалось
достичь той же скорости индексации, но при этом использовалось &lt;em&gt;вдвое&lt;/em&gt;
больше вычислительных ресурсов. Производительность Percolator находится
где-то между производительностью MapReduce и производительностью
традиционных СУБД. Так как Percolator является распределенной системой,
для обработки фиксированного небольшого количества данных ей приходится
использовать существенно больше ресурсов, чем традиционной СУБД; такова
цена масштабируемости. По сравнению с MapReduce также пришлось платить
дополнительными потребляемыми вычислительными ресурсами за возможность
случайного доступа с низкой задержкой.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Google Percolator Benchmark" class="left" src="https://www.insight-it.ru/images/google-percolator-benchmark.png" title="Google Percolator Benchmark"/&gt;&lt;/p&gt;
&lt;p&gt;Тем не менее, при выбранной архитектуре Google удалось достичь
практически линейного масштабирования при увеличении вычислительных
мощностей на много порядков &lt;em&gt;(см. график, основан на тесте TPC-E)&lt;/em&gt;.
Дополнительные накладные расходы, связанные с распределенной природой
решения, в некоторых случаях до 30 раз превосходят аналогичный
показатель традиционных СУБД, но у данной системы есть солидный простор
для оптимизации в этом направлении, чем Google активно и занимается.&lt;/p&gt;
&lt;h4&gt;Google Spanner&lt;/h4&gt;
&lt;p&gt;Spanner представляет собой единую систему автоматического управления
ресурсами &lt;strong&gt;всего парка серверов&lt;/strong&gt; Google.&lt;/p&gt;
&lt;p&gt;Основные особенности:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Единое пространство имен:&lt;ul&gt;
&lt;li&gt;Иерархия каталогов&lt;/li&gt;
&lt;li&gt;Независимость от физического расположения данных&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Поддержка слабой и сильной целостности данных между датацентрами&lt;/li&gt;
&lt;li&gt;Автоматизация:&lt;ul&gt;
&lt;li&gt;Перемещение и добавление реплик данных&lt;/li&gt;
&lt;li&gt;Выполнение вычислений с учетом ограничений и способов
    использования&lt;/li&gt;
&lt;li&gt;Выделение ресурсов на всех доступных серверах&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Зоны полу-автономного управления&lt;/li&gt;
&lt;li&gt;Восстановление целостности после потерь соединения между
    датацентрами&lt;/li&gt;
&lt;li&gt;Возможность указания пользователями высокоуровневых требований,
    например:&lt;ul&gt;
&lt;li&gt;99% задержек при доступе к этим данным должны быть до 50 мс&lt;/li&gt;
&lt;li&gt;Расположи эти данные на как минимум 2 жестких дисках в Европе, 2
    в США и 1 в Азии&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Интеграция не только с серверами, но и с сетевым оборудованием, а
    также системами охлаждения в датацентрах&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Проектировалась из расчета на:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1-10 миллионов серверов&lt;/li&gt;
&lt;li&gt;~10 триллионов директорий&lt;/li&gt;
&lt;li&gt;~1000 петабайт данных&lt;/li&gt;
&lt;li&gt;100-1000 датацентров по всему миру&lt;/li&gt;
&lt;li&gt;~1 миллиард клиентских машин&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Об этом проекте Google известно очень мало, официально он был
представлен публике лишь однажды в 2009 году, с тех пор лишь местами
упоминался сотрудниками без особой конкретики. Точно не известно
развернута ли эта система на сегодняшний день и если да, то в какой
части датацентров, а также каков статус реализации заявленного
функционала.&lt;/p&gt;
&lt;h4&gt;Прочие компоненты платформы&lt;/h4&gt;
&lt;p&gt;Платформа Google в конечном итоге сводится к набору сетевых сервисов и
библиотек для доступа к ним из различных языков программирования (в
основном используются&amp;nbsp;&lt;a href="/tag/c/"&gt;C/C++&lt;/a&gt;,&amp;nbsp;&lt;a href="/tag/java/"&gt;Java&lt;/a&gt;,&amp;nbsp;&lt;a href="/tag/python/"&gt;Python&lt;/a&gt; и&amp;nbsp;&lt;a href="/tag/perl/"&gt;Perl&lt;/a&gt;). Каждый продукт, разрабатываемый Google, в большинстве случаев использует эти библиотеки для осуществления доступа к данным, выполнения комплексных вычислений и других задач, вместо стандартных механизмов, предоставляемых операционной системой, языком программирования или opensource библиотеками.&lt;/p&gt;
&lt;p&gt;Вышеизложенные проекты составляют лишь основу платформы Google, хотя она
включает в себя куда больше готовых решений и библиотек, несколько
примеров из публично доступных проектов:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/f5686a9/" rel="nofollow" target="_blank" title="http://code.google.com/webtoolkit/"&gt;GWT&lt;/a&gt; для реализации
    пользовательских интерфейсов на &lt;a href="/tag/java/"&gt;Java&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/7f9cb797/" rel="nofollow" target="_blank" title="http://code.google.com/closure/"&gt;Closure&lt;/a&gt; - набор инструментов для
    работы с &lt;a href="/tag/javascript/"&gt;JavaScript&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/41604156/" rel="nofollow" target="_blank" title="http://code.google.com/apis/protocolbuffers/"&gt;Protocol Buffers&lt;/a&gt; -
    не зависящий от языка программирования и платформы формат бинарной
    сериализации структурированных данных, используется при
    взаимодействии большинства компонентов системы внутри Google;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/bb496d06/" rel="nofollow" target="_blank" title="http://code.google.com/p/leveldb/"&gt;LevelDB&lt;/a&gt; -
    высокопроизводительная встраиваемая &lt;a href="/tag/subd/"&gt;СУБД&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/44c46d8/" rel="nofollow" target="_blank" title="http://code.google.com/p/snappy/"&gt;Snappy&lt;/a&gt; - быстрая компрессия
    данных, используется при хранении данных в GFS.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="podvodim-itogi_1"&gt;Подводим итоги&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Стабильные, проработанные и повторно используемые базовые
    компоненты проекта&lt;/strong&gt; &lt;em&gt;- залог её стремительного развития, а также
    создания новых проектов на той же кодовой базе&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Если задачи и обстоятельства, с учетом которых проектировалась
    система, существенно изменились&amp;nbsp;&lt;em&gt;- не бойтесь вернуться на стадию проектирования и реализовать новое решение&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Используйте инструменты, подходящие для решения каждой конкретной
    задачи&lt;/em&gt;, а не те, которые навязывает мода или привычки участников
    команды.&lt;/li&gt;
&lt;li&gt;Даже, казалось бы, незначительные недоработки и допущения на большом
    масштабе могут вылиться в огромные потери &lt;em&gt;- уделяйте максимум
    внимания деталям при реализации проекта.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Нельзя полагаться даже на очень дорогое оборудование &lt;em&gt;- все ключевые
    сервисы должны работать минимум на двух серверах, в том числе и базы
    данных.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Распределенная платформа, общая для всех проектов, позволит новым
    разработчикам легко вливаться в работу над конкретными продуктами, с
    минимумом представления о внутренней архитектуре компонентов
    платформы.&lt;/li&gt;
&lt;li&gt;Прозрачная работа приложений в нескольких датацентрах - одна из
    самых тяжелых задач, с которыми сталкиваются интернет-компании.
    Сегодня каждая из них решает её по-своему и держит подробности в
    секрете, что сильно замедляет развитие opensource решений.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="istochniki-informatsii"&gt;Источники информации&lt;/h2&gt;
&lt;p&gt;Не гарантирую достоверность всех нижеизложенных источников информации,
ставших основой для данной статьи, но ввиду конфиденциальности подобной
информации на большее рассчитывать не приходится.&lt;/p&gt;
&lt;p&gt;Поправки и уточнения приветствуются :)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://www.insight-it.ru/goto/4431029a/" rel="nofollow" target="_blank" title="http://www.google.com/about/datacenters/index.html"&gt;Official Google Data Centers
    Site&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/7437fe8a/" rel="nofollow" target="_blank" title="http://research.google.com/people/jeff/WSDM09-keynote.pdf"&gt;Challenges in Building Large-Scale Information Retrieval
    Systems&lt;/a&gt;
    (Jeff Dean, WCDMA '09)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/7f1ddbff/" rel="nofollow" target="_blank" title="http://www.odbms.org/download/dean-keynote-ladis2009.pdf"&gt;Designs, Lessons and Advice from Building Large Distributed
    Systems&lt;/a&gt;
    (Jeff Dean, Ladis '09)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://www.insight-it.ru/goto/6ec4bc06/" rel="nofollow" target="_blank" title="http://research.google.com/pubs/pub36726.html"&gt;Google Percolator official
    paper&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/3473b129/" rel="nofollow" target="_blank" title="http://research.google.com/pubs/pub36971.html"&gt;&lt;em&gt;Google Megastore official
    paper&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://www.insight-it.ru/goto/dd8bec64/" rel="nofollow" target="_blank" title="http://www.theregister.co.uk/2010/09/24/google_percolator/"&gt;Google
    Percolator&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://www.insight-it.ru/goto/82efffd8/" rel="nofollow" target="_blank" title="http://www.theregister.co.uk/2010/09/09/google_caffeine_explained/"&gt;Google Caffeine
    Explained&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/63b6ec67/" rel="nofollow" target="_blank" title="http://www.theregister.co.uk/2009/10/23/google_spanner/"&gt;Google
    Spanner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/46520ede/" rel="nofollow" target="_blank" title="http://www.theregister.co.uk/2011/06/08/google_software_infrastructure_dubbed_obsolete_by_ex_employee/"&gt;Google Software Infrastructure Dubbed Obsolete by
    ex-Employee&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://www.insight-it.ru/goto/49879386/" rel="nofollow" target="_blank" title="http://www.theregister.co.uk/2011/06/23/google_moves_off_the_google_file_system/"&gt;Google Moves Off the Google File
    System&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://www.insight-it.ru/goto/745a779b/" rel="nofollow" target="_blank" title="http://www.google.co.uk/intl/en/landing/internetstats/"&gt;Google Internet
    Stats&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://www.insight-it.ru/goto/d11024ba/" rel="nofollow" target="_blank" title="http://www.businessblogshub.com/2010/10/google-statistics-yes-they-are-very-big/"&gt;Google
    Statistics&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://www.insight-it.ru/goto/bb33b2dd/" rel="nofollow" target="_blank" title="http://www.splashnology.com/article/google-plus-killer-facts-and-statistics-inforgaphics/2689/"&gt;Google Plus - Killer Facts and
    Statistics&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://www.insight-it.ru/goto/d20404a7/" rel="nofollow" target="_blank" title="http://www.youtube.com/t/press_statistics"&gt;YouTube statistics&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/9909f6c8/" rel="nofollow" target="_blank" title="http://www.alexa.com/siteinfo/google.com"&gt;&lt;em&gt;Alexa on Google&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/b088e740/" rel="nofollow" target="_blank" title="http://www.internetworldstats.com/stats.htm"&gt;&lt;em&gt;Internet World
    Stats&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://www.insight-it.ru/goto/86a009d0/" rel="nofollow" target="_blank" title="http://www.google.com/finance?fstype=bi&amp;amp;cid=694653"&gt;Google Inc.
    financials&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://www.insight-it.ru/goto/2515e26d/" rel="nofollow" target="_blank" title="http://www.geekwire.com/2011/stats-hotmail-top-worldwide-gmail-posts-big-gains"&gt;Hotmail still on top worldwide; Gmail gets
    bigger&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/2428f635/" rel="nofollow" target="_blank" title="http://www.datacenterknowledge.com/archives/2011/08/01/report-google-uses-about-900000-servers/"&gt;&lt;em&gt;Google Server
    Count&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://www.insight-it.ru/goto/b6d09313/" rel="nofollow" target="_blank" title="http://www.datacenterknowledge.com/archives/2009/10/20/google-envisions-10-million-servers/"&gt;Google Envisions 10 Million
    Servers&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/bb3d77a4/" rel="nofollow" target="_blank" title="http://www.datacenterknowledge.com/archives/2008/03/27/google-data-center-faq/"&gt;&lt;em&gt;Google Data Center
    FAQ&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="bonus-tipichnyi-pervyi-god-klastera-v-google"&gt;Бонус: типичный первый год кластера в Google&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;~1/2 перегрева (большинство серверов выключаются в течении 5 минут,
    1-2 дня на восстановление)&lt;/li&gt;
&lt;li&gt;~1 отказ распределителя питания (~500-1000 резко пропадают, ~6
    часов на восстановление)&lt;/li&gt;
&lt;li&gt;~1 передвижение стойки (много передвижений, 500-100 машин, 6 часов)&lt;/li&gt;
&lt;li&gt;~1 перепрокладка сети (последовательной отключение ~5% серверов на
    протяжении 2 дней)&lt;/li&gt;
&lt;li&gt;~20 отказов стоек (40-80 машин мгновенно исчезают, 1-6 часов на
    восстановление)&lt;/li&gt;
&lt;li&gt;~5 стоек становится нестабильными (40-80 машин сталкиваются с 50%
    потерей пакетов)&lt;/li&gt;
&lt;li&gt;~8 запланированных технических работ с сетью (при четырех могут
    случаться случайные получасовые потери соединения)&lt;/li&gt;
&lt;li&gt;~12 перезагрузок маршрутизаторов (потеря DNS и внешних виртуальных
    IP на несколько минут)&lt;/li&gt;
&lt;li&gt;~3 сбоя маршрутизаторов (восстановление в течении часа)&lt;/li&gt;
&lt;li&gt;Десятки небольших 30-секундных пропаданий DNS&lt;/li&gt;
&lt;li&gt;~1000 сбоев конкретных серверов (~3 в день)&lt;/li&gt;
&lt;li&gt;Много тысяч сбоев жестких дисков, проблем с памятью, ошибок
    конфигурации и т.п.&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Mon, 28 Nov 2011 01:32:00 +0400</pubDate><guid>tag:www.insight-it.ru,2011-11-28:highload/2011/arkhitektura-google-2011/</guid><category>BigTable</category><category>Caffeine</category><category>Closure</category><category>GFS</category><category>Google</category><category>GWT</category><category>highload</category><category>Percolator</category><category>Protocol Buffers</category><category>Snappy</category><category>Spanner</category><category>архитектура Google</category><category>датацентры</category><category>Масштабируемость</category><category>энергоэффективность</category></item></channel></rss>
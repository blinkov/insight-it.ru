<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Insight IT</title><link>https://www.insight-it.ru/</link><description></description><atom:link href="https://www.insight-it.ru/category/erlang/feed/index.xml" rel="self"></atom:link><lastBuildDate>Fri, 22 Jun 2012 01:27:00 +0400</lastBuildDate><item><title>Основы Erlang: синтаксис и пунктуация</title><link>https://www.insight-it.ru//erlang/2012/osnovy-erlang-sintaksis-i-punktuaciya/</link><description>&lt;p&gt;Мои теоретичесие рассуждения о &lt;a href="https://www.insight-it.ru/erlang/2012/erlang-v-internet-proektakh/"&gt;месте Erlang в &lt;del&gt;современном мире&lt;/del&gt;
Интернете&lt;/a&gt;&amp;nbsp;Вы
можете почитать в отдельной статье. Если сомневаетесь интересно Вам это
все или нет - то прочтите сначала её. Сегодня я постараюсь вернуться с
небес на землю и пройтись по азам этого пугающего многих языка
программирования. Коротко и по делу.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Установка ничем особым не выделяется, дистрибутив рекомендую брать
&lt;a href="https://www.insight-it.ru/goto/d3cd3653/" rel="nofollow" target="_blank" title="http://www.erlang-solutions.com/section/98/download-erlang-packages"&gt;отсюда&lt;/a&gt;,
если до сих пор пользуетесь отсутствующей в списке ОС - лучше сначала
исправить этот факт.&lt;/p&gt;
&lt;p&gt;После установки в &lt;code&gt;$PATH&lt;/code&gt; окажутся исполняемые файлы:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;erl&lt;/strong&gt; - одновременно интерактивная консоль и запуск приложений;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;erlc&lt;/strong&gt; - компилятор в байт-код для виртуальной машины BEAM или
    нативный код посредством HiPE, напрямую использовать не придется
    практически.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Со всем что будет обсуждаться в этой статье можно эксперементировать
просто в интерактивной консоли, которая запускается просто командой
&lt;strong&gt;erl&lt;/strong&gt; без аргументов.&lt;/p&gt;
&lt;h2 id="punktuatsiia"&gt;Пунктуация&lt;/h2&gt;
&lt;p&gt;Сразу скажу, что пунктуация в Erlang довольно своеобразна, больше похожа
на русский язык, чем на другие языки программирования. По крайней мере я
именно этой ассоциацией пользовался, когда запоминал.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Все функции заканчиваются &lt;strong&gt;точкой&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;После каждого выражения в функции - &lt;strong&gt;запятая;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Все ветви кода &lt;code&gt;(case, if, ...)&lt;/code&gt;, кроме последней, заканчиваются
    &lt;strong&gt;точкой с запятой&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;После заголовка функции и условий ветвления пишется &lt;strong&gt;стрелка&lt;/strong&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Маленькая демонстрация:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="nv"&gt;Z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;X&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;
    &lt;span class="nv"&gt;Y&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class="nv"&gt;Z&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;true&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class="nv"&gt;Z&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;Y&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;К слову, функции возвращают результат выполнения последнего выражения, в
данном случае оно представляет собой весь блок &lt;code&gt;if&lt;/code&gt;, а &lt;code&gt;end&lt;/code&gt;
обозначает его окончание (не функции).&lt;/p&gt;
&lt;h2 id="sintaksis"&gt;Синтаксис&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Foo&lt;/code&gt; - все что начинается с английской заглавной буквы -
    переменная, специально объявлять ничего не нужно&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_&lt;/code&gt;&amp;nbsp;- сам знак нижнего подчеркивания и все что с него
    начинается - особый случай переменной, значение которой не значимо
    для программы и при первой возможности "выкидывается"&lt;/li&gt;
&lt;li&gt;Цифры в основном как обычно, есть научная нотация в духе &lt;code&gt;1.23e4&lt;/code&gt;
    (1.23 умножить на 10 в степени 4) и системы исчисления с другим
    основанием, скажем двоичная - &lt;code&gt;2#101010&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;foo&lt;/code&gt; - с строчной буквы начинаются &lt;em&gt;атомы&lt;/em&gt;, по сути константы,
    используются повсеместно:&lt;ul&gt;
&lt;li&gt;названия функций и модулей&lt;/li&gt;
&lt;li&gt;&lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; - булевые значения&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ok&lt;/code&gt; - типичный результат успешный результат выполнения&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?FOO&lt;/code&gt;&amp;nbsp;- хоть официально и называются константами, но по сути -
    макросы, перед компиляцией заменяются на заранее определенный кусок
    кода&lt;strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{foo, bar}&lt;/code&gt; - кортеж, набор данных фиксированной длины&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[foo, bar]&lt;/code&gt; - простой однонаправленный список произвольной длины&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"foo"&lt;/code&gt; - текстовая строка, представленная в виде
    однонаправленного списка (что не эффективно с точки зрения
    потребления памяти, до 4 байт на символ)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;"foo"&amp;gt;&amp;gt;&lt;/code&gt; - бинарная строка, может содержать что угодно,
    в.т.ч. и текст; все что не цифры по возможности лучше хранить в этом
    типе данных.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="sopostavlenie-pattern-matching"&gt;Сопоставление &lt;em&gt;(pattern matching)&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;Очень мощная концепция &lt;em&gt;сопоставления&lt;/em&gt; используется в &lt;strong&gt;Erlang&lt;/strong&gt; на
каждом углу. В базовом варианте работает примерно так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Если в функции foo все прошло нормально, то она возвращает, например
&lt;code&gt;{ok, 123}&lt;/code&gt;, и переменной &lt;code&gt;Result&lt;/code&gt; окажется лишь значение &lt;code&gt;123&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Если же возникла какая-то проблема, то она вернет что-то другое, скажем
&lt;code&gt;{error, timeout}&lt;/code&gt;, приложение столкнется с несоответствием левой и
правой части (атомы &lt;strong&gt;ok&lt;/strong&gt; и &lt;strong&gt;error&lt;/strong&gt; разные) и прекращает свое
выполнение (если бы было чего выполнять).&lt;/p&gt;
&lt;p&gt;Базовый принцип, надеюсь, понятен. Подобным образом выбирается какую из
реализаций функции использовать, в какую ветвь &lt;strong&gt;case&lt;/strong&gt; идти и т.п. В
общем есть много других более сложных применений, но о них в другой раз.&lt;/p&gt;
&lt;h2 id="spiski"&gt;Списки&lt;/h2&gt;
&lt;p&gt;Со списками есть три особые операции:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[Head | Tail ] = [1, 2, 3, 4]&lt;/code&gt; - вытащить элемент с головы
    списка, работает по принципу сопоставления, в &lt;code&gt;Head&lt;/code&gt; окажется
    &lt;code&gt;1&lt;/code&gt;, а в &lt;code&gt;Tail&lt;/code&gt; - &lt;code&gt;[2, 3, 4]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1, 2] ++ [3, 4]&lt;/code&gt; - конкатенация, результатом будет &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[N&amp;nbsp;*&amp;nbsp;N&amp;nbsp;|| N&amp;nbsp;&amp;lt;- [1,&amp;nbsp;2,&amp;nbsp;3], N &amp;gt; 1]&lt;/code&gt; - выглядит замороченно, по
    сути это обычный отображение &lt;em&gt;(map)&lt;/em&gt; с фильтрацией &lt;em&gt;(filter)&lt;/em&gt; - то
    есть выражение перед &lt;code&gt;||&lt;/code&gt; применяется к каждому элементу списка,
    значение которых попадает в переменную &lt;strong&gt;N&lt;/strong&gt;, а после запятой -
    условие, накладываемое на &lt;strong&gt;N&lt;/strong&gt;; таким образом результат будет &lt;strong&gt;[4,
    9]&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="binarnye-stroki"&gt;Бинарные строки&lt;/h2&gt;
&lt;p&gt;C ними намного больше всяких трюков и преобразований, приведу наиболее
значимые:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Binary = &amp;lt;&amp;lt;Integer:64&amp;gt;&amp;gt;&lt;/code&gt; - преобразовать целое число Integer
    в бинарную строку Binary длиной 64 бита (для примера, может быть
    любой&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;Integer1:32, Integer2:32&amp;gt;&amp;gt; =&amp;nbsp;Binary&lt;/code&gt; - распокавать обратно
    бинарную строку в целые числа, но уже два по 32 бита; чем-то похоже
    на операцию &lt;code&gt;[H | T]&lt;/code&gt; у списков, но намного более гибко&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Binary3 = &amp;lt;&amp;lt;Binary1/binary, Binary2/binary&amp;gt;&amp;gt;&lt;/code&gt; - конкатенация
    бинарных строк, результат окажется в &lt;code&gt;Binary3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt; &amp;lt;&amp;lt;(N * N)/integer&amp;gt;&amp;gt; || &amp;lt;&amp;lt;N&amp;gt;&amp;gt; &amp;lt;= &amp;lt;&amp;lt;1, 2, 3&amp;gt;&amp;gt;, N &amp;gt; 1 &amp;gt;&amp;gt;&lt;/code&gt;&amp;nbsp;- аналог последнего примера для списков, только для
    бинарных данных; результат аналогичен - &lt;code&gt;&amp;lt;&amp;lt;4, 9&amp;gt;&amp;gt;&lt;/code&gt;; к слову
    официально это называется &lt;em&gt;binary comprehensions&lt;/em&gt;, а для списков -
    &lt;em&gt;list comprehensions&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="zakliuchenie"&gt;Заключение&lt;/h2&gt;
&lt;p&gt;Очень многое пришлось опустить, иначе самое главное затерялось бы, да и
объем статьи сильно вырос. Подробности всегда можно найти на
&lt;a href="https://www.insight-it.ru/goto/547f742d/" rel="nofollow" target="_blank" title="http://www.erlang.org/"&gt;официальном сайте&lt;/a&gt;, в man'ах, да и просто
погуглив.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Удачного освоения Erlang!&lt;/em&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Fri, 22 Jun 2012 01:27:00 +0400</pubDate><guid>tag:www.insight-it.ru,2012-06-22:erlang/2012/osnovy-erlang-sintaksis-i-punktuaciya/</guid><category>Erlang</category><category>Программирование</category><category>разработка</category></item><item><title>Erlang в интернет-проектах</title><link>https://www.insight-it.ru//erlang/2012/erlang-v-internet-proektakh/</link><description>&lt;p&gt;С моей точки зрения,&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/4b2ebe6b/" rel="nofollow" target="_blank" title="http://www.erlang.org"&gt;&lt;strong&gt;Erlang&lt;/strong&gt;&lt;/a&gt; - один из
наиболее продуманных языков программирования. Его создатели выбирали
каждую деталь и особенность реализации так, чтобы сделать его идеальным
для решения вполне конкретных телекоммуникационных задач, с которыми они
сталкивались в 80-90-х годах. Во многом из-за этого он так и не стал
универсальным языком программирования как &lt;a href="/tag/c/"&gt;C++&lt;/a&gt;,
&lt;a href="/tag/python/"&gt;Python&lt;/a&gt; и другие, а так и остался спустя многие годы
специализированным инструментом. Сегодня спрос и предложение на
специалистов по &lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt; на рынке труда относительно малы,
что для большинства проектов является основным аргументом &lt;em&gt;против
Erlang&lt;/em&gt;, хотя порой они и сталкиваются с задачами, где он запросто бы
стал тем самым &lt;em&gt;"идеальным инструментом"&lt;/em&gt;. В этой статье я хотел бы
обсудить, в каких именно ситуациях применительно к интернет-проектам
использование &lt;strong&gt;Erlang&lt;/strong&gt; оправдано и почему. Но начать придется
издалека - с того, чем же он так &lt;em&gt;уникален&lt;/em&gt;.
&lt;!--more--&gt;&lt;/p&gt;
&lt;h2 id="chto-takoe-erlang"&gt;Что такое Erlang?&lt;/h2&gt;
&lt;p&gt;Под словом Erlang обычно подразумевают совокупность сразу нескольких
компонентов:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Сам одноименный язык программирования - по сути синтаксис и
    идеологию;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ERTS&lt;/strong&gt; &lt;em&gt;(Erlang Run-Time System)&lt;/em&gt; - реализация всех низкоуровневых
    абстракций на &lt;a href="/tag/c/"&gt;C&lt;/a&gt;. Подробнее о них ниже.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BEAM&lt;/strong&gt; &lt;em&gt;(Bogdans' Erlang Abstract Machine)&lt;/em&gt; - стандартная
    реализация виртуальной машины, с помощью которой обычно исполняются
    программы на Erlang после компиляции в байт-код (она очень
    эффективна; хотя компиляция Erlang в нативный код и возможна, оно
    того чаще всего не стоит). BEAM используется по-умолчанию в основных
    дистрибутивах &lt;a href="/tag/linux/"&gt;Linux&lt;/a&gt; и других операционных системах.
    Когда говорят "виртуальная машина Erlang" обычно подразумевается
    совокупность ERTS и BEAM.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OTP&lt;/strong&gt; &lt;em&gt;(Open Telecom Platform)&lt;/em&gt; - набор качественно реализованных
    высокоуровневых абстракций, использование которых стало почти
    стандартом де-факто в мире Erlang, так как оно позволяет не
    изобретать велосипеды и избегать типичных ошибок при реализации
    типичных же паттернов. Немного забегая вперед, приведу несколько
    примеров:&amp;nbsp;&lt;strong&gt;gen_server&lt;/strong&gt; (просто процесс, который принимает
    какие-то запросы и как-то на них реагирует), &lt;strong&gt;gen_fsm&lt;/strong&gt; (конечный
    автомат), &lt;strong&gt;supervisor&lt;/strong&gt; (мониторинг других процессов).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="kliuchevye-osobennosti"&gt;Ключевые особенности&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Параллельное программирование&lt;/strong&gt; &lt;em&gt;(concurrent programming)&lt;/em&gt; - программы
на Erlang состоят из независимых задач, которые &lt;em&gt;могут&lt;/em&gt; выполняться
параллельно, что на практике дает свободу виртуальной машине планировать
их выполнение наиболее эффективным образом с учетом доступных системных
ресурсов.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Процессная модель&lt;/strong&gt; &lt;em&gt;(process model)&lt;/em&gt; - единицей параллельного
выполнения в Erlang является &lt;em&gt;процесс&lt;/em&gt;, который технически представляет
собой лишь часть потока исполнения &lt;em&gt;(thread)&lt;/em&gt; операционной системы и
обладает нижеизложенными свойствами, которые обеспечивает их реализация
в ERTS:&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Параллельность&lt;/strong&gt; &lt;em&gt;(concurrency)&lt;/em&gt; - каждый процесс выполняет свою
часть кода вне зависимости от других процессов, со своим темпом.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Изоляция процессов&lt;/strong&gt; &lt;em&gt;(process isolation)&lt;/em&gt;&amp;nbsp;- в отличии от
потоков исполнения в операционных системах и других языках
программирования, между процессами Erlang'а нет общей памяти. Помимо
этого сбой в одном из процессов напрямую не влияет на другие
процессы в системе. Именно по-этому они называются &lt;em&gt;процессами&lt;/em&gt;, так
как в этом ключе скорее похожи на полноценные процессы операционной
системы.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Низкое потребление ресурсов&lt;/strong&gt;&amp;nbsp;&lt;em&gt;(low resource consumption)&lt;/em&gt; - так
как процессы Erlang являются лишь абстракцией внутри потока
исполнения операционной системы, используют зачастую &lt;em&gt;меньше
килобайта&lt;/em&gt; оперативной памяти и требует минимальных вычислительных
ресурсов, то один сервер может при необходимости иметь сотни тысяч
и даже миллионы&amp;nbsp;запущенных процессов (теоретически возможный
максимум - 268435456, хотя по-умолчанию стоит ограничение в&amp;nbsp;32768
процессов). Для сравнения: суммарное количество потоков выполнения
на сервере обычно измеряется сотнями и редко превышает тысячу.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Слабая связанность&lt;/strong&gt;&amp;nbsp;&lt;em&gt;(loose coupling)&lt;/em&gt; - процессы общаются друг с
другом посредством асинхронного обмена сообщениями &lt;em&gt;(message
passing)&lt;/em&gt;,&amp;nbsp;для чего часть памяти каждого процесса выделяется под
"почтовый ящик". При отправке сообщения в списке входящих сообщений
процесса-получателя создается копия сообщения, составленного в
процессе-отправителе. При этом протокол отправки сообщений между
процессами скрыт от разработчика и не зависит от того, находится ли
получатель в той же виртуальной машине или в удаленной (на другом
сервере), что позволяет легко и практически прозрачно распределять
приложения по многим физическим серверам &lt;em&gt;(горизонтальное
масштабирование, scale out)&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Дерево ответственности&lt;/strong&gt; &lt;em&gt;(responsibility tree)&lt;/em&gt; - создаваемые
внутри системы процессы образуют иерархию, где родители несут
ответственность за потомков.&amp;nbsp;В упомянутом чуть выше примере сбой
одного из процессов вызывает его завершение и рассылку уведомлений
связанным процессам-соседям по иерархии (с информацией о том, где и
почему произошел сбой), на которые они могут как-то реагировать.
Типичных сценария реагирования два: также завершить работу и
разослать аналогичные уведомления, вызывая цепную реакцию (такие
процессы называют исполнителями, &lt;em&gt;worker&lt;/em&gt;), либо на основе
уведомления принять какое-то действие, например попытаться заново
запустить часть дерева процессов, аналогичную остановленной (такие
называют надсмотрщиками, &lt;em&gt;supervisor&lt;/em&gt;). Использование этого
механизма позволяет приложению добиться &lt;em&gt;отказоустойчивости&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ссылочная прозрачность&lt;/strong&gt; &lt;em&gt;(referential transparency)&lt;/em&gt;&amp;nbsp;- как только
переменная получила какое-то значение его уже нельзя изменить &lt;em&gt;(single
assignment)&lt;/em&gt;, для нового значения нужно заводить новую переменную. На
первый взгляд выглядит полным бредом, но именно эту цену нужно заплатить
для гарантии того, что какая-то другая часть кода втихаря не "испортит"
значение. Плюс отсутствие изменений в структурах данных в памяти дает
большую свободу для применения различных оптимизаций компилятору,
сборщику мусора и планировщику процессов.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Планировщик процессов&lt;/strong&gt; &lt;em&gt;(scheduler)&lt;/em&gt; - виртуальная машина Erlang с
точки зрения операционной системы выглядит как один процесс с
несколькими потоками исполнения &lt;em&gt;(threads)&lt;/em&gt;, каждый из которых имеет
собственный планировщик, управляющий группой Erlang-процессов. Процессы
могут прозрачно перемещаться из одного потока в другой для &lt;em&gt;балансировки
нагрузки&lt;/em&gt;. Помимо этого планировщик берет на себя управление
вводом-выводом, которые на низком уровне реализованы в неблокирующей,
основанной на событиях, манере с использованием&amp;nbsp;&lt;a href="/tag/epoll/"&gt;epoll&lt;/a&gt;&amp;nbsp;или
аналогов, но для конечного разработчика представляется в упрощенном
виде.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Сборщик мусора в памяти&lt;/strong&gt; &lt;em&gt;(garbage collector)&lt;/em&gt; - в отличии от других
виртуальных машин (в частности &lt;a href="/tag/jvm/"&gt;JVM&lt;/a&gt;) сборка мусора в Erlang
не влечет за собой значимых задержек в работе приложений, так как
благодаря изоляции процессов для сборки мусора они останавливаются по
очереди, пока все остальные продолжают работать. Обычно область памяти
выделенная под один процесс очень невелика (для сравнения: под новый
процесс в Erlang выделяется около 1 килобайта, под новый поток
исполнения в &lt;a href="/tag/java/"&gt;Java&lt;/a&gt; - более 512 килобайт в зависимости от
реализации), так что сборка мусора для каждого процесса не занимает
много времени. Планировщик может определить какие процессы нужно
пропустить при очередной сборке мусора, если они не исполнялись с
момента предыдущей сборки. Если процесс создается для выполнения
кратковременной задачи, то он может успеть сделать свое дело и
завершиться без единой сборки мусора, полностью освободив свою память по
окончании работы.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Функциональное программирование&lt;/strong&gt;&amp;nbsp;&lt;em&gt;(functional programming)&lt;/em&gt;&amp;nbsp;-
если рассмотреть один Erlang-процесс внутри, отбросив его связь с
внешним миром (обмен сообщениями), то можно увидеть программу, полностью
соответствующую функциональной парадигме: алгоритмы выражаются в виде
вызовов функций, которые, в свою очередь, являются единицами данных
наравне с числами и сложными структурами. На практике же это означает
другой стиль программирования и используемые абстракции (рекурсия вместо
циклов, поведения вместо интерфейсов и т.п.), по сравнению с более
распространенными &lt;a href="/tag/oop/"&gt;объектно-ориентированными&lt;/a&gt; языками;
подробно это будет интересно лишь программистам, так что оставим это для
другой статьи про &lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Доступно три механизма хранения данных вне памяти процессов:&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ETS&lt;/strong&gt; &lt;em&gt;(erlang term storage)&lt;/em&gt; - очень похожий на хранилище пар
ключ-значение механизм, работающий в оперативной памяти самой
виртуальной машины и доступный всем или части её процессов (есть
ограничения доступа). Данные хранятся в пространствах имен (таблицы
без жесткой структуры), а доступ осуществляется по ключу, который
являются частью значения (обычно первым элементом в хранящейся
структуре данных).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DETS&lt;/strong&gt;&amp;nbsp;&lt;em&gt;(disk erlang term storage)&lt;/em&gt;&amp;nbsp;- предоставляется аналогичный
ETS интерфейс и формат хранения данных, с той лишь разницей, что
данные хранятся в файлах на диске, а не в памяти виртуальной машины.
При использовании &lt;strong&gt;не&lt;/strong&gt;твердотельных дисков операции поиска данных
значительно медленнее аналогов из модуля ETS.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mnesia&lt;/strong&gt; - полноценная СУБД на основе ETS/DETS, с поддержкой
атомарных транзакций &lt;em&gt;(atomic transactions)&lt;/em&gt;, репликации
&lt;em&gt;(replication)&lt;/em&gt; и партиционирования &lt;em&gt;(sharding)&lt;/em&gt;. Позволяет
абстрагироваться от физического расположения данных, осуществлять
поиск/выборки данных в реальном времени, а также вносить изменения в
конфигурацию и схему данных без перезапуска.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Горячее обновление кода&lt;/strong&gt; &lt;em&gt;(hot code loading)&lt;/em&gt; - виртуальная машина
может держать в памяти и параллельно выполнять две версии одного и того
же кода (единицей измерения здесь является &lt;em&gt;модуль&lt;/em&gt;, то есть один
скомпилированный файл исходного кода), процесс переключается со старого
кода на новый при выполнении &lt;em&gt;внешнего&lt;/em&gt; вызова к одной из его функций
(что в целом полностью в руках разработчика). Эта возможность позволяет
полностью избежать недоступности приложения при обновлениях, что очень
важно для всех приложений, работающих в реальном времени, к которым
также относятся все сайты и интернет-сервисы.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="primenenie-na-praktike"&gt;Применение на практике&lt;/h2&gt;
&lt;p&gt;Телекоммуникации и Интернет на сегодняшний день хоть и являются
совершенно разными областями &lt;em&gt;информационных технологий&lt;/em&gt;, но все же
глобальная цель у них общая: позволять людям легко общаться удаленно.
Предлагаю вернуться к изначальной теме статьи: в каких конкретно
ситуациях &lt;strong&gt;Erlang&lt;/strong&gt;, вместе со своими изложенными выше особенностями и
ограничениями, может оказаться уместным решением задач интернет-проекта?
Примеры могут показаться субъективными, так что с удовольствием готов
обсудить их и другие ситуации в комментариях.&lt;/p&gt;
&lt;h3 id="vkhodiashchie-polzovatelskie-soedineniia"&gt;Входящие пользовательские соединения&lt;/h3&gt;
&lt;p&gt;Еще в далеком 2002 году в сети часто мелькал
сравнительный&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/669f1a19/" rel="nofollow" target="_blank" title="http://www.sics.se/~joe/apachevsyaws.html"&gt;бенчмарк&lt;/a&gt;&amp;nbsp;&lt;strong&gt;Apache&lt;/strong&gt;
&lt;em&gt;(C)&lt;/em&gt; и &lt;strong&gt;Yaws&lt;/strong&gt; &lt;em&gt;(Erlang)&lt;/em&gt;&amp;nbsp;по обработке HTTP-запросов, где Yaws
представлялся "победителем" с огромным отрывом. С тех пор конечно же
многое поменялось, появился стремительно набирающий обороты
&lt;a href="/tag/nginx/"&gt;nginx&lt;/a&gt; и "популярные в узких кругах" решения вроде
&lt;a href="/tag/node-js/"&gt;node.js&lt;/a&gt; или &lt;a href="/tag/tornado/"&gt;Tornado&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Но &lt;strong&gt;Erlang&lt;/strong&gt; тоже не стоит на месте. Благодаря целенаправленной работе
по оптимизации ERTS в целом и планировщика процессов в частности,
современные реализации HTTP-серверов на Erlang по-прежнему легко &lt;a href="https://www.insight-it.ru/goto/fdb93d75/" rel="nofollow" target="_blank" title="http://www.ostinelli.net/a-comparison-between-misultin-mochiweb-cowboy-nodejs-and-tornadoweb"&gt;дают фору&lt;/a&gt;&amp;nbsp;более распространенным решениям.&lt;/p&gt;
&lt;p&gt;В последние годы появляется все больше интернет-проектов, использующие
постоянные соединения &lt;em&gt;(websocket, long polling, etc.)&lt;/em&gt;&amp;nbsp;между браузером
и HTTP-сервером для обновления страниц сайта в реальном времени. Здесь
также Erlang легко справляется с задачей, так как для поддержания
постоянного соединения обычно используется лишь 1 Erlang-процесс (хотя
иногда 2), которые, как уже упоминалось, потребляют минимум &amp;nbsp;оперативной
памяти и вычислительных ресурсов. Как следствие, HTTP-сервер на Erlang
способен поддерживать очень постоянное соединение с онлайн
пользователями, даже если их количество измеряется десятками тысяч.&lt;/p&gt;
&lt;p&gt;Хочется отметить, что в этом примере речь идет именно об обработке
соединений с пользователями, то есть внутри HTTP-сервера минимум логики,
он просто "разбирает" запрос и, вероятно, передает его дальше внутрь
системы через брокер сообщений или напрямую внутренним сервисам. К
вопросу с сколько-либо сложной бизнес-логикой вернемся чуть позже.&lt;/p&gt;
&lt;h3 id="otdacha-statiki"&gt;Отдача статики&lt;/h3&gt;
&lt;p&gt;Для отдачи статики в Erlang часто используют тот же системный вызов
&lt;strong&gt;sendfile&lt;/strong&gt;, что и в &lt;a href="/tag/nginx/"&gt;nginx&lt;/a&gt;.&amp;nbsp;Но на практике ситуация
здесь неоднозначна:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;прямой доступ к sendfile через встроенные вызовы&amp;nbsp;&lt;em&gt;(BIF, Built-In
    Functions)&lt;/em&gt;&amp;nbsp;появился в Erlang только в самом последнем на
    сегодняшний день релизе - R15B;&lt;/li&gt;
&lt;li&gt;раньше использовалась
    &lt;a href="https://www.insight-it.ru/goto/e9f4e5cf/" rel="nofollow" target="_blank" title="https://github.com/tuncer/sendfile"&gt;обертка&lt;/a&gt;&amp;nbsp;с использованием
    нативных функций &lt;em&gt;(NIF, native implemented functions)&lt;/em&gt;&amp;nbsp;или просто
    чтение файла, что &lt;a href="https://www.insight-it.ru/goto/317549c0/" rel="nofollow" target="_blank" title="http://www.erlang-factory.com/upload/presentations/71/JoeWilliams-Web_Server_Deathmatch.pdf"&gt;работало не очень хорошо&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="card blue lighten-4"&gt;
&lt;p&gt;&lt;div class="card-content"&gt;
На готовые бенчмарки по отдаче статики из последних версий Erlang'а я не
натыкался, так что могу предложить взглянуть на небольшой тест
&lt;strong&gt;cowboy&lt;/strong&gt; vs &lt;strong&gt;nginx&lt;/strong&gt;&amp;nbsp;на обычном домашнем оборудовании: Ubuntu в роли
сервера, iMac в роли клиента (JMeter), 100Мбит между ними. Какого-либо
тюнинга настроек не производилось.
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.1Мб картинка в 10 потоков &lt;em&gt;(нехитрая математика говорит о том, что все
упираются в сеть)&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/images/cowboy-static.jpg"&gt;Cowboy без sendfile&lt;/a&gt;: 853мс. в среднем, 639 запросов в минуту, отклонение 428мс.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/images/cowboyR15B-static.jpg"&gt;Cowboy с sendfile&lt;/a&gt;: 853мс. в среднем, 639 запросов в минуту, отклонение 395мс.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/images/nginx-static.jpg"&gt;Nginx&lt;/a&gt;: 882мс. в среднем, 638 запросов в минуту, отклонение 515мс.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;112б текстовый файл в 1000 потоков:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/images/cowboy-static2.jpg"&gt;Cowboy без sendfile&lt;/a&gt;: 37мс. в среднем (но медиана - 3мс., то есть небольшая часть запросов сильно тормозит, а с остальной все нормально), 259 тыс. запросов в минуту, отклонение 234мс.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/images/cowboyR15B-static.jpg"&gt;Cowboy с sendfile&lt;/a&gt;: 17 мс. в среднем, 267 тыс. запросов в минуту, отклонение 27мс.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/images/nginx-static2.jpg"&gt;Nginx&lt;/a&gt;: 2мс. в среднем, 315 тыс. запросов в минуту, отклонение 3мс.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Не претендуя на хоть на какую-либо точность и применимость в боевых
условиях, эти цифры и графики показывают, что&amp;nbsp;в деле отдачи статики
&lt;strong&gt;nginx&lt;/strong&gt;&amp;nbsp;хоть и по-прежнему лидер, но в не-экстремальных ситуациях
особой разницы можно и не заметить. Хотя при использовании решений на
Erlang определенно можно начать "скучать" по нестандартным конфигурациям nginx с какой-нибудь компрессией на лету, rewrite'ами и пр.
В любом случае, для отдачи статики в сколько-либо серьезных
интернет-проектов рекомендую пользоваться услугами&amp;nbsp;&lt;a href="/tag/cdn/"&gt;CDN&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="balansirovka-nagruzki"&gt;Балансировка нагрузки&lt;/h3&gt;
&lt;p&gt;Откровенно говоря, я не слышал о каком-либо проекте на Erlang для
балансировки HTTP и/или TCP запросов, хотя бы отдаленно сравнимом по
возможностям, надежности и производительности с &lt;a href="/tag/haproxy/"&gt;HAProxy&lt;/a&gt;
и "железными" решениями.&lt;/p&gt;
&lt;p&gt;Хотя по мне так сами свойства Erlang прекрасно подходят для решения этой
задачи, но те проекты, на которые я натыкался (&lt;a href="https://www.insight-it.ru/goto/53f5a8f4/" rel="nofollow" target="_blank" title="https://github.com/mdaguete/tcpbalance"&gt;пример&lt;/a&gt;), выглядят просто как "поделки" по сравнению с проверенными временем решениями.&lt;/p&gt;
&lt;p&gt;В любом случае HTTP/TCP балансировщик нагрузки на Erlang - отличная
тема для нового opensource проекта, если вдруг кому-то нечем заняться в
свободное время :)&lt;/p&gt;
&lt;h3 id="broker-soobshchenii"&gt;Брокер сообщений&lt;/h3&gt;
&lt;p&gt;В статье про &lt;strong&gt;&lt;a href="https://www.insight-it.ru/erlang/2012/rabbitmq/"&gt;RabbitMQ&lt;/a&gt;&lt;/strong&gt;&amp;nbsp;я
уже подробно рассказывал о том, как Erlang вписывается в роль &lt;em&gt;брокера
сообщений&lt;/em&gt;, то есть посредника между различными компонентами системы,
обеспечивающего их слабую связанность путем обмена сообщениями.&lt;/p&gt;
&lt;p&gt;В дополнение хочется сказать, что хоть изобретать велосипед и редко
когда оказывается хорошей затеей, Erlang отлично подошел бы и для
реализации собственной схемы обмена сообщениями внутри системы, например
без использования централизованного брокера, как это в итоге получается
с использованием RabbitMQ или аналогов.&lt;/p&gt;
&lt;h3 id="biznes-logika"&gt;Бизнес-логика&lt;/h3&gt;
&lt;p&gt;Этот аспект является практически уникальным от проекта к проекту, так
что здесь придется ограничиться лишь какими-то общими рекомендациями.&lt;/p&gt;
&lt;p&gt;Основной слабой стороной Erlang является &lt;strong&gt;обработка данных&lt;/strong&gt;, в
частности:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Текстовые строки в Erlang реализованы как
    &lt;em&gt;однонаправленный&lt;/em&gt;&amp;nbsp;&lt;em&gt;связанный список целых чисел&lt;/em&gt;, то есть на каждый
    символ выделяется &lt;strong&gt;восемь байт&lt;/strong&gt; памяти: четыре на код символа,
    четыре - на указатель на следующий символ; плюс еще четыре байта для
    указателя на начало списка. Для 64-битных систем эти цифры нужно
    удвоить, так как машинное слово вдвое длиннее. Помимо неоправданных
    расходов памяти, эта схема усложняет различные операции со строками,
    например чтобы посчитать длину строки нужно "пройтись" по ней
    целиком. А чтобы приписать один символ в конец строки, нужно сделать
    её полную копию (для записи в начало это не так, как не трудно
    догадаться).&lt;/li&gt;
&lt;li&gt;Бинарные строки хранятся в памяти последовательно, так что объем не
    удваивается из-за указателей. Изменения в итоге также создают копии
    данных, что для больших строк накладно. В любом случае там где это
    возможно я бы рекомендовал использовать бинарные строки вместо
    текстовых.&lt;/li&gt;
&lt;li&gt;С математическими задачами все не так плачевно: хоть и реализация
    базовых операций в виртуальной машине несколько отстает по
    производительности от чистого &lt;a href="/tag/c/"&gt;С&lt;/a&gt;, при желании его можно
    практически догнать средствами нативной компиляции, грамотной
    реализации алгоритма и отсутствия "палок в колесах" у компилятора.
    Альтернативный сценарий: использование NIF.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для не-англоязычных проектов трудностью может оказаться довольно
сомнительная &lt;a href="https://www.insight-it.ru/goto/2568aa73/" rel="nofollow" target="_blank" title="http://www.erlang.org/doc/apps/stdlib/unicode_usage.html"&gt;поддержка Unicode&lt;/a&gt;:
особого типа данных нет, в тех же текстовых строках код символа может
выходить за пределы таблицы ASCII (не зря же на него 32 или 64 бита
выделили), а в бинарных строках можно хранить что угодно, в т.ч. и
Unicode-текст. Как прореагирует на Unicode тот или иной встроенный
модуль или используемая библиотека никто не гарантирует, но обычно все
более-менее нормально.&lt;/p&gt;
&lt;p&gt;Хоть на самом деле это и является роскошью, но при реализации
бизнес-логики на Erlang порой недостает ORM-подобных механизмов в духе
"вытащил объект из базы, поменял в нем что-нибудь, положил обратно". Не
то чтобы таких библиотек нет, просто эта схема не очень хорошо "ложится"
на функциональную парадигму и реализуется обычно через не особо
предназначенные для этого механизмы словарей &lt;em&gt;(dict)&lt;/em&gt; или именованных
кортежей &lt;em&gt;(record)&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;В качестве резюме хочется сказать, что на &lt;strong&gt;Erlang&lt;/strong&gt; можно реализовать
бизнес-логику практически любого интернет-проекта. Просто если она
сложнее, чем просто передать какие-то данные от одного пользователя
другому, то вероятно из-за&amp;nbsp;искусственных&amp;nbsp;ограничений и недостаточной
выразительности языка для эффективной её разработки на Erlang может
потребоваться существенно больше времени и усилий, чем на более
приспособленных для этого языках вроде &lt;a href="/tag/ruby/"&gt;Ruby&lt;/a&gt;,
&lt;a href="/tag/php/"&gt;PHP&lt;/a&gt; и &lt;a href="/tag/python/"&gt;Python&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="bazy-dannykh"&gt;Базы данных&lt;/h3&gt;
&lt;p&gt;Здесь все довольно просто: обычно &lt;strong&gt;Erlang&lt;/strong&gt; используется как
распределенная надстройка над встраиваемыми &lt;a href="/tag/subd/"&gt;СУБД&lt;/a&gt;&amp;nbsp;или
особыми форматами файлов. Основные
представители:&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/2a0c794c/" rel="nofollow" target="_blank" title="http://basho.com/products/riak-overview"&gt;Riak&lt;/a&gt;&amp;nbsp;&lt;em&gt;(Google LevelDB)&lt;/em&gt;,&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/4cab48f4/" rel="nofollow" target="_blank" title="http://couchdb.apache.org"&gt;CouchDB&lt;/a&gt;&amp;nbsp;&lt;em&gt;(свой
формат)&lt;/em&gt;,&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/5d81862f/" rel="nofollow" target="_blank" title="http://www.erlang.org/doc/man/mnesia.html"&gt;Mnesia&lt;/a&gt;&amp;nbsp;&lt;em&gt;(DETS)&lt;/em&gt;,&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/2d0bf326/" rel="nofollow" target="_blank" title="http://www.couchbase.com"&gt;Couchbase&lt;/a&gt;&amp;nbsp;&lt;em&gt;(memcached
и SQLite)&lt;/em&gt; - все совершенно разные, обсуждать и сравнивать можно до
бесконечности, так что оставим это на другой раз.&lt;/p&gt;
&lt;p&gt;Из общих особенностей вышеперечисленных решений можно выделить:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Прозрачная &lt;em&gt;горизонтальная масштабируемость&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;Настраиваемый уровень &lt;em&gt;репликации&lt;/em&gt; данных;&lt;/li&gt;
&lt;li&gt;Обычно &lt;em&gt;доступность&lt;/em&gt; и &lt;em&gt;персистентность&lt;/em&gt; в ущерб строгой целостности
    (AP из CAP-теоремы);&lt;/li&gt;
&lt;li&gt;Поддержка &lt;em&gt;сложных распределенных выборок&lt;/em&gt;
    (&lt;a href="/tag/mapreduce/"&gt;MapReduce&lt;/a&gt;, многокритериальная
    фильтрация,&amp;nbsp;полнотекстный&amp;nbsp;поиск и т.п., за исключением Couchbase)&lt;/li&gt;
&lt;li&gt;Способность легко справляться с большим &lt;em&gt;потоком изменений данных&lt;/em&gt;
    (за исключением, пожалуй, CouchDB);&lt;/li&gt;
&lt;li&gt;Отсутствие строгой схемы данных и SQL-подобного интерфейса.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="podvodim-itogi_1"&gt;Подводим итоги&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Erlang&lt;/strong&gt; в умелых руках может послужить и правда удачным решением для
реализации многих аспектов интернет-проектов, благодаря качественной,
проверенной временем, основе в виде виртуальной машины и OTP, а также
продуманной модели легковесных процессов. &lt;em&gt;В результате получаются
высокопроизводительные, горизонтально масштабируемые приложения,
полностью приспособленные для стабильной бесперебойной работы в боевых
условиях.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Высокий барьер обучения специалистов по-прежнему остается весомым
аргументом "против", но если в проекте команда разработчиков уровня выше
среднего -&amp;nbsp;вряд ли&amp;nbsp;это станет серьезным препятствием. Недостаток
"готовых" квалифицированных специалистов по Erlang на трудовом рынке
также не особо радует, но ситуация определенно постепенно улучшается.&lt;/p&gt;
&lt;p&gt;В комментариях предлагаю обсудить по каким еще причинам на сегодняшний
день Erlang столь редко можно увидеть в технологическом стеке
интернет-проектов? Какие еще вопросы смущают руководство и
разработчиков? В каких ситуациях преодоление сложностей и ограничений,
связанных с Erlang, того стоит?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Эта статья определенно будет далеко не последней про Erlang, так что
если эта тема Вам близка - рекомендую &lt;a href="/feed/"&gt;подписаться на RSS&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sat, 17 Mar 2012 19:43:00 +0400</pubDate><guid>tag:www.insight-it.ru,2012-03-17:erlang/2012/erlang-v-internet-proektakh/</guid><category>Beam</category><category>DETS</category><category>Erlang</category><category>ERTS</category><category>ETS</category><category>EVM</category><category>Mnesia</category><category>OTP</category><category>VM</category></item><item><title>RabbitMQ</title><link>https://www.insight-it.ru//erlang/2012/rabbitmq/</link><description>&lt;p&gt;Когда веб-приложение перестает быть просто коллекцией скриптов,
генерирующих HTML, встает вопрос о взаимодействии различных компонентов
системы. Есть два основных подхода:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;обращение &lt;strong&gt;напрямую&lt;/strong&gt; посредством протоколов вроде
    &lt;a href="/tag/thrift/"&gt;Thrift&lt;/a&gt; или &lt;a href="/tag/protocol-buffers/"&gt;Protocol Buffers&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;либо посредством &lt;strong&gt;брокера сообщений&lt;/strong&gt;, посредника, берущего на себя
    вопросы их маршрутизации и доставки одному или нескольким
    получателям, даже в случае сбоев оборудования и недоступности
    сетевого соединения.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Сегодня я хотел бы рассказать об одной из лучших, на мой взгляд,
реализаций брокера сообщений, &lt;strong&gt;RabbitMQ&lt;/strong&gt;. Хотите узнать почему я так
считаю? - Дочитайте до конца :)&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="osnovnye-poniatiia"&gt;Основные понятия&lt;/h2&gt;
&lt;p&gt;Слоганом &lt;a href="https://www.insight-it.ru/goto/4799c299/" rel="nofollow" target="_blank" title="http://www.rabbitmq.com"&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;&lt;/a&gt; является &lt;em&gt;"обмен
сообщениями, который просто работает"&lt;/em&gt;. Отчасти с этим утверждением
можно согласиться, для того чтобы сервис обмена сообщениями "просто
заработал" достаточно простой команды &lt;code&gt;aptitude install rabbitmq-server&lt;/code&gt; или аналога для операционных систем, не основанных на
&lt;a href="/tag/debian/"&gt;Debian&lt;/a&gt;. Но кому этого будет достаточно? Как минимум
нужно научить свой проект эти сообщения отправлять и принимать, а как
максимум - обрабатывать десятки и сотни тысяч сообщений в секунду, но
обо всем по порядку.&lt;/p&gt;
&lt;p&gt;В основе RabbitMQ лежит протокол &lt;a href="https://www.insight-it.ru/goto/4d3139fc/" rel="nofollow" target="_blank" title="http://www.amqp.org"&gt;AMQP&lt;/a&gt;, который
вводит&amp;nbsp;три основных понятия:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Сообщение&lt;/strong&gt; &lt;em&gt;(message)&lt;/em&gt;&amp;nbsp;- единица информации, которая передается
    от отправителя к получателю(ям); состоит из набора заголовков и
    содержания, которое брокером никак не интерпретируются.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Точка обмена&lt;/strong&gt; &lt;em&gt;(exchange)&lt;/em&gt;&amp;nbsp;- распределяет отправленные сообщения
    между одной или несколькими очередями в соответствии с их
    заголовками.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Очередь&lt;/strong&gt; &lt;em&gt;(queue)&lt;/em&gt;&amp;nbsp;- место, где хранятся сообщения до тех пор,
    пока их не заберет получатель.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Базовые механизмы взаимодействия с брокером очень просты:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Отправить сообщение&lt;/strong&gt; &lt;em&gt;(publish)&lt;/em&gt; - сообщение сериализуется в
    определенный формат, при необходимости снабжается маршрутной меткой
    &lt;em&gt;(routing key)&lt;/em&gt;&amp;nbsp;и передается в RabbitMQ;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Получать сообщение&lt;/strong&gt; &lt;em&gt;(consume или subscribe)&lt;/em&gt; - приложение
    регистрируется в RabbitMQ с указанием какие именно сообщения оно
    готово получать и обрабатывать, после чего ожидает их доставки.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Перед началом любого взаимодействия с брокером клиент должен указать
какая точка обмена должна заниматься обработкой его сообщений, что при
необходимости её и зарегистрирует. При этом он указывает её название и
тип, которых доступно три:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Отправка всем&lt;/strong&gt; &lt;em&gt;(fanout)&lt;/em&gt; - как следует из названия, каждое
    сообщение получат все очереди, связанные с данной точкой обмена,
    типичная публикация-подписка &lt;em&gt;(publish-subscribe)&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Прямая&lt;/strong&gt; &lt;em&gt;(direct)&lt;/em&gt;&amp;nbsp;- сообщение получит только та очередь, которая
    имеет название, соответствующее маршрутной метке сообщения, типичная
    очередь сообщений &lt;em&gt;(message queue).&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Тематическая&lt;/strong&gt; &lt;em&gt;(topic)&lt;/em&gt; - очереди при регистрации указывают
    паттерн маршрутных меток сообщений, которые они хотели бы получать.
    Этот механизм позволяет наиболее гибко управлять маршрутизацией
    сообщений и строить нетривиальные схемы доставки. Вместо регулярных
    выражений используется очень простая схема: метки в виде слов,
    разделенных точками; в паттерне &lt;code&gt;*&lt;/code&gt; заменяет ровно одно слово, &lt;code&gt;#&lt;/code&gt; -
    ноль или больше; при отсутствии этих символов работает как прямая
    точка обмена.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="card blue lighten-4"&gt;
&lt;p&gt;&lt;div class="card-content"&gt;
Если Вашему приложению достаточно простых подписки-публикации или
очереди сообщений, а также нет необходимости гарантировать доставку
сообщений или обрабатывать потоки сообщений, превышающие возможности
одного сервера, то можно рассмотреть более простые в эксплуатации
решения, не основанные на AMQP. В такой ситуации я рекомендовал бы
первым делом взглянуть на &lt;a href="/tag/redis/"&gt;Redis&lt;/a&gt;. Если это не про Вас, то
продолжаем разбираться с RabbitMQ.
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="tipichnye-stsenarii"&gt;Типичные сценарии&lt;/h2&gt;
&lt;h3 id="vypolnenie-dlitelnykh-operatsii"&gt;Выполнение длительных операций&lt;/h3&gt;
&lt;p&gt;Представим себя интернет-проектом, который размещает у себя
пользовательские видео или фото. Когда он получает по HTTP очередной
файл, ему требуется сконвертировать его в стандартный формат для
просмотра другими пользователями, а также, например, сделать несколько
превью разного размера.&lt;/p&gt;
&lt;p&gt;По-старинке эти операции делают последовательно в том же обработчике
запроса, который и принял от пользователя файл. В схеме с брокером же
после принятия файла он отправляет сообщение, в содержании которого
будет, вероятно, ссылка на файла-оригинал, после чего он возвращает
браузеру сообщение об успешной загрузке файла. Для отправки таких
сообщений используют &lt;strong&gt;прямую точку обмена&lt;/strong&gt;, с какой-то стандартной
маршрутной меткой и соответствующим именем очереди, например
&lt;code&gt;process_video&lt;/code&gt; или &lt;code&gt;create_thumbnails&lt;/code&gt;. Процессы, реализующие совершенно
независимый сервис по выполнению этих длительных операций, будут по
очереди забирать сообщения с "заданиями" из брокера, позволяя легко
создавать любое количество исполнителей c &lt;strong&gt;балансировкой нагрузки&lt;/strong&gt;,
что обеспечит горизонтальное масштабирование этой подсистемы.&lt;/p&gt;
&lt;p&gt;Еще один доступный механизм, который вписывается в эту задачу -
&lt;strong&gt;подтверждение о получении сообщения&lt;/strong&gt; &lt;em&gt;(acknowledgement)&lt;/em&gt;. Получатель
должен отправить брокеру&amp;nbsp;дополнительное сообщение о том, что такое-то
сообщение было успешно получено, в противном случае оно останется в
очереди ожидать следующего получателя. Если процессы-исполнители будут
подтверждать получение только после успешного выполнения длительной
операции, это будет гарантировать, что все задания будут успешно
выполнены вне зависимости от сбоев на каждом конкретном исполнителе, что
обеспечивает &lt;strong&gt;отказоустойчивость&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id="udalennyi-vyzov-rpc"&gt;Удаленный вызов (RPC)&lt;/h3&gt;
&lt;p&gt;Для некоторых приложений важно не только отправить запрос на выполнение
какой-то операции, но и получить в ответ какой-то результат. На самом
деле использование брокера сообщений в этой ситуации не всегда является
удачным решением, проще делать это напрямую посредством других
технологий. Но если в системе итак присутствует брокер, а для удаленного
вызова нет строгих требований по времени выполнения, плюс хочется
подобно предыдущему примеру легко получить отказоустойчивость и
балансировку нагрузки, то можно реализовать удаленный вызов и через
брокер сообщений.&lt;/p&gt;
&lt;p&gt;Для этого предусмотрено два заголовка сообщений:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Обратный адрес&lt;/strong&gt; &lt;em&gt;(reply to)&lt;/em&gt; - исполнитель должен отправить
    результат в очередь с указанным именем; отравитель сразу же после
    передачи сообщения-запроса брокеру начинает получать сообщения из
    указанной в этом заголовке очереди.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Идентификатор запроса&lt;/strong&gt; &lt;em&gt;(correlation id)&lt;/em&gt; - должен быть
    уникальным среди запросов, чтобы отправитель мог сопоставить
    результаты с запросами.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="soobshcheniia-polzovateliam"&gt;Сообщения пользователям&lt;/h3&gt;
&lt;p&gt;Очереди можно использовать как входящие почтовые ящики для пользователей
веб-приложений. Какие-то компоненты системы или другие пользователи с
использованием &lt;em&gt;прямой точки обмена&lt;/em&gt; отправляют сообщения в очереди,
содержащие в названии уникальный идентификатор пользователя-получателя.
Там они ожидают пока он их не прочитает, например, зайдя на определенную
страницу сайта.&lt;/p&gt;
&lt;p&gt;В этом примере очень важно использовать режим постоянных сообщений
&lt;em&gt;(persistant, путем установки заголовка &lt;code&gt;delivery_mode=2&lt;/code&gt;)&lt;/em&gt;, так как
получатель сообщения может появиться очень не скоро и важно чтобы
сообщения "переживали" даже полный перезапуск брокера сообщений. Для
более короткоживущих сообщений это менее критично, но тоже порой
актуально, особенно как еще одна мера для обеспечения
&lt;strong&gt;отказоустойчивости&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Пример хоть и немного оторванный от реальности из-за очистки почтового
ящика после каждого прочтения, но в каких-то ситуациях все же может
иметь право на существование.&lt;/p&gt;
&lt;h3 id="dvustoronnee-soedinenie-s-brauzerom"&gt;Двустороннее соединение с браузером&lt;/h3&gt;
&lt;p&gt;Пожалуй, самый "вкусный" пример, хоть и лежащий на поверхности. На
многих крупных &lt;a href="https://www.insight-it.ru/highload/"&gt;интернет-проектах&lt;/a&gt;, особенно социальной направленности можно увидеть уведомления &lt;em&gt;в реальном времени&lt;/em&gt; о событиях на сайте - кто-то что-то написал, поставил +1, проголосовал и т.п.&lt;/p&gt;
&lt;p&gt;Реализация этого функционала требует довольно серьезной работы как на
стороне браузера, так и на серверной стороне. Браузерный вопрос выходит
за рамки этой статьи (хотя тут у меня тоже есть что рассказать,
отдельным постом когда-нибудь обязательно напишу), а вот на серверной
стороне брокер сообщений окажется очень даже кстати, особенно в
реализации RabbitMQ.&lt;/p&gt;
&lt;p&gt;На серверной части эта задача делится на две части:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Поддерживать &lt;strong&gt;постоянное соединение&lt;/strong&gt; со всеми пользователями, кто
    находится онлайн - здесь на помощь обычно приходит либо
    &lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt;, либо неблокирующий сервер на
    &lt;a href="/tag/epoll/"&gt;epoll&lt;/a&gt;. Оба варианта очень неплохие, выбирайте сами.&lt;/li&gt;
&lt;li&gt;Дальше нужно как-то организовать &lt;strong&gt;доставку сообщений&lt;/strong&gt; (информацию
    о событиях в системе) между пользователями, где и вступает в игру
    брокер. Обработчик соединения подписывается на сообщения о публичных
    событиях (точка обмена "отправить всем"), и туда же отправляет
    информацию о действиях пользователя-владельца.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Чем больше пользователей онлайн, тем больше сообщений в единицу времени
будет проходить через брокер. Один сервер перестанет справляться
довольно быстро, так что следующий раздел статьи окажется очень кстати.&lt;/p&gt;
&lt;h2 id="klasterizatsiia_1"&gt;Кластеризация&lt;/h2&gt;
&lt;p&gt;Многое из вышеизложенного справедливо и для других реализаций
&lt;a href="/tag/amqp/"&gt;AMQP&lt;/a&gt;, но в вопросе кластеризации &lt;strong&gt;RabbitMQ&lt;/strong&gt; предстает во
всей красе. Залогом этого в первую очередь является использование
&lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt;, не знаю почему я до сих пор не написал статью
про этот язык программирования, здесь достаточно было бы на нее
сослаться и все стало бы ясно.&lt;/p&gt;
&lt;p&gt;Если вкратце, то в Erlang реализована внутренняя система легковесных
процессов, не имеющая общего состояния и взаимодействующая друг с другом
&lt;em&gt;исключительно&lt;/em&gt; посредством обменом сообщений. При этом с точки
разработчика отправка сообщений другому процессу на том же физическом
сервером и на удаленном выглядит одинаково, и даже является одним из
операторов языка - "!", наравне с "=", "+" и.т.п. Этот факт позволяет
приложениям или их частям взаимодействовать по сети так же легко, как и
в рамках одного сервера.&lt;/p&gt;
&lt;p&gt;Чтобы определить разрешено ли разным Erlang-сервера взаимодействовать
друг с другом, они обмениваются хэшем пароля (который правда называют
&lt;strong&gt;cookie&lt;/strong&gt;, хотя с одноименным механизмом браузеров он ничего общего не
имеет)&amp;nbsp;и продолжают работу только если он совпал. Он должен быть
одинаковым на всех узлах и хранится в файле &lt;code&gt;~/.erlang.cookie&lt;/code&gt;, для
RabbitMQ это обычно &lt;code&gt;/var/lib/rabbitmq/.erlang.cookie&lt;/code&gt; - первым делом
нужно решить этот вопрос, а также убедиться, что используется
нестандартное значение.&lt;/p&gt;
&lt;p&gt;Узлы в RabbitMQ кластере могут быть двух типов: работающие только &lt;strong&gt;в
памяти&lt;/strong&gt; и сохраняющие данные &lt;strong&gt;на диск&lt;/strong&gt;. Так как состояние системы
реплицируется между узлами кластера, в большинстве случаев достаточно
иметь лишь 2-3 дисковых узла, а остальные избавить от необходимости
работать с дисковой подсистемой для увеличения производительности.&lt;/p&gt;
&lt;p&gt;Важно понимать, что под состоянием системы здесь имеются ввиду лишь
привязки и настройки брокеров, каждая же очередь и хранящиеся в ней
сообщения располагаются на одном конкретном узле, что приведет к потери
части сообщений при сбое одного из серверов. Этот вопрос можно решить и
средствами операционной системы, но чаще всего правильнее выделить
критически-важные для системы очереди сообщений и включить их репликацию
средствами RabbitMQ, этот механизм называется &lt;a href="https://www.insight-it.ru/goto/3ff295d5/" rel="nofollow" target="_blank" title="http://www.rabbitmq.com/ha.html"&gt;&lt;strong&gt;зеркальные очереди&lt;/strong&gt;&lt;/a&gt; &lt;em&gt;(mirrored queues)&lt;/em&gt;. &amp;nbsp;Репликация происходит по принципу &lt;strong&gt;мастер-слуга&lt;/strong&gt; &lt;em&gt;(master-slave)&lt;/em&gt;,
как и в реляционных СУБД: все операции осуществляются на основном
сервере (мастере), он транслирует их на один или несколько вторичных
серверов (слуги), при каком-либо сбое на основном один из слуг
"повышается" до статуса мастера и берет на себя его функции. Очереди
могут быть объявлены зеркальными только при создании, но новые узлы в
роли слуг могут добавляться и позже, в таком случае новый слуга начнет
получать входящие сообщения и рано или поздно начнет полностью отражать
его состояние, механизма синхронизации при подключении дополнительного
слуги не предусмотрено. Последним шагом для гарантированной доставки
сообщений, не упоминавшимся ранее, является механизм&amp;nbsp;&lt;strong&gt;уведомления
отправителя об успешной записи сообщения&lt;/strong&gt; в очередь (на все сервера для
зеркальных).&lt;/p&gt;
&lt;p&gt;В кластерном окружении может понадобиться &lt;strong&gt;объединение точек обмена&lt;/strong&gt;
&lt;em&gt;(exchange federation)&lt;/em&gt;, что реализуется посредством пересылки сообщений
по однонаправленным связям. При этом учитывается наличие на принимающей
стороне очередей, готовых принять каждое конкретное сообщение.
Практического применения в веб-проектах этому пока особо не вижу, разве
что при кросс-датацентровой работе. Кстати, для этого поддерживается
работа поверх &lt;a href="https://www.insight-it.ru/goto/c397c12c/" rel="nofollow" target="_blank" title="http://www.rabbitmq.com/ssl.html"&gt;SSL&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Для подключения узлов к кластеру можно использовать консольную утилиту
(для временных изменений) или конфигурационные файлы (для постоянных
настроек), подробно &lt;a href="https://www.insight-it.ru/goto/db4a1208/" rel="nofollow" target="_blank" title="http://www.rabbitmq.com/clustering.html"&gt;останавливаться не буду&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="podvodim-itogi"&gt;Подводим итоги&lt;/h2&gt;
&lt;p&gt;Используя брокер сообщений при технической реализации интернет-проекта,
можно перевести его на совершенно новый уровень с точек зрения
&lt;em&gt;отказоустойчивости&lt;/em&gt; и &lt;em&gt;горизонтальной масштабируемости&lt;/em&gt;. Во многих
случаях он становится "сердцем" приложения, без которого его
существование было бы немыслимо, но в то же время благодаря
кластеризации не становится &lt;strong&gt;единственной точкой отказа&lt;/strong&gt; &lt;em&gt;(single
point of failure)&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Хоть многое из упомянутого в статье можно реализовать и с помощью других
технологий, &lt;strong&gt;RabbitMQ&lt;/strong&gt; является наиболее приспособленной к реалиям
современного Интернета реализацией брокера сообщений и AMQP в частности,
в первую очередь благодаря распределенной природе Erlang и качественно
спроектированной архитектуре этого продукта.&lt;/p&gt;
&lt;p&gt;В комментариях с удовольствием обсудил бы применение RabbitMQ и других
брокеров сообщения в различных практических ситуациях; еще можно
подискутировать по поводу его преимуществ и недостатков по сравнению с
альтернативами, в каких ситуациях это проявляется.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Жду Вас среди &lt;a href="/feed/"&gt;постоянных читателей Insight IT&lt;/a&gt;, число
которых недавно перевалило за 14 тысяч :)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sat, 10 Mar 2012 01:19:00 +0400</pubDate><guid>tag:www.insight-it.ru,2012-03-10:erlang/2012/rabbitmq/</guid><category>AMQP</category><category>Erlang</category><category>RabbitMQ</category><category>брокер</category><category>брокер сообщений</category><category>обмен сообщениями</category><category>сообщения</category></item></channel></rss>
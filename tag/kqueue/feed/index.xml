<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Insight IT</title><link>https://www.insight-it.ru/</link><description></description><atom:link href="https://www.insight-it.ru/tag/kqueue/feed/index.xml" rel="self"></atom:link><lastBuildDate>Fri, 17 Feb 2012 16:27:00 +0400</lastBuildDate><item><title>Как работает epoll?</title><link>https://www.insight-it.ru//linux/2012/kak-rabotaet-epoll/</link><description>&lt;p&gt;Слово epoll сейчас определенно на слуху, в первую очередь благодаря
росту популярности неблокирующих HTTP-серверов. При этом мало кто
пытается разобраться в том, что, собственно, за ним стоит и почему
использующие этот механизм продукты, среди которых достойное место
занимают, например, &lt;a href="/tag/nginx/"&gt;nginx&lt;/a&gt;, &lt;a href="/tag/node-js/"&gt;node.js&lt;/a&gt; и
&lt;a href="/tag/tornado/"&gt;Tornado&lt;/a&gt;, так значительно выигрывают в
производительности у ближайших альтернатив. Хотите копнуть глубже?
&lt;!--more--&gt;&lt;/p&gt;
&lt;h2 id="o-chem-poidet-rech"&gt;О чем пойдет речь?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;epoll&lt;/strong&gt; является масштабируемой &lt;em&gt;неблокирующей&lt;/em&gt; системой
    уведомления о собятиях ввода-вывода в &lt;a href="/tag/linux/"&gt;Linux&lt;/a&gt;. В
    отличии от более старых механизмов, у epoll время срабатывания не
    зависит от количества открытых файловых дескрипторов.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;epoll&lt;/strong&gt; используется для обработки событий &lt;em&gt;неблокирующих&lt;/em&gt;
    TCP-сокетов, операционная система оповещает приложение когда один из
    сокетов "под наблюдением" готов получить или отправить сообщение. В
    традиционном же подходе на каждый сокет выделяется поток выполнения
    (thread), который блокируется до возвращения обращения к
    соответствующему сокету.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="card blue lighten-4"&gt;
&lt;p&gt;&lt;div class="card-content"&gt;
Сразу хочу предупредить, хоть на практике
&lt;a href="/tag/epoll/"&gt;epoll&lt;/a&gt;&amp;nbsp;и&amp;nbsp;используется чаще, существуют и альтернативные
реализации схожего подхода, например &lt;a href="/tag/kqueue/"&gt;kqueue&lt;/a&gt; в BSD
системах. Конечные продукты обычно используют библиотеку, абстрагирующуе
низкоуровневые вызовы, наиболее
распросраненные -&amp;nbsp;&lt;a href="/goto/http://software.schmorp.de/pkg/libev.html"&gt;libev&lt;/a&gt;
и &lt;a href="https://www.insight-it.ru/goto/cd2ee101/" rel="nofollow" target="_blank" title="http://libevent.org/"&gt;libevent&lt;/a&gt;.
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="chto-eto-daet"&gt;Что это дает?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Не нужно впустую тратить &lt;em&gt;системные ресурсы&lt;/em&gt; на создание,
    уничтожение и поддержания пула потоков выполнения.&lt;/li&gt;
&lt;li&gt;Один системный процесс может поддерживать существенно большее
    &lt;em&gt;количество TCP-соединений.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Длительные соединения&lt;/em&gt;, по которым редко поступают сообщения, не
    держат заблокированный поток и потребляют минимум системных
    ресурсов.&lt;/li&gt;
&lt;li&gt;Отсутствие проблем с &lt;em&gt;синхронизацией&lt;/em&gt; пула потоков и доступом к
    общей памяти.&lt;/li&gt;
&lt;li&gt;Возможность (но не необходимость) без дополнительных сложностей
    держать в памяти процесса какое-то общее состояние, если приложение
    того требует.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="obratnaia-storona-medali"&gt;Обратная сторона медали&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Потоки выполнения в блокирующей модели имеют относительно короткий
    жизненный цикл и рано или поздно освобождают выделенную им память,
    процесс обработки неблокирующих соединений живет существенно дольше
    и намного более уязвим для &lt;em&gt;утечек памяти&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Использование одного системного процесса без пула потоков выполнения
    ограничивает приложение &lt;em&gt;использованием лишь одного процессорного
    ядра&lt;/em&gt;, что делает такой подход менее пригодным для приложений, в
    значительной мере использующих вычислительные ресурсы. В большинстве
    же случаев приемлемым решением является запуск нескольких одинаковых
    копий приложения на одном сервере по количеству процессорных ядер.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Ошибки в коде&lt;/em&gt; могут негативно повлиять на работу всего процесса
    приложения, в то время как в блокирующей модели потоки выполнения
    обычно достаточно изолированы друг от друга.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="na-paltsakh"&gt;На пальцах&lt;/h2&gt;
&lt;p&gt;Вернемся к изначальному вопросу статьи: &lt;em&gt;Как работает epoll?&lt;/em&gt; Давайте
попробуем разобрать на простом примере.&lt;/p&gt;
&lt;p&gt;Представьте себе &lt;strong&gt;пиццерию&lt;/strong&gt; &lt;em&gt;(физический сервер)&lt;/em&gt;. &lt;strong&gt;Вы&lt;/strong&gt; &lt;em&gt;(приложение
или HTTP-сервер)&lt;/em&gt; получаете &lt;strong&gt;заказы&lt;/strong&gt; &lt;em&gt;(обращения на сокет, например
HTTP-запрос)&lt;/em&gt; на выпечку &lt;strong&gt;пиццы&lt;/strong&gt; &lt;em&gt;(ответы на обращение, например
HTML-документы).&lt;/em&gt; Есть два сценария, по которым можно их обрабатывать.&lt;/p&gt;
&lt;h3 id="blokiruiushchii-traditsionnyi"&gt;Блокирующий (традиционный)&lt;/h3&gt;
&lt;p&gt;Вы принимаете заказ, ставите пиццу в &lt;strong&gt;печь&lt;/strong&gt; &lt;em&gt;(системные ресурсы,
в.т.ч. оперативная память, необходимые для обработки запроса)&lt;/em&gt; и
непрерыано наблюдаете за тем как пицца печется. Как только пицца
готова - вы берете её и отдаете в руки &lt;strong&gt;заказчику&lt;/strong&gt; (источник заказа,
например браузер), после чего принимаете следующий заказ. При
необходимости можно нанять &lt;strong&gt;помощников&lt;/strong&gt; &lt;em&gt;(потоки выполнения,
threads)&lt;/em&gt;, чтобы следить за выпеканием пицц.&lt;/p&gt;
&lt;p&gt;Вы ограничены как количеством печей, так и количеством помощников,
которые могут поместиться в вашей пиццерии.&lt;/p&gt;
&lt;h3 id="neblokiruiushchii-epoll-i-analogi"&gt;Неблокирующий (epoll и аналоги)&lt;/h3&gt;
&lt;p&gt;Вы принимаете заказ, ставит пиццу в печь и ставите &lt;strong&gt;таймер&lt;/strong&gt;
&lt;em&gt;(операционная система посредством epoll)&lt;/em&gt;, чтобы узнать когда пицца
испечется. После чего Вы возвращаетесь к приему заказов. Как только
прозвенел таймер - Вы идете к соответствующей печи, достаете пиццу и
отдаете заказчику, после чего снова возвращаетесь к приему заказов.&lt;/p&gt;
&lt;p&gt;При таком подходе Вы ограничены лишь количеством печей и не нуждаетесь в
помощниках, хотя если срабатывает несколько таймеров одновременно могут
появлятся дополнительные задержки. В качестве бонуса легко готовить
пиццы, требующие длительного времени выпекания.&lt;/p&gt;
&lt;h2 id="zakliuchenie_1"&gt;Заключение&lt;/h2&gt;
&lt;p&gt;Как Вы уже догадались, цель этого поста не научить читателя работать с
&lt;strong&gt;epoll&lt;/strong&gt; напрямую или посредством распространенных библиотек (для
большинства веб-разработчиков это не нужно), а дать общее представление
о блокирующих и неблокирующих сокетах, принципах их работы и основных
отличиях. При выборе ключевых технологий и проектировании архитектуры
интернет-проекта эти вопросы определенно стоит иметь ввиду.&lt;/p&gt;
&lt;p&gt;Буду рад услышать дополнения и поправки в комментариях, &lt;a href="/feed/"&gt;до новых встреч&lt;/a&gt;!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Fri, 17 Feb 2012 16:27:00 +0400</pubDate><guid>tag:www.insight-it.ru,2012-02-17:linux/2012/kak-rabotaet-epoll/</guid><category>epoll</category><category>kqueue</category><category>Linux</category><category>sockets</category><category>разработка</category></item></channel></rss>
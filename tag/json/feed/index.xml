<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Insight IT</title><link>https://www.insight-it.ru/</link><description></description><atom:link href="https://www.insight-it.ru/tag/json/feed/index.xml" rel="self"></atom:link><lastBuildDate>Sat, 20 Oct 2012 12:32:00 +0400</lastBuildDate><item><title>Оптимизация интерактивных сайтов</title><link>https://www.insight-it.ru//interactive/2012/optimizaciya-interaktivnykh-sajjtov/</link><description>&lt;p&gt;Возвращаясь к теме&amp;nbsp;&lt;a href="https://www.insight-it.ru/interactive/"&gt;"Интерактивных сайтов"&lt;/a&gt;,&amp;nbsp;сегодня я хотел бы обсудить заключительную часть повествования, их
&lt;strong&gt;оптимизацию&lt;/strong&gt;. Возможно вы уже успели реализовать все или часть
обсуждавшихся в предыдущих статьях приемов, в этой статье я "подкину"
Вам еще несколько.&amp;nbsp;Настоятельно рекомендую прежде чем читать дальше
ознакомиться хотя бы с первой статьей про общую архитектуру, а лучше,
конечно, со всеми предыдущими статьями серии. В этот раз мы пройдемся по
всем обсуждавшимся в отдельных статьях компонентам, правда в другом
порядке, и будем обсуждать возможные пути их улучшения.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="oglavlenie-serii-interaktivnye-saity"&gt;Оглавление серии "Интерактивные сайты"&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://www.insight-it.ru/interactive/2012/arkhitektura-interaktivnykh-sajjtov/"&gt;Общая архитектура&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.insight-it.ru/interactive/2012/klientskaya-chast-interaktivnogo-sajjta/"&gt;Организация клиентской части&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.insight-it.ru/interactive/2012/postoyannoe-soedinenie-mezhdu-brauzerom-i-serverom/"&gt;Постоянное соединение между браузером и сервером&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.insight-it.ru/interactive/2012/povtornoe-ispolzovanie-shablonov/"&gt;Повторное использование шаблонов&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.insight-it.ru/interactive/2012/servernaya-chast-interaktivnogo-sajjta-i-potoki-soobshhenijj/"&gt;Серверная часть интерактивного сайта и потоки сообщений&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.insight-it.ru/interactive/2012/optimizaciya-interaktivnykh-sajjtov/"&gt;Оптимизация&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="servernaia-chast"&gt;Серверная часть&lt;/h2&gt;
&lt;p&gt;На серверной стороне есть масса простора для оптимизации, но, чтобы не
распыляться, постараюсь сосредоточиться лишь на том, что напрямую
связано с темой &lt;em&gt;интерактивных сайтов&lt;/em&gt;. В частности на процессе
маршрутизации сообщений и уведомлений между пользователями.&lt;/p&gt;
&lt;p&gt;Когда разрабатывается первая версия сайта, то многие части функционала
проще всего реализовать в виде массовых рассылок, как-то так: произошло
какое-то публично-доступное событие, допустим кто-то куда-то поставил
"мне нравится", отправляем его в брокер сообщений с пометкой "доставить
всем" &lt;em&gt;(fanout)&lt;/em&gt;. В итоге все подключенные на данный момент клиенты
получают это уведомление и каждый сам решает что с ним делать - что-то
менять на текущей странице или просто проигнорировать.&lt;/p&gt;
&lt;p&gt;Но при большом количестве соединений и потоке событий такой подход
становится роскошью. Большинство подобных ситуаций можно реализовать
подпиской на тематические &lt;em&gt;(topic)&lt;/em&gt; рассылки для каждого пользователя
индивидуально, то есть когда пользователь открывает ту или иную
страницу - серверная сторона должна подписать его на уведомления,
связанные именно с тем контентом, который находится у него на экране.
Это позволит свести к минимуму количество&amp;nbsp;доставленных&amp;nbsp;зря сообщений.&lt;/p&gt;
&lt;p&gt;Ситуации, когда правда нужны массовые рассылки по всем пользователям,
хоть и редки, но все же бывают. Если есть возможность их избежать, то
лучшей ей воспользоваться.&lt;/p&gt;
&lt;p&gt;Чтобы реализовать индивидуальные подписки как изложено выше, вероятно
понадобится еще и изменить принцип установления соединений между
брокером сообщений и сервером, поддерживающим постоянное соединение. Для
схемы массовых рассылок достаточно одного такого соединения на сервер.
Каждый сервер хранит список активных соединений с браузерами и, получив
новое сообщение от брокера, просто итеративно проходится по нему,
ретранслируя сообщение в каждое соединение. В таком случае для
последнего соединения в списке задержка может достигать нескольких
секунд, что не всегда приемлемо. Для схемы индивидуальных подписок есть
два основных варианта:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Реализовать мини-брокер внутри каждого такого сервера, т.е. сам
    сервер по-прежнему держит лишь одно соединение с настоящим брокером
    и получает все подряд сообщения, но прежде чем ретранслировать
    анализирует его и отправляет лишь части соединений.&lt;/li&gt;
&lt;li&gt;Либо держать создавать много примитивных процессов, которые с одной
    стороны держат соединение с браузером, с другой - с брокером. Каждый
    из них подписан именно на те сообщения, которые нужны данному
    пользователю, и ретранслируют их все без анализа.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="card blue lighten-4"&gt;
&lt;p&gt;&lt;div class="card-content"&gt;
Оба варианта имеют право на существование, какой окажется лучше -
зависит от многих факторов, нужно тестировать. Лично мне больше по душе
второй, но далеко не на каждой платформе его удастся эффективно
реализовать - настоящих системных процессов для такого использования
не&amp;nbsp;напасешься.
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="postoiannoe-soedinenie-mezhdu-brauzerom-i-serverom"&gt;Постоянное соединение между браузером и сервером&lt;/h2&gt;
&lt;p&gt;Помимо выбора удачной библиотеки абстракции протоколов для различных
браузеров, о чем я уже довольно подробно писал в соответствующей статье
серии, здесь я могу предложить еще два момента для значительного
улучшения производительности.&lt;/p&gt;
&lt;h3 id="mezhvkladochnoe-vzaimodeistvie-cross-tab-communication"&gt;Межвкладочное взаимодействие &lt;em&gt;(cross-tab communication)&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;На эту тему в Интернете ходит масса слухов и разговоров, но адекватной
инструкции о том как это можно кроссбраузерно организовать в разумные
сроки я не встречал, если кто знает - дайте в ссылку в комментариях,
пожалуйста. А я пока попробую поделиться своим опытом.&lt;/p&gt;
&lt;p&gt;Вкратце для тех, кто не в курсе: в самой простой реализации постоянное
соединение между браузером и сервером устанавливается для каждой вновь
открытой вкладки заново. Так как каждое такое соединение ресурсоемко, то
этого хотелось бы избежать. Помочь в этом может организация
&lt;strong&gt;межвкладочного взаимодействия&lt;/strong&gt; или, другими словами, общения между
вкладками/окнами браузера: одна вкладка избирается &lt;em&gt;главной&lt;/em&gt; и
устанавливает соединение с сервером, когда она получает новое
сообщение - она переправляет его конкретной открытой вкладке или же всем
сразу; те же, в свою очередь, когда хотят отправить сообщение на сервер,
отправляют его сначала &lt;em&gt;главной&lt;/em&gt; вкладке, а та уже пересылает на сервер.
В итоге все работает как и раньше, но соединений не больше одного на
браузер.&lt;/p&gt;
&lt;p&gt;Вообще в явном виде общение между вкладками браузера, как Вы, вероятно,
знаете, не предусмотрено. Именно из-за этого реализовать это все
кроссбраузерно не просто. Для начала приведу список технологий, которые
так или иначе можно для этого приспособить, большинство из них принято
относить к нынче модному &lt;a href="/tag/html5/"&gt;HTML5&lt;/a&gt;, в порядке возрастания
моих симпатий:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/704e1f8a/" rel="nofollow" target="_blank" title="http://en.wikipedia.org/wiki/Local_shared_object"&gt;Flash Local Shared Cookies&lt;/a&gt; - даже не рассматривал как вариант, так как требуется Adobe Flash, плюс, кажется, постоянно всплывает окно вроде
    &lt;a href="https://www.insight-it.ru/goto/e9a669cc/" rel="nofollow" target="_blank" title="http://www.macromedia.com/support/documentation/en/flashplayer/help/help06.html"&gt;этого&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/732af670/" rel="nofollow" target="_blank" title="http://caniuse.com/#feat=x-doc-messaging"&gt;postMessage&lt;/a&gt;&amp;nbsp;-&amp;nbsp;отправка
    сообщения указанному окну по его идентификатору. Поддержка
    браузерами хорошая, но большинство примеров показывают общение с
    iframe, а сопутствующего API для получения списка всех открытых
    окон/вкладок я не нашел, может быть плохо искал.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/86256a54/" rel="nofollow" target="_blank" title="http://caniuse.com/#feat=webworkers"&gt;Web Workers&lt;/a&gt; - в браузере
    создается не зависящий от вкладок поток, с которым можно общаться из
    вкладок. Поддержка браузерами хромает, а там где её нет -
    polyfill'ов пока не придумали.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/fc6c98e9/" rel="nofollow" target="_blank" title="http://caniuse.com/#feat=namevalue-storage"&gt;Web Storage&lt;/a&gt; -
    локальное хранилище пар ключ-значение с ограничением в 5-10Мб на
    домен. Хорошая поддержка браузерами, а там где её нет - есть
    polyfill'ы. Еще бывает &lt;a href="https://www.insight-it.ru/goto/71a12fd0/" rel="nofollow" target="_blank" title="http://caniuse.com/#feat=sql-storage"&gt;Web SQL&lt;/a&gt;, но для данной задачи это уже перебор.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В общем рекомендую последний вариант, из дополнительных плюсов хранилище
можно использовать и для других целей, но об этом в следующих разделах.&lt;/p&gt;
&lt;p&gt;Если есть желание и время можно работать напрямую с API хранилища, но
все же самостоятельно разбираться с особенностями браузеров - занятие не
благодарное, так что могу посоветовать взглянуть на имеющиеся opensource
библиотеки-обертки. Из тех, что я пробовал, мне больше всего нравится
&lt;strong&gt;&lt;a href="https://www.insight-it.ru/goto/288f4119/" rel="nofollow" target="_blank" title="http://www.jstorage.info/"&gt;jStorage&lt;/a&gt;&lt;/strong&gt;&amp;nbsp;из-за своей "зеленой" таблицы
поддержки браузерами и готовому publish/subscribe API.&lt;/p&gt;
&lt;p&gt;Итак, вкратце пройдемся по ориентировочному алгоритму реализации
межвкладочного взаимодействия:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Каждая вкладка при своем открытии придумывает себе уникальный
    идентификатор (проще всего на основе &lt;em&gt;Math.random&lt;/em&gt;), будем называть
    его &lt;strong&gt;tab_id&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;В хранилище будут храниться список всех активных tab_id, допустим,
    &lt;strong&gt;tabs&lt;/strong&gt; и tab_id &lt;em&gt;главной&lt;/em&gt; &lt;em&gt;вкладки&lt;/em&gt;, допустим,&amp;nbsp;&lt;strong&gt;master&lt;/strong&gt;. Каждая
    новая вкладка смотрит есть ли другие открытые вкладки. Если есть -
    просто дописывает себя в tabs, если нет - то еще и объявляет себя
    главной и открывает соединение с браузером.&lt;/li&gt;
&lt;li&gt;Далее она подписывается на сообщения отправленные лично ей (по её
    tab_id) и на различные типы сообщений, которые могут быть интересны
    всем вкладкам.&lt;/li&gt;
&lt;li&gt;В обработчике события &lt;em&gt;window.onbeforeunload&lt;/em&gt;&amp;nbsp;(происходит сразу же
    перед закрытием вкладки) каждая вкладка убирает себя из &lt;strong&gt;tabs&lt;/strong&gt;&amp;nbsp;и
    если она была главной, то и из &lt;strong&gt;master&lt;/strong&gt; тоже. Альтернативный
    вариант: &lt;strong&gt;master&lt;/strong&gt; сразу может выбирать себе "преемника". Так как
    это событие срабатывает не всегда (когда компьютер жестко вырубился
    питанием, фатальный сбой в браузере, плюс оно не поддерживается
    неоправданно популярной в рунете Оперой и мобильным Safari), то
    придется создать альтернативный механизм проверки активности
    &lt;strong&gt;master&lt;/strong&gt; и очистки &lt;strong&gt;tabs&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Так как какого-либо API для проверки открыта ли вкладка по её
    &lt;strong&gt;tab_id&amp;nbsp;&lt;/strong&gt;по очевидным причинам нет, нужно придумать свою схему.
    Самый простой рабочий вариант, пришедший мне в голову:&lt;ul&gt;
&lt;li&gt;Главная вкладка пишет каждые несколько сотен&amp;nbsp;миллисекунд&amp;nbsp;в
    хранилище текущую дату/время, теоретически так как все
    происходит на одном компьютере, то текущее время во всех
    вкладках должно быть одно и то же;&lt;/li&gt;
&lt;li&gt;Не-главные вкладки каждые 1-3 секунд читают значение из того же
    места в хранилище и если оно отстает от текущего на, допустим,
    больше чем секунду, то главную вкладку, вероятно, закрыли и надо
    её "свергнуть" - удалить из &lt;strong&gt;tabs&lt;/strong&gt; и &lt;strong&gt;master&lt;/strong&gt;&amp;nbsp;и назначить,
    например, первую или последнюю запись из списка&amp;nbsp;&lt;strong&gt;tabs&lt;/strong&gt; новой
    главной вкладкой;&lt;/li&gt;
&lt;li&gt;Если выбранная новая вкладка тоже оказалась уже закрыта, не
    беда - во всех случаях, кроме совсем неадекватных, этот не
    хитрый механизм переберет все&amp;nbsp;&lt;strong&gt;tabs&lt;/strong&gt; и найдет-таки нормальную
    открытую;&lt;/li&gt;
&lt;li&gt;Каждая вкладка подписывается на изменения значения &lt;strong&gt;master&lt;/strong&gt;,
    чтобы если новое значение совпадет с её tab_id открыть
    соединение с сервером.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Отправка сообщений происходит по простому publish/subscribe, где
    master подписывается и ретранслирует в соединение с сервером, а
    отправляют все остальные вкладки. Если вкладка отправляет запрос,
    ответ на который хочет получить только она сама (чаще всего переход
    на другую страницу сайта или отправка формы), то она указывает в
    отправляемом запросе свой "обратный адрес" в виде tab_id. Master,
    получив ответ на такое сообщение с указанным обратным адресом,
    перенаправляет его отправителю.&lt;/li&gt;
&lt;li&gt;Также в хранилище полезно иметь переменную-флаг (также с подпиской
    на изменения), обозначающую открыто ли сейчас где-то постоянное
    соединение, чтобы вместо того, чтобы отправлять сообщения&amp;nbsp;в
    никуда&amp;nbsp;вкладки использовали какой-то альтернативный способ (AJAX или
    переход по ссылке / отправка формы средствами браузера). В качестве
    альтернативы можно реализовать очередь неотправленных сообщений, но
    по факту когда с соединением проблемы, то неизвестно когда они
    устранятся и устранятся ли вообще, так что смысла в ней чаще всего
    мало.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Надеюсь вышеизложенное окажется кому-то полезным, если нужны какие-то
уточнения - не стесняйтесь спрашивать в комментариях.&lt;/p&gt;
&lt;h3 id="minimizatsiia-razmera-soobshchenii"&gt;Минимизация размера сообщений&lt;/h3&gt;
&lt;p&gt;&lt;a href="/tag/json/"&gt;JSON&lt;/a&gt; хоть и сильно выигрывает у &lt;a href="/tag/xml/"&gt;XML&lt;/a&gt;&amp;nbsp;по объему
сериализованных сообщений, но все же является текстовым форматом с
указанием схемы (название для каждого значения) внутри самого сообщения.
Почему минимизация объема передаваемых по постоянному соединению
данных - дело полезное, объяснять, думаю, не стоит.&lt;/p&gt;
&lt;p&gt;Первое, что приходит в голову, чтобы уменьшить объем сообщений -
избавиться от включенной в них схемы, оставив только чистые данные.
Изобретать свой формат ни к чему, есть неплохой&amp;nbsp;широко
распространенный&amp;nbsp;кандидат в виде &lt;a href="/tag/google/"&gt;Google&lt;/a&gt;&amp;nbsp;&lt;a href="/tag/protocol-buffers/"&gt;Protocol
Buffers&lt;/a&gt;. Кстати, недавно нашел библиотеку с
&lt;a href="/tag/javascript/"&gt;JavaScript&lt;/a&gt; реализацией Protocol Buffers с хорошими
отзывами, в ближайшее время думаю сам опробую:
&lt;a href="https://www.insight-it.ru/goto/a420ea/" rel="nofollow" target="_blank" title="https://github.com/sirikata/protojs"&gt;protojs&lt;/a&gt;. Если кто уже работал с
ней - буду рад, если поделитесь впечатлениями.&lt;/p&gt;
&lt;p&gt;Но на практике оказалось, что эта самая схема обычно занимает максимум
10-20% от сообщения, так как большинство данных все же текстовые.
Использование Protocol Buffers было бы намного более выгодным, если бы
было необходимо "упаковать" много чисел или флагов, для текстовых данных
выигрыш намного меньше.&lt;/p&gt;
&lt;p&gt;Экономии в разы можно добиться используя обычные алгоритмы компрессии
(или, если так привычнее, архивации) данных.
&lt;a href="/tag/javascript/"&gt;JavaScrtipt&lt;/a&gt; "из коробки" этого делать не умеет, но
есть полно библиотек на любой вкус и цвет, правда все хромают и чаще
всего не кроссбраузерные. Приведу несколько, которые запомнились после
вечера, проведенного за изучением данного вопроса:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/be52f434/" rel="nofollow" target="_blank" title="http://rosettacode.org/wiki/LZW_compression"&gt;LZW&lt;/a&gt; - есть реализации
    на большинстве языков программирования, но компрессия не очень
    сильная (раза в полтора-два в лучшем случае), плюс реализация под
    интересующий меня &lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt; оказалась дико неэффективна
    по памяти, а на бинарных строках сходу не нашлась.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/49c64f8e/" rel="nofollow" target="_blank" title="https://github.com/imaya/zlib.js"&gt;zlib.js&lt;/a&gt; - умеет &lt;em&gt;zlib (deflate)&lt;/em&gt;
    и &lt;em&gt;gzip&lt;/em&gt;, но, к сожалению, в моем браузере не могла разжать обратно
    то, что сжала, плюс объем кода библиотеки очень большой.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/730dabaf/" rel="nofollow" target="_blank" title="https://github.com/dankogai/js-deflate"&gt;js-deflate&lt;/a&gt; - не
    обновлялась уже 4 года, отсутствует документация, но зато в целом
    работает. Подбирать метод компрессии для серверной стороны пришлось
    почти экспериментально, оказался &lt;em&gt;zlib (deflate)&lt;/em&gt; без заголовков и
    контрольной суммы (в &lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt; встроенная функция zlib:zip). Компрессия примерно в 3-4 раза.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Если все же решите использовать компрессию, то рекомендую реализовать
флаг для ситуаций когда в клиенте все же декомпрессия по каким-то
причинам сломана. Достаточно просто сжать-разжать короткую строку и
сравнить с оригиналом, если не совпало или выскочило исключение -
просить сервер отвечать без компрессии.&lt;/p&gt;
&lt;p&gt;По поводу дополнительных вычислительных ресурсов, которые будут
потребляться на компрессию/декомпрессию, вопрос, конечно, спорный, в
целом надо все мерять и делать выводы. Но если учесть, что почти во всех
современных устройствах, даже телефонах, как минимум 1Ггц процессор, а
на сервере можно кэшировать уже сжатые данные, то это не особо большая
проблема. К слову объем сообщений уменьшается тоже не гарантированно,
бывает что "сжатая" версия оказывается такой же или даже чуть больше,
чем оригинал. В общем, использовать компрессию нужно осторожно :)&lt;/p&gt;
&lt;h2 id="povtornoe-ispolzovanie-shablonov_1"&gt;Повторное использование шаблонов&lt;/h2&gt;
&lt;p&gt;Сообщение со списком шаблонов для использование на клиентской части,
вероятно, будет самым большим по объему и больше других выиграет от
компрессии. Но есть возможность легко минимизировать и количество таких
сообщений. Помните, я писал, что локальное хранилище в браузере можно и
для других целей использовать?&lt;/p&gt;
&lt;p&gt;Кэширование шаблонов - идеальный пример. Получив от сервера шаблоны он
кладет их не только в объект-обертку, но и в локальное хранилище. На
сервере помимо самого JSON'а с шаблонами генерируем хэш (md5, sha или
crc - не важно) текущей версии. Клиент, когда открывает соединение,
сообщает серверу есть ли у него какая-то версия и если есть, то какая,
сервер отправляет новую версию в ответ только если хэши не совпали.&lt;/p&gt;
&lt;p&gt;Аналогичным образом можно кэшировать и другую редко меняющуюся объемную
информацию, например данные для автодополнения в текстовых полях
&lt;em&gt;(autocomplete)&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id="zakliuchenie"&gt;Заключение&lt;/h2&gt;
&lt;p&gt;Надеюсь предложенные в этой статье приемы окажутся Вам полезны. Буду
рад, если Вы поделитесь своим опытом и приемами по данной теме в
комментариях, а также с удовольствием обсужу подробности.&lt;/p&gt;
&lt;div class="card green"&gt;
&lt;p&gt;&lt;div class="card-content white-text"&gt;
Эта статья - шестая и заключительная в &lt;a class="green-text text-lighten-4" href="https://www.insight-it.ru/interactive/"&gt;серии про Интерактивные сайты&lt;/a&gt;, автор - &lt;a class="green-text text-lighten-4" href="https://www.insight-it.ru/goto/b03d9116/" rel="nofollow" target="_blank" title="http://blinkov.ru"&gt;Иван&amp;nbsp;Блинков&lt;/a&gt;, основано на личном опыте.
До встречи &lt;a class="green-text text-lighten-4" href="/feed/"&gt;на страницах Insight IT&lt;/a&gt;!
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sat, 20 Oct 2012 12:32:00 +0400</pubDate><guid>tag:www.insight-it.ru,2012-10-20:interactive/2012/optimizaciya-interaktivnykh-sajjtov/</guid><category>deflate</category><category>html5</category><category>JavaScript</category><category>JSON</category><category>jStorage</category><category>Protocol Buffers</category><category>Web Storage</category><category>zlib</category><category>клиентская оптимизация</category><category>компрессия</category><category>кэширование</category><category>оптимизация</category></item><item><title>Повторное использование шаблонов</title><link>https://www.insight-it.ru//interactive/2012/povtornoe-ispolzovanie-shablonov/</link><description>&lt;blockquote&gt;
&lt;p&gt;Лень - двигатель прогресса&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Сегодня мы рассмотрим способ, позволяющий немного упростить себе жизнь
при создании &lt;a href="https://www.insight-it.ru/interactive/"&gt;интерактивного сайта&lt;/a&gt;&amp;nbsp;путем повторного использования шаблонов. Визуально результат будет примерно таким же, как при дублировании бизнес-логики в браузере, но ценой существенно меньших
трудозатрат на разработку JavaScript-клиента, да и на серверной части
тоже. Хотите узнать как это провернуть?&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Небольшая ремарка, чтобы не было недопонимания из-за терминологии:&lt;/p&gt;
&lt;div class="card blue lighten-4"&gt;
&lt;div class="card-content"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Шаблон&lt;/strong&gt;&amp;ensp;&lt;em&gt;(template)&lt;/em&gt; : HTML-документ с расширенным набором тегов,
    которые впоследствии используются для подстановки динамических
    данных.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Шаблонизатор&lt;/strong&gt;&amp;ensp;&lt;em&gt;(templating engine)&lt;/em&gt; : библиотека, позволяющая на
    основе &lt;em&gt;шаблона&lt;/em&gt; (использующего определенный синтаксис
    дополнительных тегов) и &lt;em&gt;динамических данных&lt;/em&gt; получить итоговый
    HTML-документ, пригодный для отображения в браузере.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Рендеринг&lt;/strong&gt;&amp;ensp;&lt;em&gt;(rendering)&lt;/em&gt; : в данном контексте &amp;mdash; процесс, которым занимается шаблонизатор.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id="obshchii-printsip"&gt;Общий принцип&lt;/h2&gt;
&lt;p&gt;Чтобы сразу в голове сложилась нужная картина, начнем с дополненной
схемы из статьи про &lt;a href="https://www.insight-it.ru/interactive/2012/arkhitektura-interaktivnykh-sajjtov/"&gt;архитектуру интерактивных сайтов&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Повторное использование шаблонов" class="responsive-img" src="https://www.insight-it.ru/images/templates.jpeg" title="Повторное использование шаблонов"/&gt;&lt;/p&gt;
&lt;p&gt;Если вкратце, то стандартный интерфейс внутренних сервисов, скрывающихся
за блоком &lt;strong&gt;"Бизнес-логика"&lt;/strong&gt;, можно реализовать таким образом, чтобы он
возвращал все необходимые данные для рендеринга шаблона плюс его имя.
База &lt;strong&gt;шаблонов&lt;/strong&gt; у всех общая, у каждого уникальное имя, каждый сервер
интерфейсов (обоих) держит по копии всех шаблонов в памяти.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML интерфейс&lt;/strong&gt; просто разбирает HTTP-запросы, отправляет на его
основе сообщение(ия) внутренним сервисам, получает в ответ имя шаблона и
данные для его заполнения, с помощью &lt;strong&gt;шаблонизатора&lt;/strong&gt; рендерит итоговый
&lt;a href="/tag/html/"&gt;HTML&lt;/a&gt; и отдает браузеру или роботу.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Интерфейс сериализованных данных&lt;/strong&gt;&amp;ensp;&lt;em&gt;(если он, как и обсуждалось ранее,
работает через &lt;a href="https://www.insight-it.ru/interactive/2012/postoyannoe-soedinenie-mezhdu-brauzerom-i-serverom/"&gt;постоянное соединение с браузером&lt;/a&gt;)&lt;/em&gt;&amp;nbsp;каждому
подключившемуся клиенту первым делом отправляет
&lt;a href="/tag/json/"&gt;JSON&lt;/a&gt;-объект с шаблонами, по крайней мере если их не особо
много, иначе лучше "по запросу". При действии пользователя
JavaScript-клиент отправляет сообщение с информацией, на его основе
интерфейс сериализованных данных передает то же самое (а может и как-то
модифицированное) сообщение внутреннему сервису, также получает в ответ
имя шаблона и данные и перенаправляет их клиенту (возможно
сконвертировав в другой формат). Клиенту остается передать их своему
шаблонизатору и заменить результатом его работы какую-то часть уже
имеющегося в окне браузера HTML-документа.&lt;/p&gt;
&lt;h2 id="rendering"&gt;Рендеринг&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Шаблонизаторов&lt;/strong&gt; сейчас доступно огромное количество под любую
платформу, с разной производительностью и возможностями, но чтобы
воплотить эту стратегию в жизнь подойдут далеко не все. Два основных
требования:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Отсутствие внешних вызовов при рендеринге&lt;/em&gt;, то есть на входе только
    данные, если используются какие-то фильтры или что-то такое - они
    должны быть частью шаблонизатора.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Шаблонизатор должен иметь реализацию на JavaScript&lt;/em&gt;, так как будет
    исполняться в том числе и в браузере.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Да, многофункциональные шаблонизаторы вроде &lt;a href="/tag/jinja2/"&gt;Jinja2&lt;/a&gt; - это
очень удобно, но конкретно в данном случае богатый ассортимент
возможностей не уместен. Наиболее известный &lt;em&gt;кроссплатформенный&lt;/em&gt;
шаблонизатор, не обремененный ничем лишним, называется
&lt;strong&gt;&lt;a href="https://www.insight-it.ru/goto/89b84f30/" rel="nofollow" target="_blank" title="http://mustache.github.io/"&gt;mustache&lt;/a&gt;&lt;/strong&gt;. С его использованием иногда
получаются довольно замысловатые конструкции, но зато он отлично
подходит под этот сценарий использования и прост как три копейки,
изучить можно за 5 минут, &lt;em&gt;рекомендую&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;В этой схеме напрашивается использование &lt;a href="/tag/node-js/"&gt;node.js&lt;/a&gt; для
реализации &lt;strong&gt;HTML-интерфейса&lt;/strong&gt;, что откроет доступ к многочисленным
шаблонизаторам, &lt;a href="https://www.insight-it.ru/goto/261edaf6/" rel="nofollow" target="_blank" title="https://github.com/joyent/node/wiki/modules#wiki-templating"&gt;реализованным исключительно на JavaScript&lt;/a&gt;.
Тем более кроме рендеринга шаблонов эта часть проекта практически ничего
и не делает. В качестве бонуса требование про отсутствие внешних вызовов
станет не таким строгим, да и в целом, если минималистичное решение
вроде &lt;a href="/tag/mustache/"&gt;mustache&lt;/a&gt;&amp;nbsp;по каким-то идеологическим соображениям
не устраивает - любой написанный для node.js шаблонизатор наверняка
станет отличным выходом.&lt;/p&gt;
&lt;h2 id="struktura-shablonov"&gt;Структура шаблонов&lt;/h2&gt;
&lt;p&gt;При рендеринге на клиентской стороне &lt;strong&gt;обычно&lt;/strong&gt; нужно заменять лишь
содержимое определенного блока, где располагается основной контент
сайта. Изменения в в других частях сайта нужны существенно реже,
соответственно стоит вынести их в отдельные шаблоны.&lt;/p&gt;
&lt;p&gt;Таким образом большинство шаблонов, соответствующих страницам сайта,
представляют собой содержимое одного блока. Отдельные шаблоны,
актуальные для всего сайта, создаются для:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Блока &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; документа&lt;/li&gt;
&lt;li&gt;Видимой "шапки" сайта&lt;/li&gt;
&lt;li&gt;Сайдбара(ов), если они не сильно зависят от основного контентом
    страниц&lt;/li&gt;
&lt;li&gt;Видимого "подвала" сайта плюс тегов для подключения
    &lt;a href="/tag/javascript/"&gt;JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HTML-интерфейс&lt;/strong&gt; при чтении их из файловой системы "склеивает" их в
полные шаблоны для каждой страницы, просто конкатенацией или с
использованием механизмов шаблонизатора. &lt;strong&gt;Интерфейс сериализованных
данных&lt;/strong&gt; "заворачивает" шаблоны страниц в JSON (или другой используемый
формат) прямо в исходном виде для вставки в блок с основным контентом.
Из "общесайтовых"&amp;nbsp;шаблонов браузерному клиенту вероятно могут
понадобиться только сайдбар(ы), и то не всегда.&lt;/p&gt;
&lt;p&gt;Изменения в остальных частях сайта лучше все же отдать на совесть
&lt;em&gt;представлений&lt;/em&gt; на основе клиентского фреймворка. В первую очередь это
касается изменения &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; и других мета-тегов.&lt;/p&gt;
&lt;h2 id="primechaniia"&gt;Примечания&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;При использовании минималистичного шаблонизатора без внешних вызовов
    будьте морально готовы передавать ему "многоуровневые" объекты для
    вставки в шаблон. Например, если говорить о постраничной навигации,
    там, где в продвинутом шаблонизаторе было бы что-то вроде &lt;code&gt;{% pagination(current_page, total_pages) %}&lt;/code&gt;,&amp;nbsp;может понадобится не
    только написать саму верстку (что, в целом, хорошая практика), а еще
    и передать информацию о точном списке страниц, какая именно из них
    активная, где пропуски и пр.&lt;/li&gt;
&lt;li&gt;Стоит обращать внимание на производительность используемого
    шаблонизатора. Например, под одну из платформ "официальная"
    реализация &lt;strong&gt;mustache&lt;/strong&gt;, как оказалось,&amp;nbsp;проигрывает сторонней с
    отрывом в 2 порядка.&lt;/li&gt;
&lt;li&gt;Хоть при таком подходе добиться одинакового внешнего вида страниц
    при рендеринге серверной и клиентской частью достаточно легко,
    следить за их соответствием все же стоит - какие-то детали можно и
    упустить.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="zakliuchenie"&gt;Заключение&lt;/h2&gt;
&lt;p&gt;Как я уже намекал в конце &lt;a href="https://www.insight-it.ru/interactive/2012/postoyannoe-soedinenie-mezhdu-brauzerom-i-serverom/"&gt;предыдущего материала&lt;/a&gt;,
обсуждавшийся в этой статье подход не совсем &lt;em&gt;"идеологически
правильный"&lt;/em&gt;, по крайней мере с точки зрения используемого &lt;em&gt;клиентского
фреймворка&lt;/em&gt;. &lt;strong&gt;Модели&lt;/strong&gt;,&amp;nbsp;вероятно,&amp;nbsp;будут использоваться для хранения
библиотеки шаблонов и данных для их рендеринга, а не для объектов
предметной области проекта. &lt;strong&gt;Представления&lt;/strong&gt; будут отвечать лишь за
рендеринг шаблонов и синхронизацию второстепенных элементов интерфейса.
Если Вы все же пойдете по этому пути, хочется, чтобы Вы сделали это
осознанно. Альтернативный сценарий создания полноценного
JavaScript-приложения для работы в браузере для некоторых проектов
по-прежнему может оказаться более предпочтительным.&lt;/p&gt;
&lt;p&gt;В&amp;nbsp;следующей&amp;nbsp;статье мы наконец-то перейдем к более привычной для меня
&lt;em&gt;серверной части&lt;/em&gt; интерактивных сайтов, там тоже есть много интересных
моментов, которые стоит обсудить.&lt;/p&gt;
&lt;div class="card green"&gt;
&lt;p&gt;&lt;div class="card-content white-text"&gt;
Эта статья - четвертая в &lt;a class="green-text text-lighten-4" href="https://www.insight-it.ru/interactive/"&gt;серии про Интерактивные сайты&lt;/a&gt;, автор - &lt;a class="green-text text-lighten-4" href="https://www.insight-it.ru/goto/b03d9116/" rel="nofollow" target="_blank" title="http://blinkov.ru"&gt;Иван&amp;nbsp;Блинков&lt;/a&gt;, основано на личном опыте.
До встречи &lt;a class="green-text text-lighten-4" href="/feed/"&gt;на страницах Insight IT&lt;/a&gt;!
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Fri, 13 Apr 2012 08:00:00 +0400</pubDate><guid>tag:www.insight-it.ru,2012-04-13:interactive/2012/povtornoe-ispolzovanie-shablonov/</guid><category>html</category><category>JSON</category><category>mustache</category><category>node.js</category><category>rendering</category><category>template</category><category>template engine</category><category>интерфейс</category><category>шаблон</category><category>шаблонизация</category></item></channel></rss>
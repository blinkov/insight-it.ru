<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Insight IT</title><link>https://www.insight-it.ru/</link><description></description><atom:link href="https://www.insight-it.ru/tag/rendering/feed/index.xml" rel="self"></atom:link><lastBuildDate>Fri, 13 Apr 2012 08:00:00 +0400</lastBuildDate><item><title>Повторное использование шаблонов</title><link>https://www.insight-it.ru//interactive/2012/povtornoe-ispolzovanie-shablonov/</link><description>&lt;blockquote&gt;
&lt;p&gt;Лень - двигатель прогресса&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Сегодня мы рассмотрим способ, позволяющий немного упростить себе жизнь
при создании &lt;a href="https://www.insight-it.ru/interactive/"&gt;интерактивного сайта&lt;/a&gt;&amp;nbsp;путем повторного использования шаблонов. Визуально результат будет примерно таким же, как при дублировании бизнес-логики в браузере, но ценой существенно меньших
трудозатрат на разработку JavaScript-клиента, да и на серверной части
тоже. Хотите узнать как это провернуть?&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Небольшая ремарка, чтобы не было недопонимания из-за терминологии:&lt;/p&gt;
&lt;div class="card blue lighten-4"&gt;
&lt;div class="card-content"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Шаблон&lt;/strong&gt;&amp;ensp;&lt;em&gt;(template)&lt;/em&gt; : HTML-документ с расширенным набором тегов,
    которые впоследствии используются для подстановки динамических
    данных.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Шаблонизатор&lt;/strong&gt;&amp;ensp;&lt;em&gt;(templating engine)&lt;/em&gt; : библиотека, позволяющая на
    основе &lt;em&gt;шаблона&lt;/em&gt; (использующего определенный синтаксис
    дополнительных тегов) и &lt;em&gt;динамических данных&lt;/em&gt; получить итоговый
    HTML-документ, пригодный для отображения в браузере.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Рендеринг&lt;/strong&gt;&amp;ensp;&lt;em&gt;(rendering)&lt;/em&gt; : в данном контексте &amp;mdash; процесс, которым занимается шаблонизатор.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id="obshchii-printsip"&gt;Общий принцип&lt;/h2&gt;
&lt;p&gt;Чтобы сразу в голове сложилась нужная картина, начнем с дополненной
схемы из статьи про &lt;a href="https://www.insight-it.ru/interactive/2012/arkhitektura-interaktivnykh-sajjtov/"&gt;архитектуру интерактивных сайтов&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Повторное использование шаблонов" class="responsive-img" src="https://www.insight-it.ru/images/templates.jpeg" title="Повторное использование шаблонов"/&gt;&lt;/p&gt;
&lt;p&gt;Если вкратце, то стандартный интерфейс внутренних сервисов, скрывающихся
за блоком &lt;strong&gt;"Бизнес-логика"&lt;/strong&gt;, можно реализовать таким образом, чтобы он
возвращал все необходимые данные для рендеринга шаблона плюс его имя.
База &lt;strong&gt;шаблонов&lt;/strong&gt; у всех общая, у каждого уникальное имя, каждый сервер
интерфейсов (обоих) держит по копии всех шаблонов в памяти.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML интерфейс&lt;/strong&gt; просто разбирает HTTP-запросы, отправляет на его
основе сообщение(ия) внутренним сервисам, получает в ответ имя шаблона и
данные для его заполнения, с помощью &lt;strong&gt;шаблонизатора&lt;/strong&gt; рендерит итоговый
&lt;a href="/tag/html/"&gt;HTML&lt;/a&gt; и отдает браузеру или роботу.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Интерфейс сериализованных данных&lt;/strong&gt;&amp;ensp;&lt;em&gt;(если он, как и обсуждалось ранее,
работает через &lt;a href="https://www.insight-it.ru/interactive/2012/postoyannoe-soedinenie-mezhdu-brauzerom-i-serverom/"&gt;постоянное соединение с браузером&lt;/a&gt;)&lt;/em&gt;&amp;nbsp;каждому
подключившемуся клиенту первым делом отправляет
&lt;a href="/tag/json/"&gt;JSON&lt;/a&gt;-объект с шаблонами, по крайней мере если их не особо
много, иначе лучше "по запросу". При действии пользователя
JavaScript-клиент отправляет сообщение с информацией, на его основе
интерфейс сериализованных данных передает то же самое (а может и как-то
модифицированное) сообщение внутреннему сервису, также получает в ответ
имя шаблона и данные и перенаправляет их клиенту (возможно
сконвертировав в другой формат). Клиенту остается передать их своему
шаблонизатору и заменить результатом его работы какую-то часть уже
имеющегося в окне браузера HTML-документа.&lt;/p&gt;
&lt;h2 id="rendering"&gt;Рендеринг&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Шаблонизаторов&lt;/strong&gt; сейчас доступно огромное количество под любую
платформу, с разной производительностью и возможностями, но чтобы
воплотить эту стратегию в жизнь подойдут далеко не все. Два основных
требования:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Отсутствие внешних вызовов при рендеринге&lt;/em&gt;, то есть на входе только
    данные, если используются какие-то фильтры или что-то такое - они
    должны быть частью шаблонизатора.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Шаблонизатор должен иметь реализацию на JavaScript&lt;/em&gt;, так как будет
    исполняться в том числе и в браузере.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Да, многофункциональные шаблонизаторы вроде &lt;a href="/tag/jinja2/"&gt;Jinja2&lt;/a&gt; - это
очень удобно, но конкретно в данном случае богатый ассортимент
возможностей не уместен. Наиболее известный &lt;em&gt;кроссплатформенный&lt;/em&gt;
шаблонизатор, не обремененный ничем лишним, называется
&lt;strong&gt;&lt;a href="https://www.insight-it.ru/goto/fff99a22/" rel="nofollow" target="_blank" title="http://mustache.github.com/"&gt;mustache&lt;/a&gt;&lt;/strong&gt;. С его использованием иногда
получаются довольно замысловатые конструкции, но зато он отлично
подходит под этот сценарий использования и прост как три копейки,
изучить можно за 5 минут, &lt;em&gt;рекомендую&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;В этой схеме напрашивается использование &lt;a href="/tag/node-js/"&gt;node.js&lt;/a&gt; для
реализации &lt;strong&gt;HTML-интерфейса&lt;/strong&gt;, что откроет доступ к многочисленным
шаблонизаторам, &lt;a href="https://www.insight-it.ru/goto/261edaf6/" rel="nofollow" target="_blank" title="https://github.com/joyent/node/wiki/modules#wiki-templating"&gt;реализованным исключительно на JavaScript&lt;/a&gt;.
Тем более кроме рендеринга шаблонов эта часть проекта практически ничего
и не делает. В качестве бонуса требование про отсутствие внешних вызовов
станет не таким строгим, да и в целом, если минималистичное решение
вроде &lt;a href="/tag/mustache/"&gt;mustache&lt;/a&gt;&amp;nbsp;по каким-то идеологическим соображениям
не устраивает - любой написанный для node.js шаблонизатор наверняка
станет отличным выходом.&lt;/p&gt;
&lt;h2 id="struktura-shablonov"&gt;Структура шаблонов&lt;/h2&gt;
&lt;p&gt;При рендеринге на клиентской стороне &lt;strong&gt;обычно&lt;/strong&gt; нужно заменять лишь
содержимое определенного блока, где располагается основной контент
сайта. Изменения в в других частях сайта нужны существенно реже,
соответственно стоит вынести их в отдельные шаблоны.&lt;/p&gt;
&lt;p&gt;Таким образом большинство шаблонов, соответствующих страницам сайта,
представляют собой содержимое одного блока. Отдельные шаблоны,
актуальные для всего сайта, создаются для:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Блока &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; документа&lt;/li&gt;
&lt;li&gt;Видимой "шапки" сайта&lt;/li&gt;
&lt;li&gt;Сайдбара(ов), если они не сильно зависят от основного контентом
    страниц&lt;/li&gt;
&lt;li&gt;Видимого "подвала" сайта плюс тегов для подключения
    &lt;a href="/tag/javascript/"&gt;JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HTML-интерфейс&lt;/strong&gt; при чтении их из файловой системы "склеивает" их в
полные шаблоны для каждой страницы, просто конкатенацией или с
использованием механизмов шаблонизатора. &lt;strong&gt;Интерфейс сериализованных
данных&lt;/strong&gt; "заворачивает" шаблоны страниц в JSON (или другой используемый
формат) прямо в исходном виде для вставки в блок с основным контентом.
Из "общесайтовых"&amp;nbsp;шаблонов браузерному клиенту вероятно могут
понадобиться только сайдбар(ы), и то не всегда.&lt;/p&gt;
&lt;p&gt;Изменения в остальных частях сайта лучше все же отдать на совесть
&lt;em&gt;представлений&lt;/em&gt; на основе клиентского фреймворка. В первую очередь это
касается изменения &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; и других мета-тегов.&lt;/p&gt;
&lt;h2 id="primechaniia"&gt;Примечания&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;При использовании минималистичного шаблонизатора без внешних вызовов
    будьте морально готовы передавать ему "многоуровневые" объекты для
    вставки в шаблон. Например, если говорить о постраничной навигации,
    там, где в продвинутом шаблонизаторе было бы что-то вроде &lt;code&gt;{% pagination(current_page, total_pages) %}&lt;/code&gt;,&amp;nbsp;может понадобится не
    только написать саму верстку (что, в целом, хорошая практика), а еще
    и передать информацию о точном списке страниц, какая именно из них
    активная, где пропуски и пр.&lt;/li&gt;
&lt;li&gt;Стоит обращать внимание на производительность используемого
    шаблонизатора. Например, под одну из платформ "официальная"
    реализация &lt;strong&gt;mustache&lt;/strong&gt;, как оказалось,&amp;nbsp;проигрывает сторонней с
    отрывом в 2 порядка.&lt;/li&gt;
&lt;li&gt;Хоть при таком подходе добиться одинакового внешнего вида страниц
    при рендеринге серверной и клиентской частью достаточно легко,
    следить за их соответствием все же стоит - какие-то детали можно и
    упустить.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="zakliuchenie"&gt;Заключение&lt;/h2&gt;
&lt;p&gt;Как я уже намекал в конце &lt;a href="https://www.insight-it.ru/interactive/2012/postoyannoe-soedinenie-mezhdu-brauzerom-i-serverom/"&gt;предыдущего материала&lt;/a&gt;,
обсуждавшийся в этой статье подход не совсем &lt;em&gt;"идеологически
правильный"&lt;/em&gt;, по крайней мере с точки зрения используемого &lt;em&gt;клиентского
фреймворка&lt;/em&gt;. &lt;strong&gt;Модели&lt;/strong&gt;,&amp;nbsp;вероятно,&amp;nbsp;будут использоваться для хранения
библиотеки шаблонов и данных для их рендеринга, а не для объектов
предметной области проекта. &lt;strong&gt;Представления&lt;/strong&gt; будут отвечать лишь за
рендеринг шаблонов и синхронизацию второстепенных элементов интерфейса.
Если Вы все же пойдете по этому пути, хочется, чтобы Вы сделали это
осознанно. Альтернативный сценарий создания полноценного
JavaScript-приложения для работы в браузере для некоторых проектов
по-прежнему может оказаться более предпочтительным.&lt;/p&gt;
&lt;p&gt;В&amp;nbsp;следующей&amp;nbsp;статье мы наконец-то перейдем к более привычной для меня
&lt;em&gt;серверной части&lt;/em&gt; интерактивных сайтов, там тоже есть много интересных
моментов, которые стоит обсудить.&lt;/p&gt;
&lt;div class="card green"&gt;
&lt;p&gt;&lt;div class="card-content white-text"&gt;
Эта статья - четвертая в &lt;a class="green-text text-lighten-4" href="https://www.insight-it.ru/interactive/"&gt;серии про Интерактивные сайты&lt;/a&gt;, автор - &lt;a class="green-text text-lighten-4" href="https://www.insight-it.ru/goto/b03d9116/" rel="nofollow" target="_blank" title="http://blinkov.ru"&gt;Иван&amp;nbsp;Блинков&lt;/a&gt;, основано на личном опыте.
До встречи &lt;a class="green-text text-lighten-4" href="/feed/"&gt;на страницах Insight IT&lt;/a&gt;!
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Fri, 13 Apr 2012 08:00:00 +0400</pubDate><guid>tag:www.insight-it.ru,2012-04-13:interactive/2012/povtornoe-ispolzovanie-shablonov/</guid><category>html</category><category>JSON</category><category>mustache</category><category>node.js</category><category>rendering</category><category>template</category><category>template engine</category><category>интерфейс</category><category>шаблон</category><category>шаблонизация</category></item></channel></rss>
<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Insight IT</title><link>https://www.insight-it.ru/</link><description></description><atom:link href="https://www.insight-it.ru/category/theory/feed/index.xml" rel="self"></atom:link><lastBuildDate>Mon, 29 Apr 2013 10:47:00 +0400</lastBuildDate><item><title>Горячая замена кода</title><link>https://www.insight-it.ru//theory/2013/goryachaya-zamena-koda/</link><description>&lt;p&gt;Относительно недавно почитывая RSS через доживающий свои дни Google
Reader, о предстоящем закрытии которого не написал только самый ленивый
IT-блоггер &lt;em&gt;(к слову, любопытно насколько
сильно просядет счетчик &lt;a href="/feed/"&gt;RSS-подписчиков Insight IT&lt;/a&gt; с текущих
16870, боюсь, что очень сильно...)&lt;/em&gt;, я наткнулся на статью под
заголовком &lt;strong&gt;"Горячее обновление кода не нужно?"&lt;/strong&gt; и с выводом, что мол и
правда особо не нужно, которая и подтолкнула меня поделиться своими
мыслями на эту тему.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Для начала давайте разберемся в том, что же вообще такое &lt;strong&gt;"горячая
замена кода"&lt;/strong&gt; &amp;nbsp;(&lt;em&gt;hot code replacement&lt;/em&gt;&amp;nbsp;или&amp;nbsp;&lt;em&gt;hot code swapping&lt;/em&gt;)? По
сути это возможность обновить (или откатить) код работающей программы
без её&amp;nbsp;перезапуска и, как следствие, периода недоступности, потери
состояния и повторной инициализации.&lt;/p&gt;
&lt;p&gt;В каких ситуациях это может быть полезно? Ответ следует из моего
импровизированного определения выше:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Когда простой &lt;em&gt;(downtime)&lt;/em&gt; неприемлем&lt;/li&gt;
&lt;li&gt;Когда есть какое-то состояние в памяти, которое не хочется терять&lt;/li&gt;
&lt;li&gt;Когда инициализация процесса трудоемка и занимает много времени, что
    чаще всего связано с восстановлением &amp;nbsp;состояния с диска или других
    внешних источников&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ко многим клиент-серверным приложениям, в том числе и веб-сайтам,
предъявляют очень высокие требования по отказоустойчивости, то есть
простои как таковые не допустимы даже в экстренных случаях, не говоря
уже о регулярном обновлении компонентов системы. Но чтобы обеспечить
высокой уровень доступности, измеряемый количеством девяток после
запятой в 99.(9)%, одной горячей замены кода не достаточно, нужно в
любом случае обеспечить доступность всех данных и ключевых серверных
компонентов системы даже в случае выхода из строя сервера, стойки,
маршрутизатора и даже целого датацентра. Обычно это делается "на уровень
выше" относительно самого кода приложения, путем добавления в систему
как минимум резервных (активных или пассивных) копий всех компонентов и
балансировщика нагрузки, способного обнаруживать неполадки и
соответствующим образом перенаправлять поток запросов. Балансировщик
нагрузки также нуждается в выделении под него как минимум двух серверов
с переключением на уровне DNS. Возвращаясь к изначальной теме: если уж
приложение способно пережить экстренный сбой любого компонента, то и без
всякой горячей замены спокойно переживет его плановый перезапуск в связи
с обновлением. Хотя на практике даже при резервировании всех компонентов
небольшая доля запросов может быть потеряна или обработана за
неприемлемо длинный срок в процессе перемаршрутизации их потока.&lt;/p&gt;
&lt;p&gt;Казалось бы клиент-серверные приложения чаще всего не имеют состояния, в
том плане, что все состояние находится в какой-то внешней сущности вроде
СУБД, так что инициализировать особо нечего и состояние потерять не
жалко. И на самом деле часто так и бывает, в том же мире
&lt;a href="/tag/php/"&gt;PHP&lt;/a&gt;&amp;nbsp;довольно популярна практика: положить новую версию кода
в соседнюю папочку, поменять document root в конфиге nginx, попросить
nginx перечитать свой конфиг - максимум сбросится кэш &lt;a href="/tag/apc/"&gt;APC&lt;/a&gt;
или &lt;a href="/tag/xcache/"&gt;xcache&lt;/a&gt;, что мало кого волнует, так как побочным
эффектом будет просто несколько ответов на запросы медленнее обычного.&lt;/p&gt;
&lt;p&gt;А как быть с самой СУБД? Например, &lt;a href="/tag/redis/"&gt;Redis&lt;/a&gt; при запуске
зачитывает в память все данные прежде чем начать принимать запросы, что
может занимать сколько-то минут. Другие СУБД, которые могут отвечать на
запросы и по данным на диске, стартуют относительно быстро, но провал в
их производительности до того, как разогреется встроенный в них кэш,
заметен невооруженным глазом. Очень похожа ситуация и с брокерами
сообщений вроде &lt;a href="/tag/rabbitmq/"&gt;RabbitMQ&lt;/a&gt;: если они и хранят данные на
диске, то скорее как резервную копию. А&amp;nbsp;&lt;a href="/tag/memcached/"&gt;memcached&lt;/a&gt;,
Redis без персистентности&amp;nbsp;и другие хранилища данных в памяти вовсе могут
разогреваться после перезапуска неопределенно долго, так как наполняются
по мере поступления запросов на запись.&lt;/p&gt;
&lt;p&gt;В языках программирования, основанных на байт-коде и виртуальных
машинах, зачастую есть возможность осуществлять &lt;em&gt;горячее обновление
кода&lt;/em&gt;&amp;nbsp;без перезапуска самой виртуальной машины. Когда говорят про
&lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt;,&amp;nbsp;очень часто упоминают эту возможность как одно
из ключевых преимуществ платформы, так как она хорошо сочетается с её
системой легковесных не зависящих от ОС процессов и встроенного в
виртуальную машину эффективного хранилища данных в памяти (ETS). В мире
&lt;a href="/tag/java/"&gt;Java&lt;/a&gt; это тоже возможно, но используется намного реже и
позиционируется скорее как инструмент для отладки. В момент подмены кода
в работающей виртуальной машине языка программирования с точки зрения ОС
ничего не меняется: все открытые соединения, файловые дескрипторы и
выделенная оперативная память остаются за ней, то есть она выступает
своего рода посредником между одновременно загруженными двумя версиями
кода, одна из которых будет выгружена из памяти, как только закончит
свою работу и передаст все "дела" новой. Хотя это очень поверхностное
описание, на практике всплывает масса нюансов вроде миграции состояний
процессов в обе стороны, совместимости протоколов взаимодействия и пр.
Плановый перезапуск в данной схеме нужен лишь для обновления самой
виртуальной машины, что обычно требуется намного реже, чем обновление
кода приложения.&lt;/p&gt;
&lt;p&gt;Возможность горячей замены кода на уровне виртуальной машины, казалось
бы, выглядит очень привлекательно для разработки обсуждавшихся выше
инфраструктурных компонентов, от балансировщика нагрузки до различных
хранилищ данных, что позволило бы не терять регулярно в
производительности при обновлениях из-за сброса кэша и переустановки
сетевых соединений. Но в реальности таких продуктов можно пересчитать по
пальцам, почему? Все просто: удобство требует жертв - избегая
периодических провалов в производительности из-за минимизации
перезапусков процессов при обновлении, приходится проигрывать в
производительности постоянно по сравнению с нативным кодом. Для
инфраструктуры обычно оказывается приоритетнее постоянная
производительность, что практически по-умолчанию означает разработку на
одном из диалектов &lt;a href="/tag/c/"&gt;C/C++&lt;/a&gt;, где подобная схема с подменой кода
на лету хоть и возможна, но сложна в реализации ввиду отсутствия
популярных стабильных решений.&lt;/p&gt;
&lt;p&gt;Подводя итог: &lt;strong&gt;горячая замена кода - скорее удобство, чем жизненная
необходимость&lt;/strong&gt;. Удобство при разработке, позволяющее не
инициализировать программу заново при каждом изменении в коде. Удобство
при эксплуатации, позволяющее не терять текущее состояние в памяти и
минимизировать время простоя каждого отдельного компонента системы.
Удобство при поиске сложно воспроизводимых багов, так как есть
возможность на ходу загрузить отладочную &lt;em&gt;(debug)&lt;/em&gt; сборку на проблемной
боевой машине. Но многие проекты прекрасно себе живут и без всего этого,
стоит оно того или нет - сугубо индивидуальное решение.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Mon, 29 Apr 2013 10:47:00 +0400</pubDate><guid>tag:www.insight-it.ru,2013-04-29:theory/2013/goryachaya-zamena-koda/</guid><category>hot code replacement</category><category>hot code swapping</category><category>горячая замена кода</category><category>горячее обновление кода</category><category>инициализация</category><category>отладка</category><category>перезапуск</category><category>разработка</category><category>эксплуатация</category></item><item><title>10 известных масштабируемых архитектурных шаблонов</title><link>https://www.insight-it.ru//theory/2011/10-izvestnykh-masshtabiruemykh-arkhitekturnykh-shablonov/</link><description>&lt;p&gt;&lt;strong&gt;"Масштабируемость"&lt;/strong&gt; - одна из самых&amp;nbsp;трудно достижимых&amp;nbsp;характеристик
при построении архитектуры современных программных продуктов. Что не
удивительно, ведь не существует единого рецепта масштабируемости,
который работал бы для всех возможных сценариев. Как же быть?&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Тем не менее, список наиболее распространенных рецептов или
"шаблонов", применяемых на практике, вполне реалистичен. Пост написан на
основе списка из &lt;a href="https://www.insight-it.ru/goto/e04c7ad/" rel="nofollow" target="_blank" title="http://srinathsview.blogspot.com/2011/10/list-of-known-scalable-architecture.html"&gt;статьи Srinath&lt;/a&gt;, помимо простого перевода названий я постараюсь своими словами изложить "на пальцах" в чем заключается каждый подход и с чем его едят. В оригинале можно найти ссылки на большие многостраничные работы на английском по практически каждому из шаблонов.&lt;/p&gt;
&lt;p&gt;Все нижеизложенные подходы основываются на трех основных принципах:
распределении задач, кэшировании промежуточных результатов и отложенном
(асинхронном) выполнении части работы. Пройдемся по порядку:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Балансировщики нагрузки + не имеющие ничего общего исполнители:&lt;/strong&gt;
    в данной модели существует некий входящий поток запросов или заявок,
    которые поступают через балансировщик(и) нагрузки на один из ряда
    равноправных узлов-исполнителей, которые каким-то образом генерируют
    результат запроса и отправляют обратно через балансировщик нагрузки
    или напрямую. В роли балансировщика нагрузки может использоваться
    DNS round-robin, различные программные или аппаратные решения, а
    также их комбинации (иерархии).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Балансировщики нагрузки + узлы без состояний + масштабируемое
    хранилище:&lt;/strong&gt; для большинства веб-приложений необходимо сохранять
    некое состояние, и тогда по сравнению с предыдущей моделью вводят в
    действие систему хранения данных, также приспособленную для
    горизонтального масштабирования, зачастую ценой отказа от
    реляционных и прочих комплексных операций, что сводит её интерфейс к
    простому взять-положить.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Принцип "равный-равному"
    (&lt;a href="https://www.insight-it.ru/goto/61244080/" rel="nofollow" target="_blank" title="http://en.wikipedia.org/wiki/Peer-to-peer"&gt;P2P&lt;/a&gt;):&lt;/strong&gt; заключается в
    самостоятельном распределении данных и/или задач между равнозначными
    узлами на основе заранее определенного алгоритма; причем клиент
    зачастую сам является узлом системы
    (&lt;a href="https://www.insight-it.ru/goto/bc2cc65/" rel="nofollow" target="_blank" title="http://ru.wikipedia.org/wiki/BitTorrent"&gt;BitTorrent&lt;/a&gt;), либо
    обращается к произвольному узлу, который становится "агентом" для
    поиска и делегации конкретного запроса исполнителю
    (&lt;a href="/tag/cassandra/"&gt;Cassandra&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Распределенные очереди:&lt;/strong&gt; эта модель основывается на выделении
    очередей, как отдельных сетевых сервисов; используются либо для
    передачи произвольных данных между компонентами системы, либо для
    создания очереди выполнения длительных операций (например
    конвертации фото/видео/аудио).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Парадигма подписка/публикация:&lt;/strong&gt; в системе определяется набор
    типов событий, одни компоненты системы создают эти события
    (публикуют сообщения), а другие - хотят узнавать когда произошло
    событие определенного типа (подписка на сообщения) и каким-то
    образом реагировать; реализуется обычно в виде отдельного сетевого
    сервиса, иногда совмещенного с распределенными очередями.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;"Молва" и прочие похожие на жизнь архитектуры:&lt;/strong&gt; основная идея
    заключается в том, что компонентам системы не нужно знать об общей
    структуре всей сети; узлу достаточно лишь знать о нескольких
    "соседях", с которыми он будет напрямую взаимодействовать, а
    распространение информации внутри системы возможно по принципу
    "молвы", то есть цепного распространения через "соседей";
    используется, например, для развертывания кода или упрощения
    конфигурации в больших кластерах.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MapReduce и потоки данных:&lt;/strong&gt; изначально MapReduce был предложен
    &lt;a href="/tag/google/"&gt;Google&lt;/a&gt; для обработки огромных массивов данных, с
    которыми они сталкиваются, алгоритм вкратце следующий:&lt;ul&gt;
&lt;li&gt;Каждый узел в системе считывает с дисков свою часть данных и
    образует из них пары "ключ-значение";&lt;/li&gt;
&lt;li&gt;Эти пары преобразуются в новые промежуточные пары
    "ключ-значение" по определенному алгоритму (стадия Map);&lt;/li&gt;
&lt;li&gt;Промежуточные пары сортируются и группируются по ключу и для
    каждого ключа вычисляется новое значение на основе группы
    промежуточных значений (стадия Reduce);&lt;/li&gt;
&lt;li&gt;Результат стадии Reduce обычно и является желаемой информацией,
    полученной из массива данных, и обычно сохраняется в
    распределенную файловую систему, либо каким-то образом
    импортируется в другое хранилище.
MapReduce по сути лишь распространенный частный случай обработки
потоков данных, который способен решить большую часть аналитических
задач. В общем случае процесс обработки потоков данных может иметь
любое количество этапов, преобразований и сортировок данных,
необходимых для получения результата.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Дерево ответственности:&lt;/strong&gt; заключается в разложение общей задачи на
    подзадачи и рекурсивной делегации их выполнения другим узлам
    системы, что в итоге и образует дерево; используется как часть
    некоторых других моделей.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Обработка входящих потоков:&lt;/strong&gt; скорее класс задач, чем шаблон, но
    тем не менее... есть некие внешние события (например сбои в
    клиентском ПО), обладающие какими-то характеристиками, информация о
    которых постоянно и непрерывно поступает в систему, которая должна в
    реальном времени обрабатывать события и получать на основе этих
    данных требуемую информацию. Реализуется посредством сети
    обрабатывающих узлов с общим хранилищем информации.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Масштабируемое хранилище:&lt;/strong&gt; их можно рассматривать как отдельный
    субъект, обладающий свойством масштабируемости; по типам можно
    выделить базы данных (зачастую не структурированных) и файловые
    системы.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Разделение ответственности запросов на чтение и на запись
    (&lt;a href="https://www.insight-it.ru/goto/ec5a4737/" rel="nofollow" target="_blank" title="http://martinfowler.com/bliki/CQRS.html"&gt;СQRS&lt;/a&gt;):&lt;/strong&gt; звучит страшно,
    на деле еще страшнее, если по-простому, то... модель основывается на
    обмене сообщениями между равноправными компонентами,&amp;nbsp;хранении,
    обработке данных в оперативной памяти, асинхронном масштабируемом
    хранилище данных для их сохранности и репликации компонент для
    надежности и отказоустойчивости.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Хотелось бы обсудить в комментариях какие из перечисленных моделей Вы
чаще всего используете на практике и почему? В чем видите перспективы,
преимущества и недостатки каждого? Может быть вспомните еще шаблоны,
которые не попали в список?&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Wed, 23 Nov 2011 23:42:00 +0400</pubDate><guid>tag:www.insight-it.ru,2011-11-23:theory/2011/10-izvestnykh-masshtabiruemykh-arkhitekturnykh-shablonov/</guid></item><item><title>6 способов порадовать инвестора</title><link>https://www.insight-it.ru//theory/2011/6-sposobov-poradovat-investora/</link><description>&lt;blockquote&gt;
&lt;p&gt;...или как не надо масштабировать интернет-проекты&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Недавно наткнулся на полу-поучительный и полу-юмористический материал по
масштабируемости интернет-проектов. Кому-то он может показаться, как и
мне, забавным, а кому-то - в таком формате может оказаться легче
воспринимать информацию. Надеюсь тебе тоже понравится, так что спешу
поделиться как переводом, так и оригинальным видео =)&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;На конференции&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/d4ae0945/" rel="nofollow" target="_blank" title="http://en.oreilly.com/mysql2011/"&gt;O'Reilly MySQL CE 2011&lt;/a&gt; выступил &lt;a href="https://www.insight-it.ru/goto/147f0d48/" rel="nofollow" target="_blank" title="http://it.toolbox.com/people/josh_berkus/"&gt;Josh Berkus&lt;/a&gt; c пламенной речью о том, как быть уважаемым и известным, при этом не уделяя ни капли
внимания масштабируемости. Его очень сильно удивляет, почему самыми
популярными, известными и инвестиционно-привлекательными
интернет-компаниями становятся именно те, чей интерфейс неработающего
состояния (в частности "киты" и "роботы" у &lt;a href="/tag/twitter/"&gt;Twitter&lt;/a&gt;),
известен больше, чем когда они работают. Так что Josh предлагает всем
придерживаться следующей стратегии:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Всегда следуй трендам:&lt;/strong&gt; используй только те технологии, которые
    навели больше всего шумихи в Интернете: NoSQL, "облака",
    MapReduce, Rails, RabbitMQ. Основным инструментом для выбора
    технологий должен быть Reddit (или Хабр, если адаптировать к
    российским реалиям). За что больше голосуют - то и используйте.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Не следите за текущей ситуацией:&lt;/strong&gt; математика и статистика -
    абсолютно бесполезны. Мониторинг использования ресурсов, нагрузочное
    тестирование, отслеживание трафика, тестирование производительности
    и тонкая настройка - да кому оно надо? Лучше доверять интуиции - с
    какими проблемами мы сталкивались на предыдущей работе, с такими же
    столкнемся и в этот раз&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ни о чем не беспокойтесь:&lt;/strong&gt; параллельное программирование не в
    моде, даже не смотря на то, что &lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt; позволяет
    приложениям работать на кластере из тысяч серверов. Крутые ребята не
    заботятся об оперативной памяти и управлении потоками. Нужно не
    париться и использовать однопоточные приложения с кучей блокировок,
    игнорируя области видимости и контексты памяти. Часто обновляющиеся
    таблицы из одной строки и мастер-очередь, в которую попадают все
    задания - лучшие паттерны из всех существующих.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Каждый запрос должен попадать напрямик в базу данных:&lt;/strong&gt;
    кэширование - твой смертный враг. Каждый запрос должен идти напрямую
    к СУБД, ни шага в сторону!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Масштабировать нужно невозможные вещи:&lt;/strong&gt; масштабирование простых и
    очевидных вещей - для слабаков! Это совершенно не круто заниматься
    масштабированием веб-серверов, кэшей (хотя ими пользоваться и так
    категорически запрещено) и серверов предложений.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Создавайте точки отказа:&lt;/strong&gt; вне зависимости от того, насколько
    большой ваш проект, в нем обязательно должно быть место, при отказе
    которого перестанет работать вся система. Лучшие кандидаты на эту
    роль: балансировщик нагрузки, очередь задач и мастер база данных.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Если следовать этим правилам, то ты станешь самым крутым и уважаемым
техническим специалистом в команде: ведь у тебя всегда будут истории,
где ты как настоящий герой, несмотря на все преграды, проработав все
выходные напролет решил-таки поставленную задачу! В противном же случае,
если твой код всегда работает и позволяет легко масштабироваться, то,
парадоксально, ты будешь просто старым-добрым Васей или Петей, который
просто работает и на которого никто не обращает внимания до тех пор,
пока он в один прекрасный день не уволится.&lt;/p&gt;
&lt;p&gt;Если все нормально с устным восприятием английского, очень рекомендую
посмотреть видео - с эмоциями и более лаконичным техническим английским
выглядит намного более впечатляюще:&lt;/p&gt;
&lt;div class="video-container"&gt;
&lt;iframe allowfullscreen="" frameborder="0" height="480" src="//www.youtube.com/embed/nPG4sK_glls?rel=0" width="853"&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Если вы еще не читаете Insight IT регулярно, настоятельно &lt;a href="/feed/"&gt;рекомендую подписаться на RSS&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sat, 30 Apr 2011 01:27:00 +0400</pubDate><guid>tag:www.insight-it.ru,2011-04-30:theory/2011/6-sposobov-poradovat-investora/</guid><category>Масштабируемость</category><category>вредные советы</category></item><item><title>Реальная ситуация в мире языков программирования</title><link>https://www.insight-it.ru//theory/2011/realnaya-situaciya-v-mire-yazykov-programmirovaniya/</link><description>&lt;p&gt;Наверняка у всех "гражданских" на слуху сплошные PHP да C++, но на них
все, естественно, не заканчивается. Популярность языков программирования
можно объяснить массой причин, начиная от "так исторически сложилось" и
заканчивая, скажем, условно низким порогом входа. Но далеко не всегда
лучшие технологии становятся мэйнстримом, по крайней мере в первые годы,
а то и десятилетия, их существования.&lt;/p&gt;
&lt;p&gt;Так как нас &lt;a href="https://www.insight-it.ru/misc/2011/nebolshojj-soc-opros/"&gt;здесь много разработчиков собралось&lt;/a&gt;, давайте составим рейтинг самых распространенных и перспективных языков программирования. Посмотрим на реальную ситуацию на сегодняшний день - какие языки сейчас широко распространены, какие заслуживают более детального внимания, а в каких мы видим перспективы.&lt;/p&gt;
&lt;p&gt;Для просмотра результатов и участия в опросе - прошу под кат. В
комментариях предлагаю устроить маленький холивар и обсудить сферы
применения каждого из языков на практике :)
&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Реальная ситуация в мире языков программирования" class="responsive-img" src="https://www.insight-it.ru/images/programming-language-poll-2011.jpg"/&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Mon, 21 Mar 2011 03:29:00 +0300</pubDate><guid>tag:www.insight-it.ru,2011-03-21:theory/2011/realnaya-situaciya-v-mire-yazykov-programmirovaniya/</guid></item><item><title>ООП или не ООП</title><link>https://www.insight-it.ru//theory/2010/oop-ili-ne-oop/</link><description>&lt;p&gt;Вчера мне на почту пришло письмо от коллеги с просьбой прокомментировать
статью, видимо его же перевода или авторства, о судьбе
объектно-ориентированного программирования в современном мире: &lt;a href="https://www.insight-it.ru/goto/b1bc1932/" rel="nofollow" target="_blank" title="http://blogerator.ru/page/oop_why-objects-have-failed"&gt;Почему объектно-ориентированное программирование провалилось?&lt;/a&gt;.
Собственно говоря, пишу ответ в своем блоге скорее чтобы несколько
растопить образовавшийся здесь лед, да и возможно снова затянет -
продолжу дальше активно писать в &lt;strong class="trebuchet"&gt;Insight IT&lt;/strong&gt;.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Для начала хочу вкратце пересказать саму статью. Написана она по мотивам
мнений различных экспертов в области разработки, в частности &lt;a href="https://www.insight-it.ru/goto/3e292f7c/" rel="nofollow" target="_blank" title="http://www.dreamsongs.com/ObjectsHaveFailedNarrative.html"&gt;Objects Have Failed&lt;/a&gt;
by Richard P. Gabriel, November 6, 2002 и holywar'а на конференции
&lt;a href="https://www.insight-it.ru/goto/f4d45ed5/" rel="nofollow" target="_blank" title="http://en.wikipedia.org/wiki/OOPSLA"&gt;OOPSLA&lt;/a&gt; с участием именитых
специалистов. Аргументы у обоих сторон "за и против" были довольно
странноватыми и по сути были подтверждениями и опровержениями различных
мифов об ООП, например о том, что с использованием парадигмы ООП
разработка идет быстрее/проще/понятнее/удобнее, что ОО языки
программирования не соответствуют требованиям вычислительных процессов
будущего и не адекватно отражают предметную область, что повторное
использование кода есть в любом языке программирование - как минимум в
виде библиотек. Сторонники ООП же в основном настаивают на
справедливости мифов и твердо отстаивают &lt;a href="https://www.insight-it.ru/theory/2008/tri-osnovnyx-komponenta-paradigmy-obektno-orientirovannogo-programmirovaniya/"&gt;три основных столпа их парадигмы&lt;/a&gt;.
На вышеупомянутой конференции по мнению аудитории вверх взяла сторона
"против ООП" из-за натиска сторонников языка Lisp и растерянности
сторонников ООП касательно своей же теории.&lt;/p&gt;
&lt;p&gt;Что же касается моего мнения касательно данного вопроса, то я не являюсь
ни приверженцем, ни противником объектно-ориентированного подхода к
программированию. В целом мой взгляд на ситуацию довольно прост: все
языки программирования - лишь инструмент для решения вполне
определенного круга задач. Выбор инструмента и способа работы с ним
определяется в основном лишь самой конкретной постановкой задачи,
требованиям к ней, а также имеющимися в наличии ресурсами - в первую
очередь человеческими и финансовыми. Не нужно смотреть на
программирование чисто с технической точки зрения - в первую очередь
программисты решают бизнес-задачи и проблемы людей, а каким именно
образом и с использованием каких инструментов - заказчиков и
потребителей программных продуктов волнует меньше всего. Для них намного
важнее итоговые показатели получившегося продукта: себестоимость
разработки и поддержки, сроки исполнения, соответствие требованиям, а
также в зависимости от типа продукта масштабируемость,
производительность, стабильность, безопасность.&lt;/p&gt;
&lt;p&gt;Да, в десятках и сотнях тысяч готовых классов в &lt;a href="/tag/net/"&gt;.NET&lt;/a&gt; или &lt;a href="/tag/java/"&gt;Java&lt;/a&gt; легко
запутаться, но они позволяют не разрабатывать реализуемые ими вещи
самим. Объектно-ориентированные языки программирования дают возможность
оперировать более высокоуровневыми понятиями и не тратить время на возню
с памятью напрямую (от утечек правда это не избавляет, но все же),
указателями, типовыми алгоритмами, реализацией протоколов и прочими
нормальными для низкоуровневых языков программирования вещами. Уделяя
меньше внимания деталям, можно создавать крупные проекты большими
мазками - возможно в ущерб качеству, но для многих ситуаций это
приемлемо.&lt;/p&gt;
&lt;p&gt;Когда речь идет о разработке крупной корпоративной системы с большим
количеством пользователей и разнородной информации, на первый план
выходят чаще всего масштабируемость и сроки реализации, а вовсе не
производительность и эффективность алгоритмов. В таких системах
разработка выглядит скорее как склейка требуемого продукта из различных
готовых компонентов, чем реализация собственных алгоритмов и оптимизация
производительности. Для подобных проектов чаще более уместен
объектно-ориентированный подход с использованием широкого спектра
готовых классов, библиотек и системных компонентов. Да, в данном случае
пострадает производительность, но купить несколько дополнительных
серверов дешевле, чем изобретать велосипед и писать с нуля реализацию
всех необходимых составных частей системы.&lt;/p&gt;
&lt;p&gt;Если же разрабатывается скажем какая-нибудь библиотека для расчета
инверсной кинематики, то скорее всего использование ОО-подхода в ней
будет излишним и после реализации всех алгоритмов на низкоуровневом
языке в функциональном/процедурном стиле будет достаточно создать
обертки для всех требуемых языков программирования.&lt;/p&gt;
&lt;p&gt;Плюс не стоит забывать и о том, какие люди участвуют в разработке:
бывают разработчики, которые фанатеют от ООП, всю жизнь занимаются
"сборкой" проектов из библиотек на Java или C#, являются ярыми
поклонниками
&lt;a href="https://www.insight-it.ru/goto/2d7a0d63/" rel="nofollow" target="_blank" title="http://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"&gt;TDD&lt;/a&gt;
и Agile-разработки, а бывают разработчики, которые предпочитают
Assembler/C/Fortran/Cobol/Lisp/Haskell/Erlang (нужное подчеркнуть),
любят реализовывать очень сложные алгоритмы, оптимизировать их,
добиваясь выиграша в несколько&amp;nbsp;миллисекунд&amp;nbsp;во времени или пару килобайт
в использованной оперативной памяти. Естественно это лишь крайние или
почти крайние случаи, большинство разработчиков скорее всего находятся
где-то посередине (к сожалению, у меня нет такой статистики),
предпочитая универсальные языки программирования, на которых можно
писать код как объектно-ориентированно, так и нет
(C++/Python/PHP/etc). Хочется порекомендовать руководителям не
заставлять имеющихся в наличии людей заниматься тем, что им не по душе,
просто так как Вам кто-то вчера рассказал, что "Ruby on Rails - это
круто" или так как во-о-он тот известный проект реализован с
использованием во-он тех технологий, языков программирования или
парадигм разработки. Используемые технологии и подходы к написанию кода,
должны соответствовать поставленным задачам, а команда должна быть
готова реализовать проект именно так, как это необходимо, при этом очень
большое значение имеет распределение ролей между разработчиками - чтобы
каждый занимался своим любимым делом.&lt;/p&gt;
&lt;p&gt;Коллеги, копайте ямы лопатами и забивайте гвозди молотками, а не
наоборот :)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Thu, 23 Sep 2010 13:07:00 +0400</pubDate><guid>tag:www.insight-it.ru,2010-09-23:theory/2010/oop-ili-ne-oop/</guid><category>ООП</category><category>парадигма</category><category>Программирование</category><category>языки программирования</category></item><item><title>Новый Google: интернет-гигант проливает свет на темы поиска в реальном времени, локального поиска, облачных вычислений и освобождения данных</title><link>https://www.insight-it.ru//theory/2009/novyjj-google-internet-gigant-prolivaet-svet-na-temy-poiska-v-realnom-vremeni-lokalnogo-poiska-oblachnykh-vychislenijj-i-osvobozhdeniya-dannykh/</link><description>&lt;p&gt;Когда речь заходит о продуктовых и бизнес стратегиях, &lt;a href="/tag/google/"&gt;Google&lt;/a&gt; обычно становится одной из самых скрытных и секретных компаний. Но не смотря на это, интернет-гигант некоторое время назад согласился дать серию интервью, в основном с участием высшего продуктового менеджмента, работающего в штабквартире в Mountain View, CA.&lt;/p&gt;
&lt;p&gt;В четырех отдельных интервью, сотрудники Google окунулись в самые
насущные темы, наиболее актуальные для компании в целом. Среди них
оказались различные вопросы, начиная с поиска в реальном времени,
локального поиска, и заканчивая облачными вычислениями, а также так
называемой возможностью освобождения данных. Под освобождением данных
имеется ввиду комплекс мер, направленных на предоставлении пользователям
возможности экспортировать их файлы и другую цифровую информацию из
продуктов Google (если они сами этого захотят, конечно же).&lt;/p&gt;
&lt;p&gt;Достаточно любопытный факт: менеджеры Google реально очень скучные. И им
правда нравится выглядеть именно так (по крайней мере пока их PR-коллеги
находятся рядом). Они не разговаривают о конкурентах. Они не делают
прогнозов о развитии индустрии. И они не говорят конкретно кто над чем
работает внутри Google. Просто-напросто они фокусируются на
совершенствовании своих продуктов, особенно в направлении удобства
использования пользователями, разве этого не достаточно?&lt;/p&gt;
&lt;p&gt;Возможно Jack Menzel, старший продукт-менеджер, лучше всего это выразил,
когда пошутил о "неблагодарности" работы над веб-поиском в Google: "Вы
демонстрируете [новую функцию поиска] людям, а они говорят: 'Да, вроде
она работает, ну и что?'" (Как быстро все мы забываем, каково это было
искать информацию в Интернете всего несколько лет назад.) Что ж, без
дальнейших предисловий, перейдем к основным моментам, связанным с
различными аспектами работы Google.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;em&gt;По мотивам &lt;a href="https://www.insight-it.ru/goto/c19fec69/" rel="nofollow" target="_blank" title="http://www.xconomy.com/national/2009/12/21/the-new-google-internet-giant-opens-up-about-real-time-and-local-search-cloud-computing-and-data-liberation/?single_page=true"&gt;статьи на xconomy.com&lt;/a&gt;,
автор&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/1e1524b7/" rel="nofollow" target="_blank" title="Posts by Gregory T. Huang"&gt;Gregory T. Huang&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="poisk-v-realnom-vremeni"&gt;Поиск в реальном времени&lt;/h2&gt;
&lt;p&gt;Google активно работает над максимально оперативным обновлением
результатов поиска по сети Интернет, в том числе и по социальным медиа
вроде &lt;a href="/tag/twitter/"&gt;Twitter&lt;/a&gt; или &lt;a href="/tag/facebook/"&gt;Facebook&lt;/a&gt;, практически так же быстро, как такая информация и публикуется.&lt;/p&gt;
&lt;p&gt;Menzel, бывший сотрудник Microsoft, который изучал компьютерное ремесло
в University of Washington, возглавляет продуктовую группу на данном
фронте. Он говорит, что компания Google работала над ускорением процесса
индексации и ранжирования на протяжении уже многих лет: когда-то данные
обновлялись раз в месяц, потом обновление стало ежедневным, чтобы
поспевать за блогами и новостными сайтами. В течении прошлого года
&lt;a href="/tag/twitter/"&gt;Twitter&lt;/a&gt; стал популярен и, как следствие, появилась
достаточно критичная потребность в обновлении информации за считанные
секунды или в крайнем случае минуты. "Мы двигались по направлению к
тому, чтобы становиться все быстрее и быстрее, на протяжении уже
достаточно длительного периода времени", говорит Menzel. "Данная
траектория развития была выбрана уже давно. Каждый шаг в данном
направлении приводит к все новым и новым проблемам и трудностям. Мы
верим, что именно получение доступа к свежей информации является одним
из ключевых факторов, являющихся залогом успеха Google." (В число
остальных факторов, относящихся к самому поиску, входят такие показатели
как релевантность, быстрота получения результата и полнота контента.)&lt;/p&gt;
&lt;p&gt;Menzel считает, что самой сложной задачей является не просто
быстродействие, а релевантность результатов потребностям пользователей
(возможно, кто-то привык называть этот показатель словом
&lt;em&gt;"пертинентность"&lt;/em&gt;). "Это очень, очень непросто собирать свежий
короткоживущий контент и ранжировать его рядом с, скажем, статьями из
New York Times или просто постами из блогов." Стоит заметить, что когда
контент появился буквально только что, обычно на него еще практически
никто не успел сослаться, а значит Google не может полноценно
использовать PageRank, их классическую технологию.&lt;/p&gt;
&lt;p&gt;Вместо этого, они "тяжело опираются на все то, что они выявили в течении
последних 10 лет", говорит Menzel. Это включает в себя, например,
способы отбрасывания контента, который скорее всего является
иррелевантным или спамом, в более общем случае. Помимо этого он
упоминал "совершенно новые сигналы", скажем "новые языковые модели",
которые позволяют понять какие обновления являются релевантными, а
какие - просто горстка никому не нужных данных от какого-нибудь
ученого-океанографа, или методы определения насколько тот или иной
создатель контента авторитетен в своей области.&lt;/p&gt;
&lt;p&gt;Говоря о будущем, Menzel повторил то, что казалось бы на сегодняшний
день говорят все о поиске: еще рано. "На самом деле мы лишь начали
работать над данной задачей и у нас все еще очень долгий путь впереди".
Он надеется, что в течении 5 лет Google сделает поиск намного более
персонализированным, чем он есть сегодня. Например, Google будет знать
что ты увлекаешься футболом, но привык называть его не "soccer", а
"football", то есть помимо прочего поисковая система должна понимать кем
является каждый ее конкретный пользователь, как и с кем он связан, кем
он является в реальной жизни, где находится, и, тем самым, помогать ему
организовывать всю информацию вокруг него.&lt;/p&gt;
&lt;p&gt;"Поиск - все еще очень далекая от решения проблема," - говорит Menzel.
"Существует еще масса вещей, которые очень не просто найти в
Интернете."&lt;/p&gt;
&lt;h2 id="lokalnyi-poisk"&gt;Локальный поиск&lt;/h2&gt;
&lt;p&gt;В эту категорию попадают все виды поисковых запросов, так или иначе
связанных с географической информацией, скажем "отели в Гонг-Конге" или
"рестораны в Сиэттле", а также запросы с мобильных устройств на поиск
близлежащих мест, заведений, достопримечательностей и прочих объектов.&lt;/p&gt;
&lt;p&gt;Carter Maslan, директор продуктового менеджмента в области локального
поиска в Google, называет эту область "организацией мировой информации
географически" , или созданием быстрого и простого гида по
"гео-Интернету". Самым сложным моментом в данном вопросе по его мнению
является&amp;nbsp;отображение&amp;nbsp;всех этих различных способов выражения
пользовательского запроса на очень большой массив локализированных
данных, а также возвращение правильного ответа на полученный запрос в
минимальные сроки.&lt;/p&gt;
&lt;p&gt;Maslan, еще один экс-сотрудник Microsoft, говорит, что Google
обрабатывает большое количество поисковых запросов для анализа того, как
люди предпочитают искать локальную информацию, и как с географической
точки зрения создаются ссылки на различные вещи. По его мнению конечная
цель заключается в том, чтобы сделать поиск и обнаружение мест рядом с
собой практически не требующим от пользователя каких-либо усилий.
Наиболее знакомые сценарии, это помощь в ориентировании в новом
окружении, скажем после приземления в аэропорту, или поиск баров во
время ночной прогулки по пригородам Нью-Йорка.&lt;/p&gt;
&lt;p&gt;Складывается впечатление, что все это должно плотно вписываться в более
широкую&amp;nbsp;стратегию&amp;nbsp;Google, связанную с мобильными технологиями. "Ваш
телефон знает многое" - говорит Maslan. "Он знает где Вы сейчас
находитесь, он может определить в каком направлении Вы направляетесь.
Все не ограничивается только текстом в окошке для поискового запроса. Мы
хотим вывести мобильную информацию на передний план." Существующим на
данный момент примером является &lt;a href="https://www.insight-it.ru/goto/62aa81c9/" rel="nofollow" target="_blank" title="http://www.google.com/mobile/goggles/"&gt;Google Goggles&lt;/a&gt;, приложение, которое
позволяет сфотографировать логотип, достопримечательность или какое-то
место и мгновенно получить информацию о нем.&lt;/p&gt;
&lt;p&gt;Maslan считает, что основной отличительной чертой Google в области
локального поиска является "открытость для всех источников", что
достаточно сложно с технической точки зрения. Это включает в себя
пребывание в состоянии "активной глобальности", а не просто в
индексировании информации о ключевых станциях метро. "Масштаб, с которым
Google работает с картографическими и гео-кодированными данными, в
совокупности с пониманием принципов работы Интернета является ключем для
успешной работы в данной области".&lt;/p&gt;
&lt;p&gt;Возможно в скором будущем мы увидим вещи вроде карт и списков компаний
или мест от Google в еще большем количестве мест и языков по всему миру,
с еще более точной информацией, чутко реагирующей на локальные события
вроде открытия, закрытия или перемещения предприятий и организаций. "Мы
четко понимаем, какие именно вещи у нас получаются лучше всего" -
говорит Maslan. "У нас есть небольшие команды из людей, фанатично
настроенных на реализацию их наиболее правильным образом".&lt;/p&gt;
&lt;h2 id="oblachnye-vychisleniia"&gt;Облачные вычисления&lt;/h2&gt;
&lt;p&gt;Наверняка все наслышаны о знаменитых вычислениях "в облаках", то есть с
использованием программного обеспечения, работающем на удаленных
серверах, часто нескольких одновременно и в виртуализированном&amp;nbsp;окружении, а не прямо на персональном компьютере. В
этом ключе Google наиболее интересует выполнение повседневных задач,
таких как работа с электронной почтой, составление расписаний и
управление документами. На самом деле это всего лишь часть более широкой
стратегии Google по облачным вычисления - именно она создает видимость
того, что потребители, предприятия и организации арендуют вычислительный
мощности и хранилища данных через Интернет, так как это дешевле и более
эффективно для многих приложений.&lt;/p&gt;
&lt;p&gt;Ken Norton, старший продукт-менеджер Google (а также выпускник Boston
University и бывший предприниматель), поведал о Google Apps и стратегии
компании в области облачных вычислений. Команда Norton'а работает
конкретно над Google Calendar, но Google Apps также включают в себя и
другие продукты, такие как Gmail, Google Talk, Google Docs и Google
Sites. &amp;ldquo;Сеть выигрывает на том, как приложения будут потребляться&amp;rdquo; - он
сказал.&lt;/p&gt;
&lt;p&gt;Ключевым преимуществом Google на данном фронте является масштаб и
инфраструктура. "У нас есть настолько много серверов и датацентров по
всему миру, что мы можем содержать их достаточно дешево и эффективно" -
говорит Norton. Это преимущество оказывает влияние и на индивидуальные
устройства, так как оно "открывает новые возможности" для потребителей,
возможность использовать веб-приложения с любого типа устройств, будь то
смартфон, нетбук или обычный полноразмерный ноутбук.&lt;/p&gt;
&lt;p&gt;Работа Google в области облачных вычислений сфокусирована на двух
уровнях: на первом располагаются готовые программные продукты вроде
Google Apps, направленные на прямое потребление конечными пользователями
(как индивидуальными, так и корпоративными); второй же уровень занимает
App Engine, "облачная" платформа, предназначенная для использования
разработчиками программного обеспечения для эффективного построения их
собственных веб-продуктов.&lt;/p&gt;
&lt;p&gt;Относительно прогнозов на следующий год на фронте облачных вычислений,
Norton сказал, что "мы постоянно совершенствуемся". В 2009 году было
запущенно более 100 основных новых функциональных возможностей в Google
Apps - таких вещей, как видео чат в GTalk или Gmail offline. Он считает,
что Google "продолжит делать акцент на коммуникационных предложениях".
Помимо развития Gmail и Calendar, это включает в себя доведение до ума
Google Docs и придание более завершенного вида набору их возможностей.
Norton говорит, что Google также ищет возможности по расширению своих
предложений в области коллаборации, в том числе в виде продуктов для
крупного бизнеса, совместимыми с различными системами обеспечения
безопасности для аутентификации.&lt;/p&gt;
&lt;p&gt;Подведем черту: все выглядит как-будто Google совершает переход от
фокусирования на бесплатных потребительских продуктах, работающих в
"облаках", к более активной работе над платными облачными сервисами для
бизнес-пользователей.&lt;/p&gt;
&lt;h2 id="osvobozhdenie-dannykh"&gt;Освобождение данных&lt;/h2&gt;
&lt;p&gt;Последнее время в компании все больше внимания уделяется предоставлению
пользователям легко экспортировать их данные из продуктов Google, таких
как&amp;nbsp;Blogger, Google Maps, Google Docs, Chrome и App Engine
(пользовательские данные разработчиков). На первый взгляд это может
показаться очередным капризом PR-менеджеров, но на самом деле за этим
фактом стоит более глубокая и интересная инновационная стратегия.&lt;/p&gt;
&lt;p&gt;Brian Fitzpatrick, ветеран opensource разработок, возглавляет двухлетний
проект от офисов Google в Чикаго. Основная идея заключается в оказании
помощи пользователям, если они хотят получить свои файлы и другие данные
из облака Google, чтобы у них была возможность перейти на какую-то
другую систему, если они захотят. "Большинство людей не думает о
возможности экспорта данных до тех пор пока не станет слишком поздно" -
говорит Fitzpatrick. "Мы надеемся, что если вы прекратите использование
одного нашего продукта сегодня, то у вас будет возможность попробовать
другой продукт завтра."&lt;/p&gt;
&lt;p&gt;Помимо "создания правильных возможностей для пользователей" существует и
другая мотивация. "Мы, как компания, старательно работаем над такими
вещами, как поиск. Если пользователи становятся привязанным к вашим
продуктам, то вы становитесь более самодовольными, расслабленными. Если
же уйти достаточно просто, то вы будете серьезно мотивированны делать
свои продукты как можно лучше, чтобы избежать ухода пользователей любой
ценой."&lt;/p&gt;
&lt;p&gt;Что ж, теперь у нас есть эта возможность. Google считает, что эта
открытость с точки зрения пользовательских данных, заставит компанию
работать более старательно для удержания пользовательской
базы.&amp;nbsp;Fitzpatrick не знает других компаний, которые бы открыто заявляли
об инициативе создания подобных возможностей для своих пользователей.&lt;/p&gt;
&lt;p&gt;По его мнению наибольшая трудность лежит не собственно в разработке
такого функционала, а в повышение&amp;nbsp;осведомленности&amp;nbsp;пользователей о
наличии возможности экспортировать свои данные из облака. "Достаточно
сложно заставить пользователей думать, что это на самом деле важно". Но
в целом этот подход достаточно достаточно хорошо вписывается в понятие о
том, как потребители и корпоративные пользователи заботятся о всех своих
данных, когда все большая и большая их част мигрирует "в облака" и как
Google хочет быть ответственным за организацию мировых данным, шаг за
шагом, на протяжении всего пути.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Tue, 29 Dec 2009 18:17:00 +0300</pubDate><guid>tag:www.insight-it.ru,2009-12-29:theory/2009/novyjj-google-internet-gigant-prolivaet-svet-na-temy-poiska-v-realnom-vremeni-lokalnogo-poiska-oblachnykh-vychislenijj-i-osvobozhdeniya-dannykh/</guid><category>cloud computing</category><category>data liberation</category><category>Google</category><category>local search</category><category>online</category><category>realtime search</category><category>интервью</category><category>интернет</category><category>облачные вычисления</category><category>освобождение данных</category><category>поиск</category><category>Сеть</category></item><item><title>Масштабируемые веб-архитектуры</title><link>https://www.insight-it.ru//theory/2008/masshtabiruemye-veb-arkhitektury/</link><description>&lt;p&gt;&lt;img alt="Масштабируемость" class="right" src="https://www.insight-it.ru/images/display.png"/&gt;
Уже немало слов было сказано по этой теме как в моем блоге, так и за
его пределами. Мне кажется настал подходящий момент для того, чтобы
перейти от частного к общему и попытаться взглянуть на данную тему
отдельно от какой-либо успешной ее реализации.&lt;/p&gt;
&lt;p&gt;Приступим?
&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Для начала имеет смысл определиться с тем, о чем мы вообще будем
говорить. В данном контексте перед веб-приложением ставятся три основные
цели:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;масштабируемость&lt;/strong&gt; - способность своевременно реагировать на
    непрерывный рост нагрузки и непредвиденные наплывы пользователей;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;доступность&lt;/strong&gt; - предоставление доступа к приложению даже в случае
    чрезвычайных обстоятельств;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;производительность&lt;/strong&gt; - даже малейшая задержка в загрузке страницы
    может оставить негативное впечатление у пользователя.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Основной темой разговора будет, как не трудно догадаться,
масштабируемость, но и остальные цели не думаю, что останутся в стороне.
Сразу хочется сказать пару слов про доступность, чтобы не возвращаться к
этому позднее, подразумевая как "само собой разумеется": любой сайт так
или иначе стремится к тому, чтобы функционировать максимально стабильно,
то есть быть доступным абсолютно всем своим потенциальным посетителям в
абсолютно каждый момент времени, но порой случаются всякие
непредвиденные ситуации, которые могут стать причиной временной
недоступности. Для минимизации потенциального ущерба доступности
приложения необходимо избегать наличия компонентов в системе,
потенциальный сбой в которых привел бы к недоступности какой-либо
функциональности или данных (или хотябы сайта в целом). Таким образом
каждый сервер или любой другой компонент системы должен иметь хотябы
одного дублера (не важно в каком режиме они будут работать: параллельно
или один "подстраховывает" другой, находясь при этом в пассивном
режиме), а данные должны быть реплицированы как минимум в двух
экземплярах (причем желательно не на уровне RAID, а на разных физических
машинах). Хранение нескольких резервных копий данных где-то отдельно от
основной системы (например на специальных сервисах или на отдельном
кластере) также поможет избежать многих проблем, если что-то пойдет не
так. Не стоит забывать и о финансовой стороне вопроса: подстраховка на
случай сбоев требует дополнительных существенных вложений в
оборудование, которые имеет смысл стараться минимизировать.&lt;/p&gt;
&lt;p&gt;Масштабируемость принято разделять на два направления:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Вертикальная масштабируемость&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Увеличение производительности каждого компонента системы c целью
повышения общей производительности.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Горизонтальная масштабируемость&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Разбиение системы на более мелкие структурные компоненты и
разнесение их по отдельным физическим машинам (или их группам) и/или
увеличение количества серверов параллельно выполняющих одну и ту же
функцию.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Так или иначе, при разработке стратегии роста системы приходится искать
компромис между ценой, временем разработки, итоговой производительность,
стабильностью и еще массой других критериев. С финансовой точки зрения
вертикальная масштабируемость является далеко не самым привлекательным
решением, ведь цены на сервера с большим количеством процессоров всегда
растут практически экспоненциально относительно количества процессоров.
Именно по-этому наиболее интересен горизонтальный подход, так как именно
он используется в большинстве случаев. Но и вертикальная
масштабируемость порой имеет право на существование, особенно в
ситуациях, когда основную роль играет время и скорость решения задачи, а
не финансовый вопрос: ведь купить БОЛЬШОЙ сервер существенно быстрее,
чем практически заново разрабатывать приложения, адаптируя его к работе
на большом количестве параллельно работающих серверов.&lt;/p&gt;
&lt;p&gt;Закончив с общими словами давайте перейдем к обзору потенциальных
проблем и вариантов их решений при горизонтальном масштабировании.
Просьба особо не критиковать - на абсолютную правильность и
достоверность не претендую, просто "мысли вслух", да и даже упомянуть
все моменты данной темы у меня определенно не получится.&lt;/p&gt;
&lt;h3 id="servery-prilozhenii"&gt;Серверы приложений&lt;/h3&gt;
&lt;p&gt;В процессе масштабирования самих приложений редко возникают проблемы,
если при разработке всегда иметь ввиду, что каждый экземпляр приложения
должен быть непосредственно никак не связан со своими "коллегами" и
должен иметь возможность обработать абсолютно любой запрос пользователя
вне зависимости от того где обрабатывались предыдущие запросы данного
пользователя и что конкретно он хочет от приложения в целом в текущий
момень.&lt;/p&gt;
&lt;p&gt;Далее, обеспечив независимость каждого отдельного запущенного
приложения, можно обрабатывать все большее и большее количество запросов
в единицу времени просто увеличивая количество параллельно
функционирующих серверов приложений, участвующих в системе. Все
достаточно просто (относительно).&lt;/p&gt;
&lt;h3 id="balansirovka-nagruzki"&gt;Балансировка нагрузки&lt;/h3&gt;
&lt;p&gt;Следущая задача - равномерно распределить запросы между доступными
серверами приложений. Существует масса подходов к решению этой задачи и
еще больше продуктов, предлагающих их конкретную реализацию.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Оборудование&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Сетевое оборудование, позволяющее распределять нагрузку между
несколькими серверами, обычно стоит достаточно внушительные суммы,
но среди прочих вариантов обычно именно этот подход предлагает
наивысшую производительность и стабильность (в основном благодаря
качеству, плюс такое оборудование иногда поставляется парами,
работающими по принципу
&lt;a href="https://www.insight-it.ru/goto/a40f2b94/" rel="nofollow" target="_blank" title="http://en.wikipedia.org/wiki/Heartbeat_%28program%29"&gt;HeartBeat&lt;/a&gt;).
В этой индустрии достаточно много серьезных брендов, предлагающих
свои решения - есть из чего выбрать: &lt;em&gt;Cisco&lt;/em&gt;, &lt;em&gt;Foundry&lt;/em&gt;, &lt;em&gt;NetScalar&lt;/em&gt;
и многие другие.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Программное обеспечение&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;В этой области еще большее разнообразие возможных вариантов.
Получить программно производительность сопоставимую с аппаратными
решениями не так-то просто, да и HeartBeat придется обеспечивать
программно, но зато оборудование для функционирования такого решения
представляет собой обычный сервер (возможно не один). Таких
программных продуктов достаточно много, обычно они представляют
собой просто HTTP-серверы, перенаправляющие запросы своим коллегам
на других серверах вместо отправки напрямую на обработку
интерпретатору языка программирования. Для примера можно упомянуть,
скажем, &lt;a href="/tag/nginx/"&gt;nginx&lt;/a&gt; с &lt;code&gt;mod_proxy&lt;/code&gt;. Помимо этого имеют
место более экзотические варианты, основанные на DNS, то есть в
процессе определения клиентом IP-адреса сервера с необходимым ему
интернет-ресурсов адрес выдается с учетом нагрузки на доступные
сервера, а также некоторых географических соображений.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Каждый вариант имеет свой ассортимент положительных и отрицательных
сторон, именно по-этому однозначного решения этой задачи не существует -
каждый вариант хорош в своей конкретной ситуации. Не стоит забывать, что
никто не ограничивает Вас в использовании лишь одного из них, при
необходимости может запросто быть реализована и практически произвольная
комбинация из них.&lt;/p&gt;
&lt;h3 id="resursoemkie-vychisleniia"&gt;Ресурсоемкие вычисления&lt;/h3&gt;
&lt;p&gt;Во многих приложениях используются какие-либо сложные механизмы, это
может быть конвертирование видео, изображений, звука, или просто
выполнение каких-либо ресурсоемких вычислений. Такие задачи требует
отдельного внимания если мы говорим о Сети, так как пользователь
интернет-ресурса врядли будет счастлив наблюдать за загружающейся
несколько минут страницей в ожидании лишь для того, чтобы увидеть
сообщение вроде: "Операция завершена успешно!".&lt;/p&gt;
&lt;p&gt;Для избежания подобных ситуаций стоит постараться минимизировать
выполнение ресурсоемких операций синхронно с генерацией интернет
страниц. Если какая-то конкретная операция не влияет на новую страницу,
отправляемую пользователю, то можно просто организовать &lt;em&gt;очередь&lt;/em&gt;
заданий, которые необходимо выполнить. В таком случае в момент когда
пользователь совершил все действия, необходимые для начала операции,
сервер приложений просто добавляет новое задание в очередь и сразу
начинает генерировать следущую страницу, не дожидаясь результатов. Если
задача на самом деле очень трудоемкая, то такая очередь и обработчики
заданий могут располагаться на отдельном сервере или кластере.&lt;/p&gt;
&lt;p&gt;Если результат выполнения операции задействован в следующей странице,
отправляемой пользователю, то при асинхронном ее выполнении придется
несколько схитрить и как-либо отвлечь пользователя на время ее
выполнения. Например, если речь идет о конвертировании видео в &lt;strong&gt;flv&lt;/strong&gt;,
то например можно быстро сгенерировать скриншот с первым кадром в
процессе составления страницы и подставить его на место видео, а
возможность просмотра динамически добавить на страницу уже после, когда
конвертирование будет завершено.&lt;/p&gt;
&lt;p&gt;Еще один неплохой метод обработки таких ситуаций заключается просто в
том, чтобы попросить пользователя "зайти попозже". Например, если сервис
генерирует скриншоты веб-сайтов из различных браузеров с целью
продемонстрировать правильность их отображения владельцам или просто
интересующимся, то генерация страницы с ними может занимать даже не
секунды, а минуты. Наиболее удобным для пользователя в такой ситуации
будет предложение посетить страницу по указанному адресу через
столько-то минут, а не ждать у моря погоды неопределенный срок.&lt;/p&gt;
&lt;h3 id="sessii"&gt;Сессии&lt;/h3&gt;
&lt;p&gt;Практически все веб-приложения каким-либо образом взаимодействуют со
своими посетителями и в подавляющем большинстве случаев в них
присутствует необходимость отслеживать перемещения пользователей по
страницам сайта. Для решения этой задачи обычно используется механизм
&lt;em&gt;сессий&lt;/em&gt;, который заключается в присвоении каждому посетителю
уникального идентификационного номера, который ему передается для
хранения в cookies или, в случае их отсутствия, для постоянного
"таскания" за собой через GET. Получив от пользователя некий ID вместе с
очередным HTTP-запросом сервер может посмотреть в список уже выданных
номеров и однозначно определить кто его отправил. С каждым ID может
ассоциироваться некий набор данных, который веб-приложение может
использовать по своему усмотрению, эти данные обычно по-умолчанию
хранятся в файле во временной директории на сервере.&lt;/p&gt;
&lt;p&gt;Казалось бы все просто, но... но запросы посетителей одного и того же
сайта могут обрабатывать сразу несколько серверов, как же тогда
определить не был ли выдан полученный ID на другом сервере и где вообще
хранятся его данные?&lt;/p&gt;
&lt;p&gt;Наиболее распространенными решениями является централизация или
децентрализация сессионных данных. Несколько абсурдная фраза, но,
надеюсь, пара примеров сможет прояснить ситуацию:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Централизованное хранение сессий&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Идея проста: создать для всех серверов общую "копилку", куда они
смогут складывать выданные ими сессии и узнавать о сессиях
посетителей других серверов. В роли такой "копилки" теоретически
может выступать и просто примонтированная по сети файловая система,
но по некоторым причинам более перспективным выглядит использование
какой-либо СУБД, так как это избавляет от массы проблем, связанных с
хранением сессионных данных в файлах. Но в варианте с общей базой
данных не стоит забывать, что нагрузка на него будет неуклонно расти
с ростом количества посетителей, а также стоит заранее предусмотреть
варианты выхода из проблематичных ситуаций, связанных с
потенциальными сбоями в работе сервера с этой СУБД.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Децентрализованное хранение сессий&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Наглядный пример - хранение сессий в &lt;a href="/tag/memcached/"&gt;memcached&lt;/a&gt;,
изначально расчитанная на распределенное хранение данных в
оперативной памяти система позволит получать всем серверам быстрый
доступ к любым сессионным данным, но при этом (в отличии от
предыдущего способа) какой-либо единый центр их хранения будет
отсутствовать. Это позволит избежать узких мест с точек зрения
производительности и стабильности в периоды повышенных нагрузок.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;В качестве альтернативы сессиям иногда используют похожие по
предназначению механизмы, построенные на cookies, то есть все
необходимые приложению данные о пользователе хранятся на клиентской
стороне (вероятно в зашифрованном виде) и запрашиваются по мере
необходимости. Но помимо очевидных преимуществ, связанных с отсутствием
необходимости хранить лишние данные на сервере, возникает ряд проблем с
безопасностью. Данные, хранимые на стороне клиента даже в зашифрованном
виде, представляют собой потенциальную угрозу для функционирования
многих приложений, так как любой желающий может попытаться
модифицировать их в своих интересах или с целью навредить приложению.
Такой подход хорош только если есть уверенность, что абсолютно любые
манипуляции с хранимые у пользователей данными безопасны. Но можно ли
быть уверенными на 100%?&lt;/p&gt;
&lt;h3 id="staticheskii-kontent"&gt;Статический контент&lt;/h3&gt;
&lt;p&gt;Пока объемы статических данных невелики - никто не мешает хранить их в
локальной файловой системе и предоставлять доступ к ним просто через
отдельный легковесный веб-сервер вроде &lt;a href="/tag/lighttpd/"&gt;lighttpd&lt;/a&gt; (я
подразумеваю в основном разные формы медиа-данных), но рано или поздно
лимит сервера по дисковому пространству или файловой системы по
количеству файлов в одной директории будет достигнут, и придется думать
о перераспределении контента. Временным решением может стать
распределение данных по их типу на разные сервера, или, возможно,
использование иерархической структуры каталогов.&lt;/p&gt;
&lt;p&gt;Если статический контент играет одну из основных ролей в работе
приложения, то стоит задуматься о применении распределенной файловой
системы для его хранения. Это, пожалуй, один из немногих способов
горизонтально масштабировать объем дискового пространства путем
добавления дополнительных серверов без каких-либо кардинальных изменений
в работе самого приложения. На какой именно кластерной файловой системе
остановить свой выбор ничего сейчас советовать не хочу, я уже
опубликовал далеко не один обзор конкретных реализаций - попробуйте
прочитать их все и сравнить, если этого мало - вся остальная Сеть в
Вашем распоряжении.&lt;/p&gt;
&lt;p&gt;Возможно такой вариант по каким-либо причинам будет нереализуем, тогда
придется "изобретать велосипед" для реализации на уровне приложения
принципов схожих с сегментированием данных в отношении СУБД, о которых я
еще упомяну далее. Этот вариант также вполне эффективен, но требует
модификации логики приложения, а значит и выполнение дополнительной
работы разработчиками.&lt;/p&gt;
&lt;p&gt;Альтернативой этим подходам выступает использование так называемых
&lt;strong&gt;Content Delievery Network&lt;/strong&gt; - внешних сервисов, обеспечивающих
доступность Вашего контента пользователям за определенное материальное
вознаграждение сервису. Преимущество очевидно - нет необходимости
организовывать собственную инфраструктуру для решения этой задачи, но
зато появляется другая дополнительная статья расходов. Список таких
сервисов приводить не буду, если кому-нибудь понадобится - найти будет
не трудно.&lt;/p&gt;
&lt;h3 id="keshirovanie"&gt;Кэширование&lt;/h3&gt;
&lt;p&gt;Кэширование имеет смысл проводить на всех этапах обработки данных, но в
разных типах приложений наиболее эффективными являются лишь некоторые
методы кэширования.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;СУБД&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Практически все современные СУБД предоставляют встроенные механизмы
для кэширования результатов определенных запросов. Этот метод
достаточно эффективен, если Ваша система регулярно делает одни и те
же выборки данных, но также имеет ряд недостатков, основными из
которых является инвалидация кэша всей таблицы при малейшем ее
изменении, а также локальное расположение кэша, что неэффективно при
наличии нескольких серверов в системе хранения данных.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Приложение&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;На уровне приложений обычно производится кэширование объектов любого
языка программирования. Этот метод позволяет вовсе избежать
существенной части запросов к СУБД, сильно снижая нагрузку на нее.
Как и сами приложения такой кэш должен быть независим от конкретного
запроса и сервера, на котором он выполняется, то есть быть доступным
всем серверам приложений одновременно, а еще лучше - быть
распределенным по нескольким машинам для более эффективной
утилизации оперативной памяти. Лидером в этом аспекте кэширования по
праву можно назвать &lt;a href="/tag/memcached/"&gt;memcached&lt;/a&gt;, о котором я в свое
время уже успел &lt;a href="https://www.insight-it.ru/storage/2008/obzor-memcached/"&gt;подробно рассказать&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;HTTP-сервер&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Многие веб-серверы имеют модули для кэширования как статического
контента, так и результатов работы скриптов. Если страница редко
обновляется, то использование этого метода позволяет без каких-либо
видимых для пользователя изменений избегать генерации страницы в
ответ на достаточно большую часть запросов.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Reverse proxy&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Поставив между пользователем и веб-сервером прозрачный
прокси-сервер, можно выдавать пользователю данные из кэша прокси
(который может быть как в оперативной памяти, так и дисковым), не
доводя запросы даже до HTTP-серверов. В большинстве случаев этот
подход актуален только для статического контента, в основном разных
форм медиа-данных: изображений, видео и тому подобного. Это
позволяет веб-серверам сосредоточиться только на работе с самими
страницами.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Кэширование по своей сути практически не требует дополнительных затрат
на оборудование, особенно если внимательно наблюдать за использованием
оперативной памяти остальными компонентами серверами и утилизировать все
доступные "излишки" под наиболее подходящие конкретному приложению формы
кэша.&lt;/p&gt;
&lt;p&gt;Инвалидация кэша в некоторых случаях может стать нетривиальной задачей,
но так или иначе универсального решения всех возможных проблем с ней
связанных написать не представляется возможным (по крайней мере лично
мне), так что оставим этот вопрос до лучших времен. В общем случае
решение этой задачи ложится на само веб-приложение, которое обычно
реализует некий механизм инвалидации средствами удаления объекта кэша
через определенный &lt;em&gt;период времени&lt;/em&gt; после его создания или последнего
использования, либо "вручную" при возникновении определенных &lt;em&gt;событий&lt;/em&gt;
со стороны пользователя или других компонентов системы.&lt;/p&gt;
&lt;h3 id="bazy-dannykh"&gt;Базы данных&lt;/h3&gt;
&lt;p&gt;На закуску я оставил самое интересное, ведь этот неотъемлемый компонент
любого веб-приложения вызывает больше проблем при росте нагрузок, чем
все остальные вместе взятые. Порой даже может показаться, что стоит
вообще отказаться от горизонтального масштабирования системы хранения
данных в пользу вертикального - просто купить тот самый БОЛЬШОЙ сервер
за шести- или семизначную сумму не-рублей и не забивать себе голову
лишними проблемами.&lt;/p&gt;
&lt;p&gt;Но для многих проектов такое кардинальное решение (и то, по большому
счету, временное) не подходит, а значит перед ними осталась лишь одна
дорога - горизонтальное масштабирование. О ней и поговорим.&lt;/p&gt;
&lt;p&gt;Путь практически любого веб проекта с точки зрения баз данных начинался
с одного простого сервера, на котором работал весь проект целиком. Затем
в один прекрасный момент наступает необходимость вынести СУБД на
отдельный сервер, но и он со временем начинает не справляться с
нагрузкой. Подробно останавливаться на этих двух этапах смысла особого
нет - все относительно тривиально.&lt;/p&gt;
&lt;p&gt;Следующим шагом обычно бывает &lt;strong&gt;master-slave&lt;/strong&gt; с асинхронной репликацией
данных, как работает эта схема уже неоднократно упоминалось в блоге, но,
пожалуй, повторюсь: при таком подходе все операции записи выполняются
лишь на одном сервере (master), а остальные сервера (slave) получают
данные напрямую от "мастера", обрабатывая при этом лишь запросы на
чтение данных. Как известно, операции чтения и записи любого веб-проекта
всегда растут пропорционально росту нагрузки, при этом сохраняется почти
фиксированным соотношение между обоими типами запросов: на каждый запрос
на обновление данных обычно приходится в среднем около десятка запросов
на чтение. Со временем нагрузка растет, а значит растет и количество
операций записи в единицу времени, а сервер-то обрабатывает их всего
один, а затем он же еще и обеспечивает создание некоторого количества
копий на других серверах. Рано или поздно издержки операций репликации
данных станут быть настолько высоки, что этот процесс станет занимать
очень большую часть процессорного времени каждого сервера, а каждый
slave сможет обрабатывать лишь сравнительно небольшое количество
операций чтения, и, как следствие, каждый дополнительный slave-сервер
начнет увеличивать суммарную производительность лишь незначительно, тоже
занимаясь по большей части лишь поддержанием своих данных в соответствии
с "мастером".&lt;/p&gt;
&lt;p&gt;Временным решением этой проблемы, возможно, может стать замена
master-сервера на более производительный, но так или иначе не выйдет
бесконечно откладывать переход на следующий "уровень" развития системы
хранения данных: &lt;strong&gt;"sharding"&lt;/strong&gt;, которому я совсем недавно посвятил
&lt;a href="https://www.insight-it.ru/theory/2008/segmentirovanie-bazy-dannykh/"&gt;отдельный пост "Сегментирование баз данных"&lt;/a&gt;.
Так что позволю себе остановиться на нем лишь вкратце: идея заключается
в том, чтобы разделить все данные на части по какому-либо признаку и
хранить каждую часть на отдельном сервере или кластере, такую часть
данных в совокупности с системой хранения данных, в которой она
находится, и называют сегментом или &lt;em&gt;shard&lt;/em&gt;&amp;rsquo;ом. Такой подход позволяет
избежать издержек, связанных с реплицированием данных (или сократить их
во много раз), а значит и &lt;em&gt;существенно&lt;/em&gt; увеличить общую
производительность системы хранения данных. Но, к сожалению, переход к
этой схеме организации данных требует массу издержек другого рода. Так
как готового решения для ее реализации не существует, приходится
модифицировать логику приложения или добавлять дополнительную
"прослойку" между приложением и СУБД, причем все это чаще всего
реализуется силами разработчиков проекта. Готовые продукты способны лишь
облегчить их работу, предоставив некий каркас для построения основной
архитектуры системы хранения данных и ее взаимодействия с остальными
компонентами приложения.&lt;/p&gt;
&lt;p&gt;На этом этапе цепочка обычно заканчивается, так как сегментированные
базы данных могут горизонтально масштабироваться для того, чтобы в
полной мере удовлетворить потребности даже самых высоконагруженных
интернет-ресурсов. К месту было бы сказать пару слов и о собственно
самой структуре данных в рамках баз данных и организации доступа к ним,
но какие-либо решения сильно зависят от конкретного приложения и
реализации, так что позволю себе лишь дать пару общих рекомендаций:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Денормализация&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Запросы, комбинирующие данные из нескольких таблиц, обычно при
прочих равных требуют большего процессорного времени для выполнения,
чем запрос, затрагивающий лишь одну таблицу. А производительность,
как уже упоминалось в начале повествования, чрезвычайно важна на
просторах Сети.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Логическое разбиение данных&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Если какая-то часть данных всегда используется отдельно от основной
массы, то иногда имеет смысл выделить ее в отдельную независимую
систему хранения данных.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Низкоуровневая оптимизация запросов&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Ведя и анализируя логи запросов, можно определить наиболее медленные
из них. Замена найденных запросов на более эффективные с той же
функциональностью может помочь более рационально использовать
вычислительные мощности.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;В этом разделе стоит упомянуть еще один, более специфический, тип
интернет-проектов. Такие проекты оперируют данными, не имеющими четко
формализованную структуру, в таких ситуациях использование реляционных
СУБД в качестве хранилища данных, мягко говоря, нецелесообразно. В этих
случаях обычно используют менее строгие базы данных, с более примитивной
функциональностью в плане обработки данных, но зато они способны
обрабатывать огромные объемы информации не придираясь к его качеству и
соответствию формату. В качестве основы для такого хранилища данных
может служить кластерная файловая система, а для анализа же данных в
таком случае используется механизм под названием
&lt;a href="/tag/mapreduce/"&gt;MapReduce&lt;/a&gt;, принцип его работы я расскажу лишь вкратце,
так как в полном своем масштабе он несколько выходит за рамки данного
повествования.&lt;/p&gt;
&lt;p&gt;Итак, мы имеем на входе некие произвольные данные в не факт что
правильно соблюденном формате. В результате нужно получить некое
итоговое значение или информацию. Согласно данному механизму практически
любой анализ данных можно провести в следующие два этапа:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Основной целью данного этапа является представление произвольных
входных данных в виде промежуточных пар ключ-значение, имеющих
определенный смысл и формально оформленных. Результаты подвергаются
сортировке и группированию по ключу, а после чего передаются на
следующий этап.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Reduce&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Полученные после &lt;strong&gt;map&lt;/strong&gt; значения используются для финального
вычисления требуемых итоговых данных.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Каждый этап каждого конкретного вычисления реализуется в виде
независимого мини-приложения. Такой подход позволяет практически
неограниченно распараллеливать вычисления на огромном количестве машин,
что позволяет в мгновения обрабатывать объемы практически произвольных
данных. Для этого достаточно лишь запустить эти приложения на каждом
доступном сервере одновременно, а затем собрать воедино все результаты.&lt;/p&gt;
&lt;p&gt;Примером готового каркаса для реализации работы с данными по такому
принципу служит opensource проект Apache Foundation под названием
&lt;a href="https://www.insight-it.ru/storage/2008/hadoop/"&gt;&lt;em&gt;Hadoop&lt;/em&gt;&lt;/a&gt;, о котором я уже неоднократно
рассказывал ранее, да и &lt;a href="https://www.insight-it.ru/goto/1a5b89d0/" rel="nofollow" target="_blank" title="http://ru.wikipedia.org/wiki/Hadoop"&gt;статейку в Википедию&lt;/a&gt; написал в свое время.&lt;/p&gt;
&lt;h3 id="vmesto-zakliucheniia"&gt;Вместо заключения&lt;/h3&gt;
&lt;p&gt;Если честно, мне с трудом верится, что я смог написать настолько
всеобъемлющий пост и сил на подведение итогов уже практически не
осталось. Хочется лишь сказать, что в разработке крупных проектов важна
каждая деталь, а неучтенная мелочь может стать причиной провала. Именно
по-этому в этом деле учиться стоит не на своих ошибках, а на чужих.&lt;/p&gt;
&lt;p&gt;Хоть может быть этот текст и выглядит как некое обобщение всех постов из
серии &lt;a href="https://www.insight-it.ru/highload/"&gt;"Архитектуры высоконагруженных систем"&lt;/a&gt;, но врядли он
станет финальной точкой, надеюсь мне &lt;a href="/feed/"&gt;найдется что сказать&lt;/a&gt; по
этой теме и в будущем, может быть однажды это будет основано и на личном
опыте, а не просто будет результатом переработки массы полученной мной
информации. Кто знает?...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Mon, 12 May 2008 09:00:00 +0400</pubDate><guid>tag:www.insight-it.ru,2008-05-12:theory/2008/masshtabiruemye-veb-arkhitektury/</guid><category>online</category><category>архитектура</category><category>веб-приложение</category><category>веб-проект</category><category>веб-сервер</category><category>геораспределение</category><category>информационные технологии</category><category>кэширование</category><category>Масштабируемость</category><category>распределенные вычисления</category><category>сегментирование баз данных</category></item><item><title>Интерфейс</title><link>https://www.insight-it.ru//theory/2008/interfejs/</link><description>&lt;p&gt;&lt;img alt="Интерфейс" class="right" src="https://www.insight-it.ru/images/exec.png"/&gt;
Наверняка у многих из вас слово &lt;em&gt;"интерфейс"&lt;/em&gt; ассоциируется с внешним
видом любой программы, то есть кнопочками, виджетами, иконками и прочим
ее оформлением. Да, несомненно графический пользовательский интерфейс
является одним из значений этого понятия, но существует и масса других!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Хотите узнать больше?&lt;/strong&gt;
&lt;!--more--&gt;
В общем случае под словом интерфейс понимают правила и рамки
взаимодействия двух произвольных объектов. В рамках компьютерной
терминологии такими объектами обычно выступают люди, оборудование,
программное обеспечение или его компоненты, но этот термин применим и
далеко за ее пределами.&lt;/p&gt;
&lt;p&gt;Вернувшись к примеру из первого абзаца мы теперь можем вполне
аргументированно объяснить почему GUI так часто приравнивают к слову
интерфейс: он просто является частным случаем интерфейса между
приложением и его пользователем. Можно было бы привести еще массу
примеров различных интерфейсов, скажем сокет в качестве интерфейса между
процессором и материнской платой, но целью написания этого поста было
вовсе не это.&lt;/p&gt;
&lt;p&gt;Уже догадались? Да, это я так неспеша плавно подводил разговор к
&lt;a href="/tag/oop/"&gt;объектно-ориентированному программированию&lt;/a&gt;. Термин
&lt;em&gt;интерфейс&lt;/em&gt; широко применяется и в нем. Как не трудно предположить, в
роли объектов в этом случае выступают как сами классы, так и их
экземпляры (которые, впрочем, тоже принято называть словом &lt;em&gt;объект&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;В общем случае интерфейсом класса выступает совокупность его &lt;strong&gt;public&lt;/strong&gt;
методов и переменных, то есть доступных для обращения из других частей
приложения. Этот факт вполне логичен - именно благодаря им и
осуществляется взаимодействие класса (или его объекта) с "внешним
миром". Но не все так просто, особенно с точки зрения &lt;a href="https://www.insight-it.ru/theory/2008/design-patterns/"&gt;шаблонов
проектирования&lt;/a&gt;, немаловажную роль в
взаимодействии классов и объектов играет &lt;strong&gt;абстракция&lt;/strong&gt;. Хочется
обратить внимание, что формально имеется ввиду даже не сами методы, а их
заголовки, то есть название, набор получаемых переменных и тип
возвращаемого значения (этот набор данных принято также принято называть
интерфейсом методов или функций), само тело метода (реализация) в данном
случае не важно.&lt;/p&gt;
&lt;p&gt;Иными словами, если один класс (будем называть его &lt;em&gt;клиент&lt;/em&gt;)
взаимодействует с каким-либо другим объектом, то по большому счету он
абсолютно не обязан знать какого класса этот объект является экземпляром
(может конечно, но это совсем не обязательно). Единственное, что
интересует класс-клиент, это &lt;em&gt;интерфейс&lt;/em&gt; объекта, с которым он
взаимодействует, этой информации вполне достаточно для полноценной
совместной работы.&lt;/p&gt;
&lt;p&gt;Сразу напрашивается вполне резонный вопрос: а как же тогда клиент может
быть уверен, что в классе, с которым он работает, какой-либо конкретный
интерфейс реализован? Допустим ему нужен во-о-о-он тот метод, а как же
узнать доступен ли он и получит ли клиент в ответ данные нужного типа?
Ответ на этот вопрос реализован в каждом языке программирования
по-разному: где-то существует специальные ключевые слова для
&lt;em&gt;обозначения&lt;/em&gt; интерфейсов и классов, их реализующих, где-то это
ненавязчиво реализуется средствами &lt;em&gt;наследования&lt;/em&gt; и &lt;em&gt;полиморфизма&lt;/em&gt; на
более концептуальном уровне.&lt;/p&gt;
&lt;p&gt;Самым наглядным языком программирования для демонстрации описания
интерфейсов я считаю &lt;strong&gt;Java&lt;/strong&gt; (хотя можно было бы выбрать и C#, PHP или
практически любой другой по вкусу). В теории все просто:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ключевое слово &lt;code&gt;interface&lt;/code&gt; обозначает описание интерфейса;&lt;/li&gt;
&lt;li&gt;За ним следует название конкретного интерфейса, которое впоследствии
    можно будет использовать в коде при его упоминании (некоторые
    программисты на правах традиции начинают названия интерфейсов с
    заглавной буквы &lt;strong&gt;I&lt;/strong&gt;, мне в свое время даже пытались объяснить
    зачем так надо делать, но аргументы не показались мне достаточно
    весомыми);&lt;/li&gt;
&lt;li&gt;Далее идет тело интерфейса, в котором перечисляются все заголовки
    методов, которые должны быть в классе, реализующем данный интерфейс
    (никакой реализации!);&lt;/li&gt;
&lt;li&gt;Впоследствии приписав к заголовку любого класса ключевое слово
    &lt;code&gt;implements&lt;/code&gt; с последующим указанием названия интерфейса, можно
    &lt;em&gt;обязать&lt;/em&gt; этот класс реализовать указанные в описания интерфейса
    методы. Существует небольшое исключение для абстрактных классов (то
    есть классов,для которых &lt;em&gt;не может&lt;/em&gt; быть создан объект, обозначаются
    ключевым словом &lt;code&gt;abstract&lt;/code&gt;), они &lt;em&gt;могут&lt;/em&gt; и не реализовать все
    методы интерфейса, но тогда эта &lt;em&gt;обязанность&lt;/em&gt; будет переложена на их
    &lt;em&gt;наследников&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В данной ситуации клиент, работающий с каким-либо произвольным объектом
может просто-напросто проверить, реализован ли в нем заранее
определенный интерфейс, что даст ему гарантию, что он может смело
обращаться к необходимому набору методов.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Небольшое примечание:&lt;/em&gt; сами интерфейсы и методы в их теле по-умолчанию
обладают свойствами &lt;code&gt;abstract&lt;/code&gt; и &lt;code&gt;public&lt;/code&gt;, так что повторно
указывать эти ключевые слова не нужно.&lt;/p&gt;
&lt;p&gt;На практике же это выглядит это примерно следующим образом:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// описание интерфейса&lt;/span&gt;
&lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Renderable&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// обязуем реализовать метод draw&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;draw&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// конкретная реализация интерфейса&lt;/span&gt;
&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SomeText&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Renderable&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
   &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;SomeText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;text&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;draw&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="c1"&gt;// вынуждены подчиниться и реализовать&lt;/span&gt;
       &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;text&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// класс-клиент&lt;/span&gt;
&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Render&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Render&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Renderable&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="c1"&gt;// можно быть уверенным, что&lt;/span&gt;
     &lt;span class="c1"&gt;// метод draw реализован&lt;/span&gt;
     &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;draw&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
     &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;         в качестве альтернативы можно было бы написать как-то так:&lt;/span&gt;
&lt;span class="cm"&gt;         if(obj instanceof Renderable)obj.draw();&lt;/span&gt;
&lt;span class="cm"&gt;         то есть проверить реализован ли интерфейс&lt;/span&gt;
&lt;span class="cm"&gt;         вместо использования его названия в роли типа данных&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;В данном примере ситуация тривиальна: класс-клиент &lt;code&gt;Render&lt;/code&gt; умеет лишь
визуализировать классы, которые он получает в конструктор, вызывая у них
метод &lt;code&gt;draw&lt;/code&gt;. Для обеспечения такой возможности описан интерфейс
&lt;code&gt;Renderable&lt;/code&gt;, который реализуется в классе &lt;code&gt;SomeText&lt;/code&gt;. Хоть класс
&lt;code&gt;Render&lt;/code&gt; ничего и не знает о том, какой именно класс ему подсунут,
благодаря интерфейсу он сможет вывести на экран любой объект, корректно
реализующий наш интерфейс, в том числе и &lt;code&gt;SomeText&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Как я уже упоминал: альтернативой такому подходу является использование
полиморфизма и наследования. Такой подход более распространен в других
языках программирования, например C++, но пример я приведу все равно на
&lt;strong&gt;Java&lt;/strong&gt;, основываясь на предыдущем примере, чтобы читателям было проще
сравнивать.&lt;/p&gt;
&lt;p&gt;В теории такой подход еще проще: создается абстрактный класс, хоть
как-то реализующий наш интерфейс (теоретически реализация может быть и
пустой, просто в виде метода-заглушки), а на стороне клиента достаточно
лишь просто принимать только наследников этого абстрактного класса. В
нашем примере достаточно лишь изменить пару ключевых слов и все:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// теперь используем абстрактный класс&lt;/span&gt;
&lt;span class="kd"&gt;abstract&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Renderable&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// реализуем метод draw&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;draw&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Вывод на экран недоступен!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// реализация интерфейса (на этот раз неформального)&lt;/span&gt;
&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SomeText&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Renderable&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="c1"&gt;// на этот раз используем extends (наследование)&lt;/span&gt;
   &lt;span class="c1"&gt;// вместо implements&lt;/span&gt;
   &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
   &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;SomeText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;text&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;draw&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="c1"&gt;// переопределяем метод draw&lt;/span&gt;
       &lt;span class="c1"&gt;// но могли этого и не делать, тогда&lt;/span&gt;
       &lt;span class="c1"&gt;// использовался бы метод из Renderable&lt;/span&gt;
       &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;text&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// класс-клиент&lt;/span&gt;
&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Render&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Render&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Renderable&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="c1"&gt;// можно быть уверенным, что&lt;/span&gt;
     &lt;span class="c1"&gt;// метод draw реализован&lt;/span&gt;
     &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;draw&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
     &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;        на этот раз так как в крайнем случае&lt;/span&gt;
&lt;span class="cm"&gt;        в крайнем случае вызовется хотябы&lt;/span&gt;
&lt;span class="cm"&gt;        метод из класса Renderable&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Минимальные изменения - суть та же. Сразу хочу отметить, что этот
процесс так прост только в &lt;strong&gt;Java&lt;/strong&gt;, в других языках программирования
понадобилось бы использование дополнительных модификаторов для метода
&lt;code&gt;draw&lt;/code&gt; (например в &lt;strong&gt;C#&lt;/strong&gt;: &lt;code&gt;virtual&lt;/code&gt; или &lt;code&gt;abstract&lt;/code&gt; в
классе-потомке и &lt;code&gt;override&lt;/code&gt; в классе-наследнике, это необходимо для
обеспечения возможности их переопределения).&lt;/p&gt;
&lt;p&gt;На этом позвольте завершить данное повествование, очень надеюсь, что мне
удалось изложить суть максимально прозрачно. Эта тема будет активно
подниматься в дальнейших статьях по &lt;a href="/tag/oop/"&gt;ООП&lt;/a&gt;, так что очень
надеюсь, что она стала для Вас элементарной и очевидной. По традиции
напоминаю, что не пропустить публикацию новых постов можно &lt;a href="/feed/"&gt;подписавшись
на RSS&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sun, 04 May 2008 13:41:00 +0400</pubDate><guid>tag:www.insight-it.ru,2008-05-04:theory/2008/interfejs/</guid><category>Java</category><category>интерфейс</category><category>ООП</category><category>Программирование</category></item><item><title>Сегментирование базы данных</title><link>https://www.insight-it.ru//theory/2008/segmentirovanie-bazy-dannykh/</link><description>&lt;p&gt;&lt;img alt="Сегментирование базы данных" class="left" src="https://www.insight-it.ru/images/partitions.png"/&gt;
В процессе чтения моего блога у вас наверняка возникал вопрос: а что же
имеется в виду под фразой &lt;em&gt;сегментирование базы данных&lt;/em&gt;?
На самом деле это просто приглянувшийся мне вариант перевода термина
&lt;em&gt;sharding&lt;/em&gt; (или он же - &lt;em&gt;partitioning&lt;/em&gt;), в качестве альтернатив можно
было бы использовать &lt;em&gt;партиционирование&lt;/em&gt;, &lt;em&gt;секционирование&lt;/em&gt; или
что-нибудь еще менее звучное, суть от этого не меняется.&lt;/p&gt;
&lt;p&gt;Сильно сомневаюсь, что предыдущий абзац предоставил Вам полную
информацию по данному вопросу, так что позволю себе перейти к более
детальным ответам...
&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id="chto-eto-takoe"&gt;Что это такое?&lt;/h3&gt;
&lt;p&gt;Особенно в условиях Сети данные накапливаются и запрашиваются с
невероятной скоростью, рано или поздно даже самый мощный сервер
перестанет справляться с задачей хранения и предоставления данных.
Количество запросов в секунду, которое способен обеспечивать один сервер
ограничено ничуть не меньше, чем его дисковое пространство. Когда
запросы данных начинают поступать слишком интенсивно, чаще всего
прибегают к наиболее тривиальному решению: реплицирование данных на
несколько серверов и обработка запросов на чтение данных параллельно, а
записи - лишь на одном, классическая схема master-slave. Но и у такого
подхода есть предел, с ростом системы затраты вычислительных мощностей
на реплицирование данных рано или поздно начнут потреблять большую часть
процессорного времени, что сделает прирост производительности от
простого добавления в систему дополнительных серверов минимальным.
Единственным выходом из такой ситуации становится пересмотр архитектуры
всей системы хранения данным, одним из возможных исходов которого и
сожет стать сегментирование базы данных.&lt;/p&gt;
&lt;p&gt;Сама идея сегментирования проста: разбить все данные на части по
какому-либо признаку и хранить каждую часть на отдельном сервере или
кластере, такую часть данных в совокупности с системой хранения данных,
в которой она находится, и называют сегментом или shard'ом.&lt;/p&gt;
&lt;p&gt;Признак по которому разделяются данные должен быть максимально прост и
очевиден, ведь в случае необходимости получения конкретных данных именно
он будет служить путеводителем для определения в каком именно сегменте
эти данные необходимо искать. В большинстве ситуаций такая необходимость
возникает очень часто, а значит и проверка признака должна выполняться
очень быстро. Сами эти признаки можно распределить на несколько групп по
принципу их проверки:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Диапазон&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Самый простой и тривиальный вариант, выбирается один из параметров
какой-либо записи, например идентификационный номер, и проверяется
его принадлежность определенному диапазону, например все записи с ID
от 0 до 999 хранятся на одном сервере, от 1000 до 1999 - на другом,
и так далее.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Список&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Принцип остается такой же как и при использовании диапазонов, с той
лишь разницей что проверяется принадлежность параметра какому-либо
списку значений (который может состоять и из одного значения), а не
диапазону, например: людей можно разбить по районам проживания или
их имени.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Хэш-функция&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;О принципах работы хэширующих функций &lt;a href="https://www.insight-it.ru/security/2008/obratnogo-puti-net/"&gt;я уже рассказывал&lt;/a&gt;, так что
лишь вкратце опишу принцип такого подхода: для определения в каком
именно сегменте хранится та или иная запись, один из ее заранее
известных параметров передается хэширующей функции, возвращающей в
качестве результата номер сегмента от 0 до (n-1), где - n общее
количество сегментов.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Композиция&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;При дальнейшем росте объемов данных и нагрузке на систему можно
несколько усложнить ее работу, реализовав сегментирование на основе
композиции из нескольких упомянутых выше признаков.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;В условиях интернет-проектов данные обычно разбиваются по принадлежности
к пользователю, автором которых он является (или просто они как-либо
взаимосвязаны), с использованием хэш-функций.&lt;/p&gt;
&lt;h3 id="dlia-chego-eto-vse-nuzhno"&gt;Для чего это все нужно?&lt;/h3&gt;
&lt;p&gt;Возможно описание получилось несколько устрашающим, но на самом деле вся
эта история с распределением данных того стоит. Для начала стоит
отметить, что такой подход позволяет оперировать огромными объемами
данными с невероятной скоростью, благодаря параллельной обработке
запросов в абсолютно разных частях системы. Количество запросов,
обрабатываемых каждым узлом одновременно невелико, что не может не
сказаться на скорости обработки каждого запроса.&lt;/p&gt;
&lt;p&gt;Использование в качестве системы хранения данных для каждого сегмента
кластера, а не просто одного сервера, может существенно повысить
надежность системы в случае программных или аппаратных сбоев. Тем более
в случае использования master-slave репликации в рамках каждого
сегмента, у системы в целом все равно не будет единственного сервера для
обработке операций записи позволит минимизировать издержки
реплицирования данных.&lt;/p&gt;
&lt;h3 id="a-kak-zhe"&gt;А как же...&lt;/h3&gt;
&lt;h4&gt;...перераспределять данные?&lt;/h4&gt;
&lt;p&gt;При необходимости по тем или иным причинам изменить количество сегментов
возникновение ситуации, когда система нагружена неравномерно, очень
вероятно. Наиболее простым решением было бы простое перераспределение
записей, но как же его реализовать?&lt;/p&gt;
&lt;p&gt;Над этой проблемой стоит задуматься сразу же при переходе к
сегментированной архитектуре. Она может сначала показаться нерешаемой
без одновременного перемещения огромных массивов данных и временной
практически полной потери производительности, но это не так. Наиболее
элегантным решением является организация для системы некоторого сервиса
определения местоположения данных, в обязанности входит не только
определение номера сегмента по заранее определенному алгоритму, но и
постепенное перемещение данных в случае необходимости. Например, в
случае появления необходимости разбить сегмент на две части в связи с
приближающимся переполнением дискового простронства, данный сервис
начнет постепенно последовательно создавать копии записей на новом или
существующем слабо загруженном сегменте. Пока копирование каждой
конкретной записи не будет завершено операции чтения перенаправляются на
исходный сегмент. Как только процесс завершился - перенаправление данных
переключается на копию, а оригинал уничтожается, после чего система
переходит к перемещению следующей записи.&lt;/p&gt;
&lt;h4&gt;...выполнить операцию, затрагивающию разные сегменты?&lt;/h4&gt;
&lt;p&gt;Когда все данные хранились в одном месте - можно было бы выполнить один
сложноструктурированный запрос и получить все нужные данные, но при
таком распределении данных это не возможно. Для достижения такого же
результата необходимо выполнение нескольких запросов к различным
сегментам и аггрегация полученных данных на программном уровне.&lt;/p&gt;
&lt;h4&gt;...реализовать все это?&lt;/h4&gt;
&lt;p&gt;Один из самых интересных вопросов, которые можно было бы задать по
данной теме. Однозначно лучшего решения для реализации этого подхода не
существует. В большинстве случаев приходится реализовывать теорию на
практике своими силами, но готовые решения все же тоже существуют:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/goto/2b245ae9/" rel="nofollow" target="_blank" title="http://www.enterprisedb.com/community/projects/gridsql.do"&gt;GridSQL&lt;/a&gt;
    от EnterpriseDB предоставляет систему сегментирования на базе
    &lt;a href="/tag/postgresql/"&gt;PostgreSQL&lt;/a&gt; (которую, кстати, не так давно под GPL
    опубликовали);&lt;/li&gt;
&lt;li&gt;Многие реляционные системы управления базами данных, такие как MySQL
    и Oracle, имеют собственную встроенную систему разбиения данных на
    партиции;&lt;/li&gt;
&lt;li&gt;В рамках проекта &lt;a href="https://www.insight-it.ru/goto/cacbd918/" rel="nofollow" target="_blank" title="http://www.hibernate.org"&gt;Hibernate&lt;/a&gt;
    разрабатывается библиотека, инкапсулирующая сегментирование данных;&lt;/li&gt;
&lt;li&gt;В &lt;a href="https://www.insight-it.ru/highload/2008/arkhitektura-livejournal/"&gt;статье об архитектуре LiveJournal&lt;/a&gt; я рассказывал о спектре opensource-решений от разработчиков этого проекта для схожих задач.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Так или иначе ни один из них не является средством из серии "установил и
все сразу заработало", они лишь могут упростить реализацию такой
системы, существенную часть работы придется проделать самостоятельно.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Ещё остались вопросы по теме?&lt;/em&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Thu, 01 May 2008 20:12:00 +0400</pubDate><guid>tag:www.insight-it.ru,2008-05-01:theory/2008/segmentirovanie-bazy-dannykh/</guid><category>partitioning</category><category>shard</category><category>sharding</category><category>архитектура</category><category>Масштабируемость</category><category>партиционирование</category><category>сегментирование</category><category>сегментирование баз данных</category><category>секционирование</category><category>СУБД</category></item><item><title>Design patterns</title><link>https://www.insight-it.ru//theory/2008/design-patterns/</link><description>&lt;p&gt;&lt;img alt="Шаблоны проектирования" class="right" src="{filename/images/idea.png" title="Шаблоны проектирования"/&gt;
Как говорится, все новое - хорошо забытое старое. Когда я в вдруг вспомнил
эту поговорку, мне пришла в голову мысль вернуться к незаслуженно
забытой некоторое время назад теме объектно-ориентированного
программирования. Возможно многим читателям уже поднадоели часто
публикующиеся здесь &lt;a href="https://www.insight-it.ru/highload/"&gt;статьи об устройстве уже существующих проектов&lt;/a&gt;, это конечно же не повод прекратить их публикацию, но, тем не менее, немного отвлечься все же стоит.&lt;/p&gt;
&lt;p&gt;Этот пост будет введением в очередную ветвь спирали повествования о
теории &lt;a href="/tag/oop/"&gt;ООП&lt;/a&gt;, о которой уже много было сказано различными
авторами, не знаю остались ли в этой теме неосвещенные уголки, но все же
я думаю, что мне найдется что сказать.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;em&gt;&lt;a href="/tag/design-patterns/"&gt;Design Patterns&lt;/a&gt;&lt;/em&gt; обычно переводят на русский
фразой &lt;em&gt;"шаблоны проектирования"&lt;/em&gt;, оно применимо и за рамками
программирования, в таких случаях под ней подразумевают просто
стандартизованное эффективное решение характерного класса задач. В
рамках программирования это понятие можно несколько конкретизировать,
представив его как незаконченную заготовку для будущего проекта или его
части, которая не может быть напрямую реализована в коде, но зато она
предоставляет некую скорее теоретическую базу для последующего решения
задачи в самом проекте. Возможно у кого-то из вас возникла ассоциация с
алгоритмами, она вполне предсказуема, но не совсем уместна: речь идет о
проектировании, а не решении каких-либо вычислительных задач.&lt;/p&gt;
&lt;p&gt;Если же говорить об объектно-ориентированных шаблонах проектирования, то
зачастую помимо просто методов и средств для решения задачи или просто
общей схемы организации проекта они предоставляют механизмы и схемы
построения взаимоотношения классов, выполняющих определенные роли для
достижения общей цели.&lt;/p&gt;
&lt;p&gt;Изначально идея построения шаблонов для решения типичных задач появилась
в архитектуре (имеется ввиду которая к строительству относится, а не к
&lt;a href="https://www.insight-it.ru/highload/"&gt;высоконагруженным системам&lt;/a&gt; :) ). Автором ее был Cristopher Alexander, он впервые составил набор шаблонов проектирования для архитекторов во второй половине двадцатого века, но, к сожалению, в этой науке эта идея не прижилась, зато ее успешно переняли и перенесли в область программирования.&lt;/p&gt;
&lt;p&gt;Основной вклад в этот процесс сделала знаменитая команда, известная как
&lt;strong&gt;Gang of Four&lt;/strong&gt;. Она состоит из четырех авторов не менее известной
книги &lt;em&gt;"Design Patterns &amp;mdash; Elements of Reusable Object-Oriented
Software"&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Erich Gamma&lt;/li&gt;
&lt;li&gt;Richard Helm&lt;/li&gt;
&lt;li&gt;Ralph Jonson&lt;/li&gt;
&lt;li&gt;John Vlissides&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Именно благодаря этим людям и их книге эта методология проектирования
программного обеспечения получила такое широкое распространение. В своей
книге они предоставили 23 основных шаблона проектирования, каждый из
которых может использоваться для решения очень широкого класса
абстрактных задач, при этом абсолютно не привязываясь к какому-либо
конкретному языку программирования или стилю написания кода. Но не стоит
забывать, что все они - просто часть теории, скорее указание на верный
путь, чем тропинка, с которой нельзя сделать шаг в сторону.&lt;/p&gt;
&lt;p&gt;Основным преимуществом применения шаблонов проектирования при разработке
программного обеспечения является тот факт, что они помогают существенно
ускорить процесс разработки и проектирования, предоставляя проверенную
временем и многими разработчиками парадигму разработки. Помимо этого они
существенно упрощают понимание кода при работе над ним группы
программистов, а также процесс составления документации.&lt;/p&gt;
&lt;p&gt;В последующих записях я планирую пройтись по основным шаблонам
проектирования с более подробной информацией о сферах их применения, их
востребованности, эффективности, а также с приведением примеров на
каком-либо языке программирования, скорее всего на &lt;a href="/tag/java/"&gt;Java&lt;/a&gt;,
так как он позволит сделать примеры более наглядными. Как обычно для
более оперативного получения информации об обновлении блога хочу
предложить &lt;a href="/feed/"&gt;подписаться на RSS-ленту&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Thu, 24 Apr 2008 13:03:00 +0400</pubDate><guid>tag:www.insight-it.ru,2008-04-24:theory/2008/design-patterns/</guid><category>Design Patterns</category><category>Gang of Four</category><category>GoF</category><category>ООП</category><category>Программирование</category></item><item><title>hCard</title><link>https://www.insight-it.ru//theory/2008/hcard/</link><description>&lt;p&gt;&lt;a href="https://www.insight-it.ru/goto/7ed2e6a8/" rel="nofollow" target="_blank" title="http://microformats.org/wiki/hcard"&gt;hCard&lt;/a&gt; представляет собой
реализацию спецификации &lt;a href="https://www.insight-it.ru/goto/9d8165cb/" rel="nofollow" target="_blank" title="http://www.ietf.org/rfc/rfc2426.txt"&gt;RFC 2426&lt;/a&gt;
(более известной как vCard) в виде микроформата. Основной его целью
является предоставление стандарта оформления персональных данных на
просторах Сети, но помимо этого имеется возможность указания информации
об компаниях, организациях или местах.
&lt;!--more--&gt;
Как и любой другой микроформат, hCard реализуется без нарушения
стандартов XHTML с помощью атрибутов тэга &lt;code&gt;class&lt;/code&gt;, причем какие именно
тэги используются - не важно. Для оформления данных используя этот
микроформат достаточно лишь объявить какой-либо тэг hCard объектом с
помощью &lt;code&gt;class="vcard"&lt;/code&gt; и разместить внутри него все тэги,
обозначающие какое-либо свойство объекта. Большая часть информации,
предоставляемой в соответствии с этим микроформатом является
опциональной, единственным обязательным свойством является имя объекта -
&lt;code&gt;class="fn"&lt;/code&gt;. Помимо этого в атрибуте &lt;strong&gt;profile&lt;/strong&gt; тэга &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;
принято указывать адрес &lt;code&gt;http://www.w3.org/2006/03/hcard&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;В целом все свойства объектов hCard можно поделить на семь групп:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;идентификационные&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;ndash; различные варианты имен объекта.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;адресные&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;ndash; указания различных адресов, каким-либо образом ассоциирующихся с
объектом: место жительство, работы и тому подобные.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;телекоммуникационные&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;ndash; любые формы контактной информации: номера телефонов, факс, адреса
электронной почты и так далее.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;географические&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;ndash; месторасположение объекта.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;организационные&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;ndash; информация о должности и компании или организации, в которой
работает объект.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;уточняющие&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;ndash; любая дополнительная информация об объекте.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;безопасность&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;ndash; ограничение доступа к информации в hCard.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Значением каждого свойства является видимый пользователю текст,
получающийся в результате обработки документа браузером (или другим
парсером данных). Но стоит несколько остановиться на свойстве photo, так
как для него действуют несколько другие правила размещения значения:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;при использовании свойства photo в тэге &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;, значением
    является адрес из атрибута &lt;code&gt;href&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;в тэге &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;, значением является само изображение, то есть
    значение атрибута &lt;code&gt;src&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;в &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;, значением является атрибут &lt;code&gt;`data&lt;/code&gt;, то есть его
    источник данных.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Раз уж зашла речь об размещении значений свойств, то сразу хочется
сказать об небольшом исключении в виде тэга &lt;code&gt;&amp;lt;abbr&amp;gt;&lt;/code&gt;, где оно
задается в атрибуте &lt;code&gt;title&lt;/code&gt;, а внутри самого тэга - некое более
удобное для чтения людьми его представление.&lt;/p&gt;
&lt;p&gt;Если тэг, обозначенный любым свойством, содержит какую-либо информацию
помимо самого значения свойства, то для отделения релевантного контента
от лишней информации можно разместить внутри тэга свойства дочерние
объекты, обозначив их атрибутом &lt;code&gt;class="value"&lt;/code&gt;. Это даст понять
парсеру микроформата, что собрав воедино (методом конкатенации) все
значения помеченных таким образом объектов он сможет получить значение
исходного свойства. Описание получилось несколько запутанным, так что
лучше продемонстрировать этот принцип на примере, в котором значению
свойства &lt;strong&gt;fn&lt;/strong&gt; будет присвоено значение "Иван Блинков":&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"vcard"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"fn"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;span&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"value"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Иван &lt;span class="nt"&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;подпрыгнул три раза на месте,
    обернулся и увидел написанную на стене
    свою фамилию: &lt;span class="nt"&gt;&amp;lt;span&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"value"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Блинков&lt;span class="nt"&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;.
  &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Как не трудно заметить, значение свойства разбавлено массой ненужной
информации, но с помощью тэгов с атрибутом &lt;code&gt;class="value"&lt;/code&gt; мне удалось
выделить лишь важную информацию, не поменяв при этом внешний вид
документа. Парсер микроформатов, читая этот документ, соединит обе части
и получит в итоге как раз "Иван Блинков", что и будет соответствовать
желаемому имени объекта.&lt;/p&gt;
&lt;p&gt;Вы заметили в предыдущем примере пробел после моего имени? Он был
поставлен для того, чтобы при конкатенации составные части значения не
слились в одно слово "ИванБлинков", не самый удобный подход к решению
проблемы, но у него есть альтернатива в виде тэга &lt;code&gt;&amp;lt;abbr&amp;gt;&lt;/code&gt; (не
забываем про упомянутое чуть выше исключение):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"vcard"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;abbr&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"fn"&lt;/span&gt; &lt;span class="na"&gt;title=&lt;/span&gt;&lt;span class="s"&gt;"Иван Блинков"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    Иван
  &lt;span class="nt"&gt;&amp;lt;/abbr&amp;gt;&lt;/span&gt;
  подпрыгнул три раза на месте,
  обернулся и увидел написанную на стене
  свою фамилию: Блинков.
&lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Общей информации на сегодня хватит, так что перейду к деталям
реализации.&lt;/p&gt;
&lt;h4&gt;Идентификационные свойства&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Свойство&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Описание&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;fn&lt;/td&gt;
&lt;td&gt;полное имя объекта &lt;em&gt;(formatted name)&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;имя, используется для идентификации составных частей fn &lt;em&gt;(name)&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nickname&lt;/td&gt;
&lt;td&gt;прозвище&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bday&lt;/td&gt;
&lt;td&gt;день рождения в формате &lt;strong&gt;YYYY-MM-DD&lt;/strong&gt; &lt;em&gt;(birthday)&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;photo&lt;/td&gt;
&lt;td&gt;фотография&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Свойство &lt;strong&gt;fn&lt;/strong&gt; уже успели слегка обсудить, так что перейдем сразу к
&lt;strong&gt;n&lt;/strong&gt;. Как уже было сказано, используется он для детализации составных
частей полного имени объекта, для чего оно имеет ряд подсвойств,
используемых в дочерних элементах:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;given-name&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;ndash; имя.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;additional-name&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;ndash; отчество.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;family-name&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;ndash; фамилия.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;honorific-preffix&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;ndash; какой-либо префикс к имени, отображающий социальный статус
человек.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;honorific-suffix&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;ndash; суффикс с тем же смыслом.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Выглядит это все примерно так, ничего сложного:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"vcard"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"n"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;span&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"given-name"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Иван&lt;span class="nt"&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;span&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"additional-name"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Иванович&lt;span class="nt"&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;span&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"family-name"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Блинков&lt;span class="nt"&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Адресные свойства&lt;/h4&gt;
&lt;p&gt;Адрес может быть указан в двух формах:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;adr&lt;/strong&gt; - структурированной (с указанием составных частей);&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;label&lt;/strong&gt; - не структурированной.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для структурированного адреса используются подсвойства по аналогии с
&lt;strong&gt;n&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Свойство&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Описание&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;post-office-box&lt;/td&gt;
&lt;td&gt;почтовый адрес&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;extended-address&lt;/td&gt;
&lt;td&gt;полный адрес (с номером подъезда, квартиры и т.д.)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;street-address&lt;/td&gt;
&lt;td&gt;улица&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;locality&lt;/td&gt;
&lt;td&gt;город&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;region&lt;/td&gt;
&lt;td&gt;регион, штат или провинция&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;postal-code&lt;/td&gt;
&lt;td&gt;индекс&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;тип адреса, то есть то, как он связан с исходным идивидом, должен принимать одно из значений: dom, parcel, home, work, pref&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;label&lt;/strong&gt; же используется просто для написания адреса по тому же
принципу, как если бы Вы писали его, например, на конверте традиционного
письма. Возможно использование подсвойства &lt;strong&gt;type&lt;/strong&gt; как и в &lt;strong&gt;adr&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;С телекоммуникационными свойствами все проще:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;телефон - &lt;strong&gt;tel&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;адрес электронной почты - &lt;strong&gt;email&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;почтовый клиент - &lt;strong&gt;mailer&lt;/strong&gt; (не понятно - и зачем он тут сдался?).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Телефонный номер может иметь тип (&lt;strong&gt;type&lt;/strong&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;home&lt;/strong&gt; - домашний&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;msg&lt;/strong&gt; - имеется автоответчик&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;work&lt;/strong&gt; - рабочий&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pref&lt;/strong&gt; - предпочтительный&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;voice&lt;/strong&gt; - голосовой&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fax&lt;/strong&gt; - факс&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cell&lt;/strong&gt; - мобильный aka сотовый&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;video&lt;/strong&gt; - для видеоконференций&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pager&lt;/strong&gt; - пэйджер&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bbs&lt;/strong&gt; - bulletin board system&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;modem&lt;/strong&gt; - возможно использование модема&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;isdn&lt;/strong&gt; - integrated services digital network&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pcs&lt;/strong&gt; - personal communication service&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Географические свойства также не отличаются особой сложностью:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;tz&lt;/strong&gt; - временная зона&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;long&lt;/strong&gt; - широта&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lat&lt;/strong&gt; - долгота&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;С ручным заполнением этих свойств могут возникнуть некоторые проблемы,
но при интеграции веб-приложения с сервисом вроде Google Earth - должно
быть вполне удобно.&lt;/p&gt;
&lt;p&gt;Свойства, описывающие индивида с точки зрения работы, немногочисленны:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;title&lt;/strong&gt; - должность&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;role&lt;/strong&gt; - роль&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;logo&lt;/strong&gt; - ссылка на логотип компании&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;agent&lt;/strong&gt; - указание представителя индивида, например секретаря,
    например в виде ссылки на его hCard&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;org&lt;/strong&gt; - название компании&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Дополнительные свойства:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;category&lt;/strong&gt; - категория, то есть чем по сути является данный hCard,
    например - визитка&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;note&lt;/strong&gt; - какие-либо замечания к остальным свойствам&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rev&lt;/strong&gt; - время последнего редактирования hCard, то есть время на
    которое данная информация является актуальной&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sort-string&lt;/strong&gt; - отмечает какая часть hCard (обычно часть имени),
    которая будет использована при сортировке списка из нескольких hCard&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sound&lt;/strong&gt; - адрес, указывающий на звуковой файл с правильным
    произношением имени индивида&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;url&lt;/strong&gt; - адрес персонального или корпоративного сайта&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;uid&lt;/strong&gt; - уникальный идентификационный номер в каком-либо
    специфицированном IANA формате (подсвойство &lt;strong&gt;type&lt;/strong&gt; указывает в
    каком именно)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для обеспечения ограничения доступа к данным из &lt;a href="/tag/hcard/"&gt;hCard&lt;/a&gt;
используется два свойства - &lt;strong&gt;class&lt;/strong&gt; и &lt;strong&gt;key&lt;/strong&gt;. &lt;strong&gt;class&lt;/strong&gt; определяет
уровень доступа по примерно тому же принципу, что и в &lt;a href="/tag/oop/"&gt;ООП&lt;/a&gt;:
&lt;em&gt;public&lt;/em&gt; или &lt;em&gt;confidentional&lt;/em&gt;. А свойство &lt;strong&gt;key&lt;/strong&gt; предоставляет
публичный ключ, для расшифровки данных с закрытым доступом.&lt;/p&gt;
&lt;p&gt;Хочется добавить, что благодаря своей структурированной архитектуре
данный микроформат может использоваться в более широком спектре случаев,
чем просто предоставление персональных данных, например, можно описывать
и просто организацию или какое-либо место. Те же самые принципы могут
быть использованы и при оформление персональных данных в формате
&lt;a href="/tag/xml/"&gt;XML&lt;/a&gt; - достаточно лишь использовать те же самые атрибуты
hCard для произвольных тэгов &lt;a href="/tag/xml/"&gt;XML&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В заключение хочу сказать, что в качестве источников информации для
данной статьи были использованы &lt;a href="https://www.insight-it.ru/goto/7ed2e6a8/" rel="nofollow" target="_blank" title="http://microformats.org/wiki/hcard"&gt;официальная вики&lt;/a&gt; и &lt;a href="https://www.insight-it.ru/goto/1161c09e/" rel="nofollow" target="_blank" title="http://www.xfront.com/microformats/hCard.html"&gt;презентация от Robert Costello&lt;/a&gt;, а подписаться на &lt;a href="/feed/"&gt;&lt;strong&gt;RSS&lt;/strong&gt;&lt;/a&gt; можно вот &lt;a href="/feed/"&gt;&lt;strong&gt;ТУТ&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sun, 13 Apr 2008 22:51:00 +0400</pubDate><guid>tag:www.insight-it.ru,2008-04-13:theory/2008/hcard/</guid><category>hcard</category><category>online</category><category>XHTML</category><category>интернет</category><category>Микроформаты</category><category>персональная информация</category></item><item><title>nofollow: за и против</title><link>https://www.insight-it.ru//theory/2008/nofollow-za-i-protiv/</link><description>&lt;p&gt;Наверняка каждый владелец любого интернет-ресурса хоть раз сталкивался с
этим микроформатом, &lt;a href="https://www.insight-it.ru/goto/a9b68873/" rel="nofollow" target="_blank" title="http://microformats.org/wiki/rel-nofollow"&gt;rel-nofollow&lt;/a&gt;. Изначально он был введен для обозначения ссылок, оставленных кем-либо, кроме создателя самой веб-страницы, и, как следствие. для снятие с него ответственности
за эту ссылку. Активнее всего этот микроформат влияет на работу
большинства поисковых систем, оказывая влияние на учет ссылок в
определении тех или иных параметров, присваиваемых страницам (Google
PageRank, например). В общем случае ссылки, помеченные атрибутом
&lt;code&gt;rel="nofollow"&lt;/code&gt;, из этого процесса исключаются.
&lt;!--more--&gt;
Но не все так однозначно, насчет этого микроформата сложилось масса
мнений, так как несмотря на свое, казалось бы, предназначение бороться
со спамом на форумах / блогах / социальных сетях / новостных порталах
(нужное подчеркнуть), направленным на создание входящих ссылок на тот
или иной ресурс, порой им злоупотребляют и используют там, где это было
бы излишним.&lt;/p&gt;
&lt;h3 id="protiv"&gt;Против&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;nofollow не в состоянии полностью предотвратить спам в ресурсах
    указанных выше типов;&lt;/li&gt;
&lt;li&gt;название "nofollow" лишь сбивает с толку, &lt;a href="/tag/crawler/"&gt;crawler&lt;/a&gt;'ы
    все равно следуют по таким ссылкам;&lt;/li&gt;
&lt;li&gt;nofollow порой вредит &lt;em&gt;естественным&lt;/em&gt; ссылкам на сайты, которые
    вполне заслуженно могли бы и получить свою входящую ссылку при
    расчете того же, например, PageRank;&lt;/li&gt;
&lt;li&gt;для использования простыми пользователями, этот микроформат
    абсолютно бесполезен;&lt;/li&gt;
&lt;li&gt;благодаря nofollow поисковые системы порой не в состоянии отличить
    ссылки на сайты добросовестных читателей ресурса от ссылок
    спаммеров;&lt;/li&gt;
&lt;li&gt;он препятствует возможности людей, оставляющих комментарии, привлечь
    внимание к какой-либо странице;&lt;/li&gt;
&lt;li&gt;если взглянуть со стороны поисковых систем, nofollow препятствует
    Сети выглядеть как сеть, в прямом смысле этого слова;&lt;/li&gt;
&lt;li&gt;единственные кто получают какую-либо пользу от этого микроформата -
    поисковые системы.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="za"&gt;За&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;но тем не менее, если ссылка размещается посетителем только ради
    влияния на позицию своего ресурса в поисковых системах, наличие
    &lt;code&gt;nofollow&lt;/code&gt; заставит его как минимум задуматься: а стоит ли?&lt;/li&gt;
&lt;li&gt;помимо поисковых систем, данный микроформат может служить
    инструментом вебмастера для организации более эффективной
    перелинковки страниц в рамках одного сайта;&lt;/li&gt;
&lt;li&gt;в недалеком будущем, возможно, движки сайтов смогут ставить атрибут
    &lt;code&gt;nofollow&lt;/code&gt; не на всех подряд ссылках, оставленных посетителями, а
    только на подозрительных с их точки зрения (которая могла бы
    определяться, допустим, средствами эвристического анализа);&lt;/li&gt;
&lt;li&gt;так как oформлен он в виде &lt;a href="/tag/mikroformaty/"&gt;микроформата&lt;/a&gt;, он не
    противоречит стандартам &lt;a href="/tag/xhtml/"&gt;XHTML&lt;/a&gt; и &lt;a href="/tag/html/"&gt;HTML&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Не смотря на множество спорных моментов, этот микроформат определенно
имеет свою скромную роль в жизни Сети. Использовать его или нет - дело
каждого, но по-моему если применять его в меру и только по прямому
назначению, то он только несомненно помогает развитию как Сети в целом,
так и конкретного ресурса в отдельности, особенно с точки зрения
эффективности взаимодействия с поисковыми системами.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sun, 24 Feb 2008 16:51:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-02-24:theory/2008/nofollow-za-i-protiv/</guid><category>crawler</category><category>nofollow</category><category>rel-nofollow</category><category>SEO</category><category>spider</category><category>Микроформаты</category><category>поисковые системы</category><category>принцип работы поисковых систем</category></item><item><title>Отношения online</title><link>https://www.insight-it.ru//theory/2008/otnosheniya-online/</link><description>&lt;p&gt;Допустим, у Вас появилось желание оставить на своем интернет-ресурсе
ссылку на сайт своего старого друга. Объяснить этот факт простому
читателю достаточно просто:
&lt;code&gt;&amp;lt;a&amp;nbsp;href="www.site.ru"&amp;gt;Сайт&amp;nbsp;моего&amp;nbsp;друга&amp;lt;/a&amp;gt;&lt;/code&gt;, но поймет ли такую
надпись очередной раз инспектирующий Ваш сайт &lt;a href="/tag/crawler/"&gt;crawler&lt;/a&gt;
какой-нибудь поисковой системы? Может быть Вы просто злостно торгуете
ссылками со своего сайта?
&lt;!--more--&gt;
Как Вы могли уже догадаться, для решения этой достаточно
узкоспециализированной задачи - выражение отношений с владельцем сайта,
на который указывает ссылка - существует специальный
&lt;a href="/tag/mikroformaty/"&gt;микроформат&lt;/a&gt; под названием &lt;a href="/tag/xfn/"&gt;&lt;strong&gt;XFN&lt;/strong&gt;&lt;/a&gt;, что расшифровывается как &lt;em&gt;XHTML Friends Network&lt;/em&gt;. С
его помощью любой человек, у которого есть сайт может продемонстрировать
всем желающим в каких отношениях он находится с владельцем сайта, на
который он ссылается.&lt;/p&gt;
&lt;p&gt;Реализуется этот микроформат с помощью атрибута &lt;code&gt;rel&lt;/code&gt; тэга &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;,
возможные варианты значения (имеется возможность их комбинировать):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Категории значений&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Значения XFN&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;дружба:&lt;/td&gt;
&lt;td&gt;&lt;code&gt;friend&lt;/code&gt;(кто-либо, кого Вы считаете другом),  &lt;code&gt;acquaintance&lt;/code&gt; (знакомый, просто пару раз здоровались или недолго общались), &lt;code&gt;contact&lt;/code&gt; (кто-либо, с кем Вы знаете как связаться в случае необходимости)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;физические:&lt;/td&gt;
&lt;td&gt;&lt;code&gt;met&lt;/code&gt; (кто-либо, с кем вы когда-то лично встречались)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;профессиональные:&lt;/td&gt;
&lt;td&gt;&lt;code&gt;co-worker&lt;/code&gt; (коллега по работе),&lt;code&gt;colleague&lt;/code&gt; (коллега по учебе или иной форме активности)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;географические:&lt;/td&gt;
&lt;td&gt;&lt;code&gt;co-resident&lt;/code&gt; (живете на одной улице),&lt;code&gt;neighbor&lt;/code&gt; (сосед)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;семейные:&lt;/td&gt;
&lt;td&gt;&lt;code&gt;child&lt;/code&gt; (ребенок, в том числе и приемный),&lt;code&gt;parent&lt;/code&gt; (родители, в том числе и приемные),&lt;code&gt;sibling&lt;/code&gt; (все братья и сетры),&lt;code&gt;spouse&lt;/code&gt; (муж/жена), &lt;code&gt;kin&lt;/code&gt; (дальний родственник)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;романтические:&lt;/td&gt;
&lt;td&gt;&lt;code&gt;muse&lt;/code&gt; (муза, источник вдохновения), &lt;code&gt;crush&lt;/code&gt; (кто-либо, к кому у Вас страстное увлечение), &lt;code&gt;date&lt;/code&gt; (кто-либо, с кем Вы встречаетесь), &lt;code&gt;sweetheart&lt;/code&gt; (кто-либо, в кого Вы влюбились"}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;личность:&lt;/td&gt;
&lt;td&gt;&lt;code&gt;me&lt;/code&gt; (ссылка на самого себя на другом сайте. Обязательно должна быть симметрична; отношение 'me' неявно подразумевается между поддиректорией и всем ее содержимым)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Как не трудно заметить, практически все возможные варианты отношений
могут быть описаны одним из значений или их комбинацией. Наш пример из
начала этого поста с использованием XFN выглядел бы:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"www.site.ru"&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;"friend&amp;nbsp;met"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    Сайт&amp;nbsp;моего&amp;nbsp;друга
&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Помимо этого есть еще один маленький нюанс, необходимый для того, чтобы
browser'ы и поисковые системы знали, что данная страница оффциально
поддерживает этот микроформат, для этого необходимо указать следующий
атрибут тэгу &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;head&lt;/span&gt; &lt;span class="na"&gt;profile=&lt;/span&gt;&lt;span class="s"&gt;"http://gmpg.org/xfn/11"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Этот пост был написан по мотивам &lt;a href="https://www.insight-it.ru/goto/faee6117/" rel="nofollow" target="_blank" title="http://www.gmpg.org/xfn/"&gt;официального сайта XFN&lt;/a&gt;, если Вас заинтересовал этот микроформат,
возможно имеет смысл посетить и его: там можно найти FAQ, утилиты для
автоматической генерации кода, а также всю остальную информацию по
данному микроформату (на английском естественно).&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sat, 16 Feb 2008 13:07:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-02-16:theory/2008/otnosheniya-online/</guid><category>online</category><category>xfn</category><category>XHTML</category><category>интернет</category><category>Микроформаты</category><category>семантика</category><category>Сеть</category><category>технология</category></item><item><title>Микроформаты</title><link>https://www.insight-it.ru//theory/2008/mikroformaty/</link><description>&lt;p&gt;&lt;img alt="Microformats" class="left" src="https://www.insight-it.ru/images/microformats.png" title="Microformats"/&gt;&lt;/p&gt;
&lt;p&gt;Не смотря на тот факт, что эта технология еще только начинает получать
широкое распространение и применение на просторах Сети, слов о ней уже
написано немало, не вижу ни одной причины почему бы мне тоже не написать
несколько слов о &lt;a href="https://www.insight-it.ru/goto/b960d7c/" rel="nofollow" target="_blank" title="http://microformats.org"&gt;микроформатах.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Основной идеей микроформатов является попытка дополнить смыслом
существующие элементы стандартов разметки - XHTML и HTML, такого рода
смысл нынче модно назвать словом &lt;em&gt;семантика&lt;/em&gt;, что так или иначе влияет
как на людей, пользующихся услугами Сети, так и на программы,
обслуживающие ее функционирование.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id="chto-predstavliaiut-soboi-mikroformaty"&gt;Что представляют собой микроформаты?&lt;/h3&gt;
&lt;p&gt;Строго говоря, микроформаты являются набором форматов данных,
основывающихся на существующих широкораспространенных стандартах
представления данных (в частности XHTML), каждый из них предназначен для
решения конкретной узкоспециализированной задачи, то есть для
обеспечения конкретной семантикой конкретной части стандарта.&lt;/p&gt;
&lt;p&gt;Как не трудно догадаться, измение существующих и добавление новых тэгов
к стандарту XHTML в микроформатах недопустимо, ведь иначе документ
перестанет соответствовать исходному стандарту. Именно по-этому для
реализации микроформатов используются атрибуты тэгов XHTML, в которых
допускаются некоторые вольности - &lt;strong&gt;rel&lt;/strong&gt; и &lt;strong&gt;class&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id="chto-zhe-mozhet-dat-osmyslennost-razmetki"&gt;Что же может дать осмысленность разметки?&lt;/h3&gt;
&lt;p&gt;В перспективе вся эта затея направлена на повышение качества сервисов,
предоставляемых в Сети. На данный момент большая часть сервисов,
основанных на анализе данных расположенных в Сети, способна лишь на
частичное использование разметки документа для уточнения смысла той или
иной информации. Показать это лучше всего на примере: тэги &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt; и
&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; говорят о том, что содержащаяся внутри них информация
имеет некий смысловой акцент, но в то же время многие другие тэги не
несут за собой никакой дополнительной смысловой информации, помимо
содержащегося внутри них текста. Одним из таких тэгов является
&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;, который говорит о наличии ссылки на некоторую
интернет-страницу, как-то связанную с текстом между открывающим и
закрывающим тэгами, а также расположенную по URL, указанному в атрибуте
&lt;code&gt;href&lt;/code&gt;, можно конечно к этому прибавить атрибут &lt;code&gt;title&lt;/code&gt;, но так или
иначе на этом информация о ресурсе, на который ссылается автор
документа, заканчивается. Один из микроформатов, позволяющих расширить
возможности простых ссылок, называется &lt;a href="https://www.insight-it.ru/goto/faee6117/" rel="nofollow" target="_blank" title="http://www.gmpg.org/xfn/"&gt;XFN&lt;/a&gt; и
предоставляет авторам документов возможность описать свое отношение к
другим авторам, на работы которых они ссылаются, выглядит это примерно
следующим образом:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"http://www.my-friend.ru"&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;"friend"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    Сайт моего друга
&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Теперь понять, что сайт, на который происходит ссылка, является сайтом
друга автора текущего документа, может не только читатель, но и
программа, занимающаяся индексированием страниц Сети для какого-либо
сервиса, например этот микроформат полезен для повышения качества работы
социальных сетей. Это была лишь небольшая часть возможностей
микроформата XFN, подробнее останавливаться на нем не буду - ведь каждый
из них явно заслуживает отдельной записи.&lt;/p&gt;
&lt;h3 id="klassifikatsiia"&gt;Классификация&lt;/h3&gt;
&lt;p&gt;Наверняка к Вам в голову приходила мысль: а почему необходимо
пользоваться именно вот этими микроформатами? Если в XHTML допускаются
любые значения тэгов &lt;code&gt;rel&lt;/code&gt; и &lt;code&gt;class&lt;/code&gt;, почему я не могу придумать
свои микроформаты и пользоваться ими? Ответ прост: микроформаты призваны
повысить качество Сети вцелом, а не какого-то конкретного сайта
отдельно. Только часть микроформатов получила широкое распространение, и
именно ими приходится пользоваться всем остальным сайтам под влиянием
&lt;em&gt;сетевого эффекта&lt;/em&gt; (т.е. того факта, что ценность технологии прямо
пропорциональна обширности ее применения, в нашем случае в рамках Сети),
просто чтобы быть совместимыми с остальной частью Интернета.&lt;/p&gt;
&lt;p&gt;Но не смотря на это - количество и разнообразие распространенных
микроформатов велико, и как-либо классифицировать их достаточно сложно.
Самым простым и точным вариантом можно назвать разделение по структуре
формата:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;элементарные&lt;/em&gt; - применимые только к одному конкретному типу тэгов.
    В эту группу попадают упомянутый выше &lt;strong&gt;XFN&lt;/strong&gt;, а также множество
    других, например &lt;em&gt;rel-tag&lt;strong&gt;, &lt;/strong&gt;rel-nofollow&lt;/em&gt;*, и так далее;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;композитные (или составные)&lt;/em&gt; - имеют более сложную структуру, и для
    своей реализации требуют модификации нескольких тэгов одного
    элемента. Микроформаты из этой категории предназначены для описания
    более сложной структуры, например &lt;strong&gt;hCard&lt;/strong&gt;, используемый для
    описания людей или организаций (можно посмотреть на пример его
    использования &lt;a href="https://www.insight-it.ru/author/"&gt;на моей странице "О себе"&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Это пожалуй единственный общепринятый тип классификации микроформатов,
можно конечно попытаться провести границы по типам используемых
атрибутов или модифицируемых тэгов, но такого рода классификации
несущественны и не являются широко распространенными.&lt;/p&gt;
&lt;h3 id="primenenie-na-praktike"&gt;Применение на практике&lt;/h3&gt;
&lt;p&gt;Вариантов их применения на сегодняшний день не так уж и много. Как я уже
упоминал, эта технология еще находится лишь на пути к получению
повсеместной распространенности на просторах Сети, но уже сейчас они
проявили себя достаточно, чтобы оказывать влияние на многие аспекты сети
Интернет:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Многие поисковые системы активно используют при составлении своего
    индекса микроформат &lt;strong&gt;rel-nofollow&lt;/strong&gt;, об этом мне уже &lt;a href="https://www.insight-it.ru/theory/2008/putevoditel-dlya-robotov/"&gt;доводилось
    упоминать в одной из предыдущих
    записей&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;Plug-in для Firefox под названием
    &lt;a href="https://www.insight-it.ru/goto/c84adfbb/" rel="nofollow" target="_blank" title="https://addons.mozilla.org/en-US/firefox/addon/4106"&gt;&lt;em&gt;Operator&lt;/em&gt;&lt;/a&gt; -
    позволяет просматривать используемые на текущей странице
    микроформаты, а также предлагает небольшой ассортимент действий, с
    ними связанных. Например, &lt;strong&gt;hCard&lt;/strong&gt; предлагается экспортировать в
    адресную книгу, а для &lt;strong&gt;rel-tag&lt;/strong&gt; - осуществить поиск по скромному
    списку интернет-сервисов. &lt;img alt="Operator screenshot" class="right" src="https://www.insight-it.ru/images/firefox-operator.png" title="Operator menu"/&gt;
    Лично я уже достаточно его себе установил и всегда держу включенным,
    не для того, чтобы реально им пользоваться, а просто чтобы быть в
    курсе, что тот или иной ресурс вдруг начал поддерживать эту
    замечательную технологию;&lt;/li&gt;
&lt;li&gt;Появляется все больше и больше CMS, поддерживающих различные
    микроформаты "из коробки" или с помощью plug-in'ов, что ведет к все
    более активному расширению списка сайтов, следующих этим стандартам
    представления данных. &lt;a href="https://www.insight-it.ru/goto/92e8fc22/" rel="nofollow" target="_blank" title="http://wordpress.org"&gt;WordPress&lt;/a&gt;, &lt;del&gt;на которой работает этот блог&lt;/del&gt;, тоже относится к категории CMS, поддерживающих
    микроформаты, в чем вы можете убедиться, установив упомянутый в
    предыдущем пункте &lt;em&gt;Operator&lt;/em&gt;. Сам по себе этот факт какой-либо
    полезности не несет, но является лишним стимулом для разработчиков
    программного обеспечения и интернет-ресурсов, поддерживающих
    микроформаты.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Этот список можно было бы продолжать еще достаточно долго, так что
позволю себе остановиться, ограничившись лишь перечислением наиболее
актуальных с моей точки зрения аспектов применения микроформатов.&lt;/p&gt;
&lt;h3 id="podvodim-itogi"&gt;Подводим итоги&lt;/h3&gt;
&lt;p&gt;По сути являясь своеобразной "надстройкой" над XHTML, микроформаты
создаются по принципу "чем проще - тем лучше", но в то же время
благодаря своей узкой специализации и простоте, каждый из них способен
быть составной частью модульной структуры форматов данных, способной
поднять Сеть на качественно новый уровень развития.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sun, 27 Jan 2008 19:31:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-01-27:theory/2008/mikroformaty/</guid><category>hcard</category><category>hreview</category><category>html</category><category>xfn</category><category>XHTML</category><category>интернет</category><category>Микроформаты</category><category>семантика</category><category>смысл</category><category>технология</category></item><item><title>Путеводитель для роботов</title><link>https://www.insight-it.ru//theory/2008/putevoditel-dlya-robotov/</link><description>&lt;p&gt;Ни для кого не секрет, что одним их основных факторов, влияющих на
расположение страниц интернет-ресурса на просторах поисковых систем,
является уникальность контента (или другими словами - содержания).
Конечно же простейшим способом избежать дублирующегося контента является
просто собственноручная его генерация (или в крайнем случае с помощью
наемных работников или посетителей Вашего сайта). Но, к сожалению, это
позволяет избежать лишь повторов между разными сайтами. Помимо этого
свою роль играют и повторы в рамках одного сайта. Наверняка Вы замечали,
что многие CMS размещают один и тот же текст на разных страницах сайта:
например на обычной странице, в RSS-ленте и каком-нибудь архиве.&lt;/p&gt;
&lt;p&gt;Именно для решения этой маленькой проблемы и была создана технология под
названием &lt;strong&gt;Robots Exclusion Protocol&lt;/strong&gt;. С ее помощью можно
минимизировать возможность повторов содержимого, проиндексированного
поисковыми системами в рамках одного сайта, а также исключить из индекса
неинформативные страницы.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Надеюсь, что Вы представляете себе в чем заключается принцип работы
поисковых систем, но в любом случае не вижу причин для того чтобы не
рассказать вкратце об этом. Помимо собственно сайта, где пользователи
вводят ключевую фразу для поиска, любая поисковая система имеет еще две
части: базу данных (другими словами - индекс сайтов) и специальной
программы (которую чаще всего называют &lt;em&gt;пауком&lt;/em&gt; или по-английски -
&lt;em&gt;crawler&lt;/em&gt; или &lt;em&gt;spider&lt;/em&gt;, но иногда используется более общий термин -
&lt;em&gt;робот&lt;/em&gt;). Эта программа запущена на серверах поисковых систем во
множестве экземпляров и основной целью их работы является пополнение и
обновления индекса поисковой системы. Сам же сайт лишь делает выборку из
индекса в соответствии с запросом и сортирует результат.&lt;/p&gt;
&lt;p&gt;Принцип работы такого класса программ я уже упоминал в &lt;a href="https://www.insight-it.ru/security/2008/otkuda-voznikaet-spam-i-kak-s-nim-borotsya/" title="Откуда возникает спам и как с ним бороться"&gt;записи о борьбе со спамом&lt;/a&gt;,
так что повторюсь лишь вкратце в надежде, что Вы ее уже читали: они
перемещаются по просторам Сети следуя по гиперссылкам, и на каждой
странице, куда они попадают, стараются выполнить заранее определенное
действие, в нашем случае - проиндексировать ее.&lt;/p&gt;
&lt;p&gt;Обсуждаемая нами технология дает возможность веб-мастеру предоставить
crawler'ам, образно говоря, &lt;em&gt;путеводитель&lt;/em&gt; по его сайту. Методов для
этого имеется несколько:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Любой crawler прежде чем перейти на новый домен проверяет
    существование файла по адресу &lt;code&gt;http://www.некий-домен.ru/robots.txt&lt;/code&gt;.
    В таком файле веб-мастер может разместить директивы для
    потенциальных компьютеризированных посетителей в соответствии с
    &lt;a href="https://www.insight-it.ru/goto/32ecd79a/" rel="nofollow" target="_blank" title="http://www.robotstxt.org/norobots-rfc.txt"&gt;соответствующим стандартом&lt;/a&gt;. Если поисковый робот обнаруживает этот файл, то прочитав его он
    корректирует свой маршрут обхода всего интернет-ресурса в
    соответствии с указанными директивами.&lt;/li&gt;
&lt;li&gt;Внутри заголовка любой HTML-страницы или любого другого документа,
    передаваемого по http протоколу (с помощью заголовков самого
    протокола), можно разместить специальный meta-tag для роботов,
    который также должен соответствовать &lt;a href="https://www.insight-it.ru/goto/fef0ecbb/" rel="nofollow" target="_blank" title="http://www.robotstxt.org/meta.html"&gt;стандарту, опубликованному в 1996 году&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Основной частью &lt;em&gt;путеводителя&lt;/em&gt; чаще всего является карта &lt;a href="https://www.insight-it.ru/goto/9821991b/" rel="nofollow" target="_blank" title="http://sitemaps.org/"&gt;сайта в формате XML&lt;/a&gt;. С ее помощью программа может
    быстро определить весь ассортимент страниц, которые ей было бы
    неплохо проиндексировать.&lt;/li&gt;
&lt;li&gt;Самым последним был воплощен в жизнь метод, основанный на
    &lt;a href="https://www.insight-it.ru/goto/a9b68873/" rel="nofollow" target="_blank" title="http://microformats.org/wiki/rel-nofollow"&gt;микроформатах&lt;/a&gt;.
    Реализуется он с помощью параметра &lt;code&gt;rel="nofollow"&lt;/code&gt;, указанного
    внутри тэга &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;, который обозначает ссылку, не предназначенную для
    перехода по ней пауком.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Карты сайтов и директивы robots.txt предназначены для определения
маршрута путешествия crawler'а, в то время как микроформаты и
meta-тэги - для влияния на сам процесс индексации.&lt;/p&gt;
&lt;p&gt;У каждого из описанных выше методов есть своя узкая специализация:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;robots.txt предоставляет базовый набор директив для роботов, которым
    они следуют даже в случае конфликтов с другими использованными
    методами.&lt;/li&gt;
&lt;li&gt;Карта сайта влияет на последовательность и набор страниц, посещенных
    пауком, с помощью указания приоритетов страниц или времени последней
    модификации.&lt;/li&gt;
&lt;li&gt;Мета-тэги распространяют свое действие на весь документ и влияет на
    индексирование страниц (если они одновременно присутствуют как в
    заголовке (X)HTML документа, так и в заголовках &lt;code&gt;X-Robots-Tags&lt;/code&gt;
    HTTP-протокола, то приоритет считается выше у заголовков протокола).&lt;/li&gt;
&lt;li&gt;Микроформаты позволяют в случае необходимости переопределять
    параметры любого конкретного тэга документа, не смотря на указания в
    мета-тэгах.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;С синтаксисом robots.txt лучше всего ознакомиться прямо в
соответствующей спецификации, ссылку на которую я уже приводил (хотя
возможно в будущем я всетаки соберусь написать запись и по этому
поводу). Не знаю занимается ли кто-нибудь генерацией карт сайта вручную,
но для общего развития будет полезно изучить и ее формат, неплохим
примером может послужить &lt;a href="/sitemap.xml" title="XML Sitemap"&gt;XML-карта этого блога&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Fri, 18 Jan 2008 01:13:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-01-18:theory/2008/putevoditel-dlya-robotov/</guid><category>crawler</category><category>robots exclusion protocol</category><category>robots.txt</category><category>SEO</category><category>spider</category><category>интернет</category><category>информационные технологии</category><category>поисковые системы</category><category>принцип работы поисковых систем</category><category>технология</category></item><item><title>Мы делаем новости!</title><link>https://www.insight-it.ru//theory/2008/my-delaem-novosti/</link><description>&lt;p&gt;&lt;a href="/feed/"&gt;&lt;img alt="RSS Logo." class="right" src="https://www.insight-it.ru/images/rss.png" title="Логотип RSS"/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Ярко-рыжий логотип, который можно увидеть на практически любом сайте,
наверняка не раз привлекал Ваше внимание. Если Ваше любопытство хоть раз
заставляло Вас перейти по ссылке, которая чаще всего стоит за таким
логотипом, то Вы наверняка уже успели представить себе о чем пойдет
речь.&lt;/p&gt;
&lt;p&gt;Такая ссылка в подавляющем большинстве случаев ведет на новости сайта,
на котором она расположена, представленные в формате представления
данных под названием RSS (хотя это даже не обязательно должны быть
новости в обычном понимании этого слова, с помощью этого формата можно
публиковать любой контент). Этот формат предоставляет пользователям
возможность подписываться на &lt;em&gt;каналы&lt;/em&gt; новостей с помощью специально
предназначенных для этого программ - &lt;em&gt;аггрегаторов&lt;/em&gt;, позволяя иметь
быстрый и удобный доступ ко всем интересующим его/ее информационным
ресурсам, без необходимости собственно посещать все эти сайты.&lt;/p&gt;
&lt;p&gt;О процессе создания такого канала я и хочу Вам рассказать.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Конечно же многие CMS поддерживают автоматическую генерацию RSS-каналов,
и &lt;a href="https://www.insight-it.ru/goto/f4bdda87/" rel="nofollow" target="_blank" title="http://www.wordpress.org"&gt;WordPress&lt;/a&gt;, &lt;del&gt;на которой работает этот
блог&lt;/del&gt;, к ним относится. &lt;a href="/feed/"&gt;RSS-канал этого блога&lt;/a&gt;, хоть и
не является новостным по сути, но также прекрасно генерируется из постов
блога. Но для того, чтобы работать с технологией обычно бывает не лишним
понимать как она работает, по-этому в этой записи я поведаю Вам о ручном
составлении RSS-канала, а в одной из последующих - об автоматической
генерации.&lt;/p&gt;
&lt;p&gt;Прежде всего стоит сказать, что RSS является методом, основанным на XML
и предназначенным для оперативного распространения новостей и контента
сайта как среди потенциальных читателей, так и среди других сайтов.&lt;/p&gt;
&lt;p&gt;Как следствие, на RSS распространяются все &lt;a href="https://www.insight-it.ru/theory/2008/9-osnovnyx-pravil-napisaniya-xml/"&gt;правила написания XML-документов&lt;/a&gt;, с которыми имеет смысл ознакомиться перед тем, как продолжить чтение этой записи. Помимо них, для RSS существует отдельный стандарт и соответственно набор не менее простых правил.&lt;/p&gt;
&lt;p&gt;В качестве примера можно использовать любой понравившийся канал,
например мой. Для того, чтобы увидеть сам текст документа, необходимо
нажать правой кнопкой мыши на открытый в браузере документ и выбрать
пункт, называющийся как-нибудь вроде "Просмотр исходного кода страницы"
или "View Page Source".&lt;/p&gt;
&lt;p&gt;По сравнению с XML, RSS-документ должен обладать четко определенной
структурой:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;За стандартным XML-заголовком открывается корневой элемент &lt;code&gt;&amp;lt;rss&amp;gt;&lt;/code&gt;,
    содержащий указание версии RSS&lt;/li&gt;
&lt;li&gt;В корневой элементе должен должен содержаться ровно один элемент
    &lt;code&gt;&amp;lt;channel&amp;gt;&lt;/code&gt;, символизирующий наш канал&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Внутри &lt;code&gt;&amp;lt;channel&amp;gt;&lt;/code&gt; обязательно должны содержаться три элемента:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; - заголовок канала&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; - ссылка на сам сайт&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;description&amp;gt;&lt;/code&gt; - описание канала&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Помимо них он должен содержать один или несколько элементов
    &lt;code&gt;&amp;lt;item&amp;gt;&lt;/code&gt;, которые будут обозначать одну конкретную новость,
    запись, пост, статью, заметку, не важно какое из этих слов больше
    подходит к каждому конкретному случаю - суть от этого не меняется.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Элементы между парой тэгов &lt;code&gt;&amp;lt;item&amp;gt;&lt;/code&gt;, как ни странно, тоже должны
    в себя включать в себя волшебно-обязательные элементы, разница лишь
    в значении, которое им придается:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; - заголовок новости-записи-поста-статьи-заметки&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; - ссылка на нее же, обычно на страницу внутри сайта&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;description&amp;gt;&lt;/code&gt; - собственно говоря сам текст&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Пример:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8" ?&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;rss&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;channel&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Insight IT&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;description&amp;gt;&lt;/span&gt;Блог об информационных технологиях&lt;span class="nt"&gt;&amp;lt;/description&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;link&amp;gt;&lt;/span&gt;https://www.insight-it.ru&lt;span class="nt"&gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;lastBuildDate&amp;gt;&lt;/span&gt;Sun, 07 Jan 2008 23:42:01 +0000&lt;span class="nt"&gt;&amp;lt;/lastBuildDate&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;pubDate&amp;gt;&lt;/span&gt;Sun, 07 Jan 2008 23:42:01 +0000&lt;span class="nt"&gt;&amp;lt;/pubDate&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;ttl&amp;gt;&lt;/span&gt;1800&lt;span class="nt"&gt;&amp;lt;/ttl&amp;gt;&lt;/span&gt;

 &lt;span class="nt"&gt;&amp;lt;item&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Мы делаем новости!&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;description&amp;gt;&lt;/span&gt;Ярко-рыжий логотип, который можно увидеть на практически любом сайте, наверняка не раз привлекал Ваше внимание.&lt;span class="nt"&gt;&amp;lt;/description&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;link&amp;gt;&lt;/span&gt;http://www.insight-it.ru/?p=18&lt;span class="nt"&gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;guid&lt;/span&gt; &lt;span class="na"&gt;isPermaLink=&lt;/span&gt;&lt;span class="s"&gt;"true"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;7bd204c6-1655-4c27-aeee-53f933c5395f&lt;span class="nt"&gt;&amp;lt;/guid&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;pubDate&amp;gt;&lt;/span&gt;Sun, 07 Jan 2008 23:42:01 +0000&lt;span class="nt"&gt;&amp;lt;/pubDate&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;

&lt;span class="nt"&gt;&amp;lt;/channel&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/rss&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Перечисленного выше вполне достаточно для написания простейшего
RSS-канала, но возможности RSS далеко выходят за рамки просто размещения
в Сети текстовых сообщений. Для их реализации стандартом предусмотрен
еще целый ряд тэгов,&amp;nbsp; доступных для использования. Позволю себе привести
краткую справку по основным из них (для полноты картины повторю
обязательные):&lt;/p&gt;
&lt;h4&gt;Дочерние элементы &lt;channel&gt;&lt;/channel&gt;&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Элемент&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Описание&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;category&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Не обязателен, определяет одну или несколько категорий для канала, позволяет &lt;em&gt;аггрегаторам&lt;/em&gt; группировать записи по этому параметру&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;cloud&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Не обязателен, используется для осуществления об обновлении канала с помощью технологии RPC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;copyright&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Опционально, предназначен для предупреждения о необходимости соблюдения авторских прав&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;description&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Обязательное описание канала&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;docs&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Необязательная ссылка на описания формата, использованного в данном канале&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;generator&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Указание программы, сгенерировавшей канал, обычно они сами заполняют этот тэг. В случае заполнения вручную он вообще не нужен&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Опциональное отображение логотипа канала в &lt;em&gt;аггрегаторе&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;language&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Определяет язык, на котором написано содержимое канала. Не обязательно, но желательно&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;lastBuildDate&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Время последнего обновления содержимого канала. Опционально.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Обязательная ссылка канала&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;managingEditor&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Адрес электронной почты редактора канала, не обязателен.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;pubDate&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Опциональная дата последней публикации на канале&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;rating&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Опциональный PICS рейтинг канала&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;skipDays&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Количество дней, которые аггрегатор должен пропускать между проверкой обновлений канала&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;skipHours&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;По аналогии с предыдущим, только в часах&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;textInput&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Определяет текстовое поле, которое может отображаться рядом с каналом. Не обязательно.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Обязательная тема канала&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;ttl&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Время в минутах, в течении которого канал может отображаться из кэша &lt;em&gt;аггрегатора&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;webMaster&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Адрес электронной почты веб-мастера, не обязательно.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;Дочерние элементы &lt;item&gt;&lt;/item&gt;&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Элемент&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Описание&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;author&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Название говорит само за себя - автор, указывать не обязательно&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;category&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Категория или категории, куда можно отнести запись. Опционально&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;comments&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Ссылка на комментарии к записи. Опционально.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;description&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Обязательное описние записи, то есть само ее содержание&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;enclosure&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Существует возможность по желанию сопровождать запись ссылкой на меда-файл так или иначе с ней связанный&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;guid&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Уникальный идентификатор элемента&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Обязательная ссылка записи&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;pubDate&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Дата публкации. Не обязательно.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;source&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Опциональная ссылка на внешний источник записи&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Обязательный заголовок записи&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Более подробно о каждом из них можно узнать, ознакомившись со
&lt;a href="https://www.insight-it.ru/goto/aa3956d6/" rel="nofollow" target="_blank" title="http://cyber.law.harvard.edu/rss/rss.html"&gt;спецификацией на английском&lt;/a&gt;. Напоследок хочу напомнить, что вся эта запись представлена лишь для общего понимания принципов организации RSS-документа. На практике в большинстве случаев такие документы генерируются автоматически, о чем и пойдет речь в одной из последующих записей.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Mon, 07 Jan 2008 23:42:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-01-07:theory/2008/my-delaem-novosti/</guid><category>RSS</category><category>XML</category><category>аггрегатор</category><category>новости</category><category>Сеть</category><category>технология</category><category>хранение данных</category></item><item><title>9 основных правил написания XML</title><link>https://www.insight-it.ru//theory/2008/9-osnovnyx-pravil-napisaniya-xml/</link><description>&lt;p&gt;Правила написания XML являются в равной степени простыми и строгими, что
делает как ручное составление XML документов, так и написание программ,
умеющих анализировать и генерировать XML документы, достаточно
несложными задачами. Помимо этого, правильно написанный документ в этом
формате говорит сам за себя - прочитав его не трудно понять о чем речь.&lt;/p&gt;
&lt;p&gt;В этой записи я планирую перечислить и объяснить все 9 правил, с
использованием примеров.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;В качестве примера будет использован следующий XML документ, описывающий
книгу:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8" ?&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;book&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;title&lt;/span&gt; &lt;span class="na"&gt;subtitle=&lt;/span&gt;&lt;span class="s"&gt;"The Dark Elf Trilogy"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Sojourn&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;author&amp;gt;&lt;/span&gt;R. A. Salvatore&lt;span class="nt"&gt;&amp;lt;/author&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;chapter&amp;gt;&lt;/span&gt;Well met&lt;span class="nt"&gt;&amp;lt;/chapter&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/book&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Не правда ли легко понять, что речь идет именно о книге?&lt;/p&gt;
&lt;h4&gt;Теперь самое подходящее время перейти непосредственно к правилам оформления документов.&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Документ должен начинаться с определения типа документа,&lt;/strong&gt;
    содержащее указание версии XML (в нашем случае - 1.0) и кодировку
    символов (соответственно - UTF-8)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Должен содержать ровно один корневой элемент&lt;/strong&gt; - в нашем пимере
    это &lt;code&gt;&amp;lt;book&amp;gt; &amp;lt;/book&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Каждому открывающему тэгу должен соответствовать один
    закрывающий.&lt;/strong&gt; Как не трудно заметить это правило соблюдается в
    примере, если Вы привыкли в HTML оставлять тэги открытыми примерно
    следующим образом: &lt;code&gt;&amp;lt;p&amp;gt;Какой-то текст&lt;/code&gt;, то изучение XML может стать неплохим поводом отучиться от этой
    вредной привычки.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;XML тэги чувствительны к регистру символов.&lt;/strong&gt; Тэги &lt;code&gt;&amp;lt;Book&amp;gt;&lt;/code&gt; и
    &lt;code&gt;&amp;lt;book&amp;gt;&lt;/code&gt; считаются разными, запись &lt;code&gt;&amp;lt;Book&amp;gt; &amp;lt;/book&amp;gt;&lt;/code&gt; будет
    считаться ошибочной.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Тэги должны быть расположены строго друг внутри друга.&lt;/strong&gt;
    Продемонстрирую на отдельном примере: &lt;code&gt;&amp;lt;foo&amp;gt;ВЕ&amp;lt;bar&amp;gt;РНО&amp;lt;/bar&amp;gt;&amp;lt;/foo&amp;gt;&lt;/code&gt;, а так &lt;code&gt;&amp;lt;foo&amp;gt;НЕВЕ&amp;lt;bar&amp;gt;РНО&amp;lt;/foo&amp;gt;&amp;lt;/bar&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Значения всех атрибутов всегда должны быть заключены в кавычки.&lt;/strong&gt;
    Например: &lt;code&gt;&amp;lt;title subtitle="The Dark Elf Trilogy"&amp;gt;Sojourn&amp;lt;/title&amp;gt;&lt;/code&gt; - верно, а &lt;code&gt;&amp;lt;title subtitle=The Dark Elf Trilogy&amp;gt;Sojourn&amp;lt;/title&amp;gt;&lt;/code&gt; - нет.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Последовательно расположенные пробелы не объединяются в один.&lt;/strong&gt;
    Имейте это ввиду, если вы привыкли к HTML.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Конец строки обозначается просто переводом на новою строку, без возврата каретки.&lt;/strong&gt; Во многих приложениях для обозначения конца
    строки используется возврат каретки совместно с переводом на новую
    строку (&lt;code&gt;/r/n&lt;/code&gt;), в XML же принято для
    этих целей использовать просто перевод на новую строку
    (&lt;code&gt;/n&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Комментарии обозначаются так же как и в HTML:&lt;/strong&gt;
&lt;code&gt;&amp;lt;!--комментарий--&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Как Вы могли уже убедиться этот формат оформления данных представляет
собой всего лишь текст, разбавленный некоторым количеством тэгов и
следующий простым правилам. Не стоит ожидать от него чего-то большего.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sun, 06 Jan 2008 21:53:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-01-06:theory/2008/9-osnovnyx-pravil-napisaniya-xml/</guid><category>markup</category><category>XML</category><category>описание данных</category><category>хранение данных</category></item><item><title>Что такое XML?</title><link>https://www.insight-it.ru//theory/2008/chto-takoe-xml/</link><description>&lt;p&gt;Если Вам интересен ответ на этот вопрос, то Вам сюда!&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Ответ на вопрос, заявленный в теме прост до безобразия. Сама
аббревиатура XML расшифровывается как e&lt;strong&gt;X&lt;/strong&gt;tensible &lt;strong&gt;M&lt;/strong&gt;arkup
&lt;strong&gt;L&lt;/strong&gt;anguage, из чего логически вытекает все остальное.&lt;/p&gt;
&lt;p&gt;Как и HTML он является &lt;em&gt;языком разметки&lt;/em&gt;, но в отличии от HTML, XML
предназначен для других целей: он был разработан для &lt;em&gt;описания и
хранения данных&lt;/em&gt;, когда HTML в основном сосредоточен на определении
того, как данные будут отображаться на экране. Еще одним основным
отличием является тот факт, XML нет предопределенных тэгов, Вы должны
сами определять какие тэги будете использовать.&lt;/p&gt;
&lt;p&gt;XML может использоваться для хранения практически любых типов данных, а
его расширяемость позволяет ограничивать варианты его использования лишь
фантазией разработчиков. Вот некоторые из них:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;В совокупности с технологией XSL или CSS данные, хранящиеся в XML
    могут быть представлены как простая веб-страница&lt;/li&gt;
&lt;li&gt;XML являться форматом обмена данными между несовместимыми системами,
    так как он не зависит ни от программного обеспечения, ни от
    оборудования, на котором хранятся данные&lt;/li&gt;
&lt;li&gt;XML может не просто хранить данные, но и дать понять что же эти
    данные значат&lt;/li&gt;
&lt;li&gt;На базе XML может быть построено множество других технологии, из уже
    получивших широкое распространение можно назвать RSS, WAP и WML.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Одними из самых наглядных способов увидеть что же из себя представляет
XML - являются &lt;a href="/feed"&gt;RSS лента&lt;/a&gt; и &lt;a href="/sitemap.xml"&gt;карта сайта в XML&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sun, 06 Jan 2008 20:18:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-01-06:theory/2008/chto-takoe-xml/</guid><category>markup</category><category>XML</category><category>описание данных</category><category>разметка</category><category>хранение данных</category></item><item><title>Три основных компонента парадигмы объектно-ориентированного программирования</title><link>https://www.insight-it.ru//theory/2008/tri-osnovnyx-komponenta-paradigmy-obektno-orientirovannogo-programmirovaniya/</link><description>&lt;p&gt;Представьте: Россия, солнце только-только начинает свой путь по
бескрайним просторам неба, Вы находитесь на одной из самых оживленных
улиц своего города и вокруг Вас нетрудно заметить множество людей,
спешащих по своим делам. И вот, Вы видите как один человек зашел в
большое офисное здание.&lt;/p&gt;
&lt;p&gt;Вы спросите у меня: как это все может быть связано с темой этой
записи? - об этом я и собираюсь Вам поведать.&lt;/p&gt;
&lt;!--more--&gt;
&lt;div class="card blue lighten-4"&gt;
&lt;p&gt;&lt;div class="card-content"&gt;Перед тем как продолжить чтение этой записи, очень рекомендую сначала ознакомиться с &lt;a href="https://www.insight-it.ru/theory/2008/obektno-orientirovannoe-programmirovanie-a-chto-zhe-eto/"&gt;введением в объектно-ориентированное програмирование&lt;/a&gt;, если Вы еще не успели этого сделать.
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img alt="Три основных компонента" class="right" src="https://www.insight-it.ru/images/cubes.png"/&gt;&lt;/p&gt;
&lt;p&gt;Человек, которого Вы, надеюсь, успешно представили в процессе прочтения
вступления к этой записи, будет служить нам примером в процессе
обсуждения трех базовых вещей, на которых основывается вся концепция
&lt;strong&gt;ООП&lt;/strong&gt;, которые имеет смысл сразу обозначить прямо сейчас:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;наследование&lt;/li&gt;
&lt;li&gt;инкапсуляция&lt;/li&gt;
&lt;li&gt;полиморфизм&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Все они являются равнозначными и перечислены они просто в порядке их
упоминания в этом посте. Но прежде чем перейти к их рассмотрению по
отдельности было бы не лишним несколько конкретизировать пример,
упомянутый чуть выше. Основной акцент в этой записи делается на теорию,
но для упрощения понимания я буду стараться приводить элементарные
примеры реализации на языке &lt;em&gt;Java&lt;/em&gt; (выбранный как наиболее характерный
представитель языков программирования, приспособленных для ООП), которые
правда будут лишь иллюстрировать повествование, но не будут нести за
собой никакой практической пользы.&lt;/p&gt;
&lt;p&gt;Для начала можно рассматривать этого человека просто "со стороны": с
этой точки зрения можно определить его рост, возраст, пол, цвет волос и
глаз, и возможно какие-либо внешние признаки. Помимо этого можно
предположить, что он обладает элементарными навыками, которые он успел
продемонстрировать, проходя мимо Вас: он умеет ходить и еще, видимо,
работать, правда не ясно кем.&lt;/p&gt;
&lt;p&gt;Теперь посмотрим на него, как на объект, который необходимо
смоделировать внутри программы. Внешние данные, перечисленные в
предыдущем абзаце, станут &lt;em&gt;состоянием&lt;/em&gt;, которое необходимо будет описать
примерно следующим образом в описании класса, экземпляром которого и
будет впоследствии являться наш человек:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Human&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// рост&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// возраст&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;gender&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// пол&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;eyesColor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// цвет глаз&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;hairColor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// цвет волос&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Помимо этого мы говорили о его навыках, которые тоже необходимо здесь же
упомянуть, для простоты не будем ничего сложного придумывать в плане
реализации:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Human&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// рост&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// возраст&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;gender&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// пол&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;eyesColor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// цвет глаз&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;hairColor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// цвет волос&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;walk&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я иду!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю в большом офисном здании"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Пожалуй этого будет достаточно для перехода собственно к обсуждению
первого из трех компонентов парадигмы.&lt;/p&gt;
&lt;h3 id="nasledovanie"&gt;Наследование&lt;/h3&gt;
&lt;p&gt;В отличии от реальной жизни, в рамках данной концепции наследование
относится не к материальным вещам, а к переменным и методам класса. Тот
класс, который передает "наследство", принято называть &lt;strong&gt;базовым&lt;/strong&gt;, а
получателя "наследства", соответственно - &lt;strong&gt;наследующим&lt;/strong&gt;. Наследующий
класс в дополнение к собственным методам и переменным получает еще и
полный доступ ко всем переменным и методам базового класса (за некоторым
исключением, о котором пойдет речь при разговоре об инкапсуляции, но обо
всем по порядку).&lt;/p&gt;
&lt;p&gt;Для иллюстрации этого механизма предлагаю предположить кем же мог
работать наш человек. Для примера возьмем три варианта: менеджер,
программист и директор. Менеджер будет уметь командовать подчиненными,
программист писать код, а директор - ничего не делать. но не будем
забывать, что человек, обладающий каждой из этих трех профессий, все же
остается просто человеком и может выполнять все стандартные действия,
которые мог бы выполнять обычный безработный, и обладать теми же
признаками.&lt;/p&gt;
&lt;p&gt;Конечно же можно было бы написать для каждой из профессии класс, просто
добавив по одному методу, это выглядело бы примерно так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Director&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// рост&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// возраст&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;gender&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// пол&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;eyesColor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// цвет глаз&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;hairColor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// цвет глаз&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;walk&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я иду!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю в большом офисном здании"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;idle&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я ничего не делаю!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Но такой подход годится только для людей даже краем уха не слышавших об
ООП, ведь он далеко не самый эффективный, особенно с точки зрения
затрачиваемого на написание кода времени. Воспользовавшись механизмом
наследования, можно сократить как объем кода, так и время, затраченное
на его написание. В используемом для примеров языке программирования
Java, для этого достаточно лишь указать в заголовке наследующего класса
ключевое слово &lt;em&gt;extends&lt;/em&gt; и название базового класса. Аналогичный
предыдущему класс с использованием этого механизма существенно
упрощается:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Director&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;idle&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я ничего не делаю!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Как не трудно заметить объем кода существенно сократился, но это далеко
не единственное преимущество. Помимо этого, например, если появится
необходимость произвести изменения во всех профессиях - нужно будет
произвести их один раз в базовом классе, а не три раза, как было бы в
случае не использования наследования. А в некоторых случаях базовый
класс может быть уже написан разработчиками языка программирования и для
того чтобы им воспользоваться останется лишь написать пару волшебных
слов.&lt;/p&gt;
&lt;h3 id="polimorfizm"&gt;Полиморфизм&lt;/h3&gt;
&lt;p&gt;Это слово пришло к нам из греческого языка, понимания этого термина
легко достичь, просто переведя его на русский язык: &lt;code&gt;&amp;pi;&amp;omicron;&amp;lambda;ύ&amp;mu;&amp;omicron;&amp;rho;&amp;phi;&amp;omicron;&amp;sigmaf;&lt;/code&gt; - многоформенность. То есть в наиболее
простом случае подразумевается использование одной и той же переменной
(или массива) для хранения информации об объектах, описываемых разными
классами. Представим, что нам необходим стандартизованный способ узнать
кем же работает тот или иной человек, естественно для этого необходимо
описание соответствующего метода для выполнения этой функции в каждом
классе, причем он должен одинаково называться в каждом из них. Для
реализации этого примера на языке Java нет необходимости использовать
дополнительных ключевых слов (в отличие от, например, C#, где
необходимо использование слова virtual в заголовке метода в базовом
классе и override - в производных). Продолжая приводить примеры на Java
имеем три производных класса (для упрощения опустим дополнительные
методы, которые могли бы присутствовать):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Director&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю директором!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Programmer&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю программистом!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Manager&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю менеджером!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Для того, чтобы воспользоваться механизмом полиморфизма достаточно лишь
написать функцию, которая будет создавать экземпляры наших классов и
"спрашивать" к них кем они работают, выглядит это ничуть не сложнее, чем
и описания классов, хочу лишь обратить Ваще внимание на то, что
полиморфная переменная должна иметь тип базового класса:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AskHuman&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Director&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;work&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Manager&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;work&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Programmer&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;work&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;В ответ на выполнение этого мы метода мы получим каждую фразу из всех
четырех классов, то есть не смотря на то, что у переменной заявлен тип
базового класса, будут вызываться методы производных:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Я работаю директором! Я работаю менеджером! Я работаю программистом!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Этот механизм расширяет возможности использования классов, позволяя
более гибко использовать переменные и методы (да, этот механизм
справедлив и для методов), а также позволяет писать более абстрактные
программы и существенно упрощает работу программ, имеющих модульную
структуру.&lt;/p&gt;
&lt;p&gt;Также имеет смысл упомянуть, что в некоторых языках программирования
существует такое понятие как &lt;strong&gt;интерфейс&lt;/strong&gt;, предназначенное именно для
стандартизации механизма полиморфизма. Смысл интерфейса состоит в том,
что он предоставляет классу список методов, которые класс &lt;em&gt;обязан&lt;/em&gt;
реализовать (ключевое слово в Java - &lt;code&gt;implements&lt;/code&gt;), при этом сам
интерфейс не содержит какой-либо реализации и может быть только
определен. Выглядит примерно следующим образом:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Worker&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Director&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Worker&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю директором!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Programmer&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Worker&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю программистом!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Manager&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Worker&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю менеджером!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;В этом случае производные классы будут &lt;em&gt;обязаны&lt;/em&gt; иметь метод work, что
даст гарантию классу AskHuman, что он не вызовет несуществующий метод.&lt;/p&gt;
&lt;h3 id="inkapsuliatsiia"&gt;Инкапсуляция&lt;/h3&gt;
&lt;p&gt;Наверняка Вы уже задавались вопросом о том, что же значит слово
&lt;code&gt;public&lt;/code&gt; во всех предыдущих примерах. Это ключевое слово является
частью реализации механизма инкапсуляции в языке Java, суть его состоит
в том, чтобы дать возможность определить &lt;em&gt;область видимости&lt;/em&gt; для
составных частей класса, это очень актуально при написании ПО,
использующего библиотеки, plug-in'ы или при написании программы группой
людей. Ведь если Ваш класс подразумевает какие-либо ограничения для
переменных или методов (например - возраст не может быть отрицательным),
то их легко обойти воспользовавшись прямым доступом к ним из-за пределов
класса или просто выполнив наследование.&lt;/p&gt;
&lt;p&gt;Для предотвращения этого используется система параметров, назначаемых
переменным и методам внутри класса для присвоения им "уровней доступа"
(на примере опять же Java, но в большинстве известных мне
высокоуровневых языков используется та же система):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt; - назначается по-умолчанию - полностью свободный доступ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;private&lt;/code&gt; - доступ предоставляется &lt;em&gt;только&lt;/em&gt; другим компонентам
   класса&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protected&lt;/code&gt; - доступ предоставляется остальным компонентам класса,
   а также всем &lt;em&gt;наследникам&lt;/em&gt; данного класса&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Данный механизм является незаменимым помощником разработчиков любых
более-менее крупных проектов, следующих принципам ООП.&lt;/p&gt;
&lt;h4&gt;Вместо заключения&lt;/h4&gt;
&lt;p&gt;Казалось бы бестолковая история про человека, идущего на работу,
позволила Вам получить базовое представление об основах
объектно-ориентированного программирования. Надеюсь у меня не раз еще
найдется повод вернуться к обсуждению этой парадигмы.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sat, 05 Jan 2008 22:28:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-01-05:theory/2008/tri-osnovnyx-komponenta-paradigmy-obektno-orientirovannogo-programmirovaniya/</guid><category>инкапсуляция</category><category>интерфейс</category><category>наследование</category><category>объектно-ориентированное программирование</category><category>ООП</category><category>парадигма</category><category>полиморфизм</category><category>Программирование</category><category>программное обеспечение</category></item><item><title>Объектно-ориентированное программирование: а что же это?</title><link>https://www.insight-it.ru//theory/2008/obektno-orientirovannoe-programmirovanie-a-chto-zhe-eto/</link><description>&lt;p&gt;Находишься в поисках способов облегчить свой труд в процессе написания
программного обеспечения? - об одном из них мы сегодня и поговорим.&lt;/p&gt;
&lt;p&gt;Сама концепция &lt;a href="/tag/oop/"&gt;этого подхода&lt;/a&gt; к программированию достаточно
проста для понимания, и заключается она в...&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;...совокупности достаточно большого количества факторов, о которых и
пойдет речь ниже (надеюсь Вы не ожидали увидеть пост, состоящий из двух
предложений).&lt;/p&gt;
&lt;p&gt;Хочется верить, что Вам уже доводилось иметь хоть какой-либо опыт в
программировании, иначе я не могу гарантировать что значения всех слов,
которыми я буду оперировать в процессе написания, будет для Вас
очевидным.&lt;/p&gt;
&lt;p&gt;Для начала напомню тот факт, что в языках высокого уровня простейшими
элементами, доступными программисту, являются:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;переменная&lt;/em&gt; и &lt;em&gt;константа&lt;/em&gt; - указатель на ячейку памяти заранее
    определенной длинны, содержащую какие-либо данные. Различие в том,
    что константа обычно заранее определена, а содержимое переменных
    вычисляется в процессе работы программы.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;функция, процедура и оператор&lt;/em&gt; - по сути представляют собой
    логически обособленную часть программы. Точную границу между этими
    тремя терминами провести сложно, да и не важна она, могу лишь
    упомянуть, что процедуры не возвращают значения и, как следствие,не
    могут использоваться внутри выражений.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ни для кого не секрет, что набор ноликов и единичек, содержащийся в
переменной, должен каким-то образом интерпретироваться программой.
Способы интерпретации данных программой принято называть &lt;strong&gt;тип данных&lt;/strong&gt;.
Помимо базовых типов, которые можно найти в практически любом языке
программирования высокого уровня (в основном числовые и символьные
данные разных видов), большинство из них позволяют программистам
определять собственные типы данных, которые
могут представлять собой практически что угодно, но на одной категории
определяемых программистом типов данных стоит остановиться по-подробнее:&lt;/p&gt;
&lt;h3 id="klass"&gt;Класс&lt;/h3&gt;
&lt;p&gt;У многих из вас это слово наверняка вызывает множество ассоциаций,
связанных как минимум со школой, и возможно с какими-либо науками, ведь
это слово имеет достаточно много значений.&lt;/p&gt;
&lt;p&gt;Если же по смотреть на слово класс с точки зрения программирования, то
он представляет собой тип данных, состоящий из совокупности переменных,
констант, и функций (которые принято называть &lt;em&gt;методами&lt;/em&gt;). Все вместе
они служат общей цели - смоделировать возможное поведение некоторого
&lt;strong&gt;объекта&lt;/strong&gt;. Не сомневаюсь, что у большинства из вас возник вопрос: что
же имеется в виду под этим словом в программировании?&lt;/p&gt;
&lt;h3 id="obekt"&gt;Объект&lt;/h3&gt;
&lt;p&gt;Для простоты понимания это слово можно воспринимать буквально - как
некую сущность, находящуюся в каком-либо состоянии и имеющую возможность
совершать некий набор действий. Также как и реальные объекты, объекты
"компьютерные" живут своей &lt;em&gt;жизнью&lt;/em&gt;: рождением считается создание
объекта (выделение памяти), а смертью - уничтожение (освобождение
памяти). Промежуток между этими двумя событиями принято называть
&lt;em&gt;временем жизни&lt;/em&gt; объекта.&lt;/p&gt;
&lt;p&gt;Если же есть желание взглянуть на объект с технической точки зрения, то
он представляет собой экземпляр какого-либо класса, то есть как раз
указатель на область оперативной памяти, данные по которому подчиняются
"правилам", установленными в соответствующем классе. То есть для него
могут выполняться заранее определенные функции, что будет приводить к
определенным изменениям в его состоянии (то есть совокупности
переменных).&lt;/p&gt;
&lt;p&gt;Все написанное выше можно считать лишь неким подобием введения в ООП,
дающим поверхностное представление о том, что же понимают под этой
странновато звучащей фразой, и на какие же "&lt;a href="/tag/obekt/"&gt;"объекты"&lt;/a&gt;
нужно "ориентироваться". Сама же теория является намного более обширной,
и я собираюсь еще не раз вернуться к ее обсуждению в теории и с более
практической точки. Например, возможно для многих остался не ясным
вопрос: какие же преимущества предоставляет использование ООП перед
более традиционным функциональным программированием? Ответить на него я
и собираюсь в одном из следующих постов, не пропустить публикацию
которого можно с помощью &lt;a href="/feed/"&gt;RSS&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Fri, 04 Jan 2008 21:39:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-01-04:theory/2008/obektno-orientirovannoe-programmirovanie-a-chto-zhe-eto/</guid><category>класс</category><category>объект</category><category>объектно-ориентированное программирование</category><category>ООП</category><category>ПО</category><category>Программирование</category><category>программное обеспечение</category></item><item><title>Пара простых способов повысить эффективность написания кода</title><link>https://www.insight-it.ru//theory/2008/para-prostyx-sposobov-povysit-effektivnost-napisaniya-koda/</link><description>&lt;p&gt;Начнем, пожалуй, издалека: если рассматривать процесс программирования
чуть более глобально, чем просто как дальний синоним слова
&lt;em&gt;&lt;a href="/tag/koding/"&gt;coding&lt;/a&gt;&lt;/em&gt;, то нетрудно прийти к выводу, что реализация
хоть сколько-нибудь большого проекта невозможна просто с помощью
следования банальному алгоритму: сесть за компьютер, бросить взгляд на
ТЗ, открыть любимый текстовый редактор, взять в зубы клавиатуру и
написать. Если говорить о проектах уровня "Hello, world!" такой алгоритм
вполне пригоден для реального использования, но как только речь заходит
о чем-либо более серьезном и полномасштабным, такой подход сразу
начинает порождать несметное количество проблем.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Основными причинами этого явления я бы назвал ограниченность ресурсов
одного человека и отсутствие какой-либо стандартизации. Количество строк
кода, которые кодер в состоянии писать в единицу времени ограниченно не
только скоростью набора символов на клавиатуре, но и аналитическими
способностями: начиная с какого-то момента человек тупо начинает
забывать где у него находилась, например, та или иная функция или что
значит та или иная переменная / константа.&lt;/p&gt;
&lt;p&gt;Временным спасением от подобного рода проблем может послужить привычка
грамотно оформлять код:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Размещение строго по одному выражению на строке в комбинации с
    поддающимся хоть какой-либо логике расставления отступов в начале
    строки позволяет избежать потерянных выражений и четко понимать: а
    где же заканчивает вон то-о-от цикл?&lt;/li&gt;
&lt;li&gt;Осмысленные названия переменных резко сокращают время, необходимое
    для осознавания ответа на вопрос "а что же она значила?" Мне
    доводилось не раз сталкивался с кодом, написанным с использованием в
    качестве абсолютно всех переменных разнообразных букв латинского
    алфавита - мало того что изменить их на что-либо другое как
    автозаменой, так и RegExp'ами проблематично, так и на разобраться
    что к чему ушло очень продолжительный период времени. Существует
    большое количество более адекватных способов названия переменных и
    функций, перечислять их все смысла не вижу, по-этому кратенько
    расскажу о том, которым предпочитаю пользоваться сам: алгоритм прост
    как три копейки - название соответствует переведенному на английский
    смыслу (переменную, содержащую чье-либо имя называем name), в случае
    если слов требуется более одного слова - пишем их слитно, начиная
    все кроме первого с заглавной буквы (например: veryLongName), и по
    старинной традиции делаем исключение для индексов циклов, которые
    называем буквами латинского алфавита начиная с &lt;em&gt;i&lt;/em&gt; и далее по
    списку. Вот собственно говоря банальный способ, позволяющий в очень
    сжатые сроки вспомнить как называлась переменная, содержащее имя :)&lt;/li&gt;
&lt;li&gt;Подавляющее большинство языков программирования поддерживает
    &lt;em&gt;разбавление&lt;/em&gt; кода комментариями, что существенно упрощает
    ориентирование в &lt;em&gt;объемистых&lt;/em&gt; листингах как самим автором, так и
    всеми остальными персонами, которым по тем или иным причинам
    доведется в последствии читать &lt;em&gt;произведение.&lt;/em&gt; Особенно этот способ
    актуален для низкоуровневых языков программирования, так как с
    первого взгляда на код даже его автору порой проблематично
    определить его значение.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Все вышесказанное хоть и упрощает процесс программирования (хотя в этом
предложении более подходящим является слово &lt;em&gt;&lt;a href="/tag/koding/"&gt;кодинг&lt;/a&gt;&lt;/em&gt;), но
не позволяет избежать большей части потенциальных проблем, связанных с
крупномасштабными проектами. Существует множество способов борьбы с
издержками от масштаба проекта, такие как компонентно-ориентированное и
объектно-ориентированное программирование, различные формы анализа и
проектирования.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Thu, 03 Jan 2008 20:52:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-01-03:theory/2008/para-prostyx-sposobov-povysit-effektivnost-napisaniya-koda/</guid><category>код</category><category>кодинг</category><category>название переменных</category><category>Программирование</category><category>реализация</category><category>форматирование текста</category></item></channel></rss>
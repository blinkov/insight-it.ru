<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Insight IT</title><link>https://www.insight-it.ru/</link><description></description><atom:link href="https://www.insight-it.ru/tag/evm/feed/index.xml" rel="self"></atom:link><lastBuildDate>Sat, 17 Mar 2012 19:43:00 +0400</lastBuildDate><item><title>Erlang в интернет-проектах</title><link>https://www.insight-it.ru//erlang/2012/erlang-v-internet-proektakh/</link><description>&lt;p&gt;С моей точки зрения,&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/4b2ebe6b/" rel="nofollow" target="_blank" title="http://www.erlang.org"&gt;&lt;strong&gt;Erlang&lt;/strong&gt;&lt;/a&gt; - один из
наиболее продуманных языков программирования. Его создатели выбирали
каждую деталь и особенность реализации так, чтобы сделать его идеальным
для решения вполне конкретных телекоммуникационных задач, с которыми они
сталкивались в 80-90-х годах. Во многом из-за этого он так и не стал
универсальным языком программирования как &lt;a href="/tag/c/"&gt;C++&lt;/a&gt;,
&lt;a href="/tag/python/"&gt;Python&lt;/a&gt; и другие, а так и остался спустя многие годы
специализированным инструментом. Сегодня спрос и предложение на
специалистов по &lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt; на рынке труда относительно малы,
что для большинства проектов является основным аргументом &lt;em&gt;против
Erlang&lt;/em&gt;, хотя порой они и сталкиваются с задачами, где он запросто бы
стал тем самым &lt;em&gt;"идеальным инструментом"&lt;/em&gt;. В этой статье я хотел бы
обсудить, в каких именно ситуациях применительно к интернет-проектам
использование &lt;strong&gt;Erlang&lt;/strong&gt; оправдано и почему. Но начать придется
издалека - с того, чем же он так &lt;em&gt;уникален&lt;/em&gt;.
&lt;!--more--&gt;&lt;/p&gt;
&lt;h2 id="chto-takoe-erlang"&gt;Что такое Erlang?&lt;/h2&gt;
&lt;p&gt;Под словом Erlang обычно подразумевают совокупность сразу нескольких
компонентов:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Сам одноименный язык программирования - по сути синтаксис и
    идеологию;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ERTS&lt;/strong&gt; &lt;em&gt;(Erlang Run-Time System)&lt;/em&gt; - реализация всех низкоуровневых
    абстракций на &lt;a href="/tag/c/"&gt;C&lt;/a&gt;. Подробнее о них ниже.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BEAM&lt;/strong&gt; &lt;em&gt;(Bogdans' Erlang Abstract Machine)&lt;/em&gt; - стандартная
    реализация виртуальной машины, с помощью которой обычно исполняются
    программы на Erlang после компиляции в байт-код (она очень
    эффективна; хотя компиляция Erlang в нативный код и возможна, оно
    того чаще всего не стоит). BEAM используется по-умолчанию в основных
    дистрибутивах &lt;a href="/tag/linux/"&gt;Linux&lt;/a&gt; и других операционных системах.
    Когда говорят "виртуальная машина Erlang" обычно подразумевается
    совокупность ERTS и BEAM.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OTP&lt;/strong&gt; &lt;em&gt;(Open Telecom Platform)&lt;/em&gt; - набор качественно реализованных
    высокоуровневых абстракций, использование которых стало почти
    стандартом де-факто в мире Erlang, так как оно позволяет не
    изобретать велосипеды и избегать типичных ошибок при реализации
    типичных же паттернов. Немного забегая вперед, приведу несколько
    примеров:&amp;nbsp;&lt;strong&gt;gen_server&lt;/strong&gt; (просто процесс, который принимает
    какие-то запросы и как-то на них реагирует), &lt;strong&gt;gen_fsm&lt;/strong&gt; (конечный
    автомат), &lt;strong&gt;supervisor&lt;/strong&gt; (мониторинг других процессов).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="kliuchevye-osobennosti"&gt;Ключевые особенности&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Параллельное программирование&lt;/strong&gt; &lt;em&gt;(concurrent programming)&lt;/em&gt; - программы
на Erlang состоят из независимых задач, которые &lt;em&gt;могут&lt;/em&gt; выполняться
параллельно, что на практике дает свободу виртуальной машине планировать
их выполнение наиболее эффективным образом с учетом доступных системных
ресурсов.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Процессная модель&lt;/strong&gt; &lt;em&gt;(process model)&lt;/em&gt; - единицей параллельного
выполнения в Erlang является &lt;em&gt;процесс&lt;/em&gt;, который технически представляет
собой лишь часть потока исполнения &lt;em&gt;(thread)&lt;/em&gt; операционной системы и
обладает нижеизложенными свойствами, которые обеспечивает их реализация
в ERTS:&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Параллельность&lt;/strong&gt; &lt;em&gt;(concurrency)&lt;/em&gt; - каждый процесс выполняет свою
часть кода вне зависимости от других процессов, со своим темпом.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Изоляция процессов&lt;/strong&gt; &lt;em&gt;(process isolation)&lt;/em&gt;&amp;nbsp;- в отличии от
потоков исполнения в операционных системах и других языках
программирования, между процессами Erlang'а нет общей памяти. Помимо
этого сбой в одном из процессов напрямую не влияет на другие
процессы в системе. Именно по-этому они называются &lt;em&gt;процессами&lt;/em&gt;, так
как в этом ключе скорее похожи на полноценные процессы операционной
системы.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Низкое потребление ресурсов&lt;/strong&gt;&amp;nbsp;&lt;em&gt;(low resource consumption)&lt;/em&gt; - так
как процессы Erlang являются лишь абстракцией внутри потока
исполнения операционной системы, используют зачастую &lt;em&gt;меньше
килобайта&lt;/em&gt; оперативной памяти и требует минимальных вычислительных
ресурсов, то один сервер может при необходимости иметь сотни тысяч
и даже миллионы&amp;nbsp;запущенных процессов (теоретически возможный
максимум - 268435456, хотя по-умолчанию стоит ограничение в&amp;nbsp;32768
процессов). Для сравнения: суммарное количество потоков выполнения
на сервере обычно измеряется сотнями и редко превышает тысячу.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Слабая связанность&lt;/strong&gt;&amp;nbsp;&lt;em&gt;(loose coupling)&lt;/em&gt; - процессы общаются друг с
другом посредством асинхронного обмена сообщениями &lt;em&gt;(message
passing)&lt;/em&gt;,&amp;nbsp;для чего часть памяти каждого процесса выделяется под
"почтовый ящик". При отправке сообщения в списке входящих сообщений
процесса-получателя создается копия сообщения, составленного в
процессе-отправителе. При этом протокол отправки сообщений между
процессами скрыт от разработчика и не зависит от того, находится ли
получатель в той же виртуальной машине или в удаленной (на другом
сервере), что позволяет легко и практически прозрачно распределять
приложения по многим физическим серверам &lt;em&gt;(горизонтальное
масштабирование, scale out)&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Дерево ответственности&lt;/strong&gt; &lt;em&gt;(responsibility tree)&lt;/em&gt; - создаваемые
внутри системы процессы образуют иерархию, где родители несут
ответственность за потомков.&amp;nbsp;В упомянутом чуть выше примере сбой
одного из процессов вызывает его завершение и рассылку уведомлений
связанным процессам-соседям по иерархии (с информацией о том, где и
почему произошел сбой), на которые они могут как-то реагировать.
Типичных сценария реагирования два: также завершить работу и
разослать аналогичные уведомления, вызывая цепную реакцию (такие
процессы называют исполнителями, &lt;em&gt;worker&lt;/em&gt;), либо на основе
уведомления принять какое-то действие, например попытаться заново
запустить часть дерева процессов, аналогичную остановленной (такие
называют надсмотрщиками, &lt;em&gt;supervisor&lt;/em&gt;). Использование этого
механизма позволяет приложению добиться &lt;em&gt;отказоустойчивости&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ссылочная прозрачность&lt;/strong&gt; &lt;em&gt;(referential transparency)&lt;/em&gt;&amp;nbsp;- как только
переменная получила какое-то значение его уже нельзя изменить &lt;em&gt;(single
assignment)&lt;/em&gt;, для нового значения нужно заводить новую переменную. На
первый взгляд выглядит полным бредом, но именно эту цену нужно заплатить
для гарантии того, что какая-то другая часть кода втихаря не "испортит"
значение. Плюс отсутствие изменений в структурах данных в памяти дает
большую свободу для применения различных оптимизаций компилятору,
сборщику мусора и планировщику процессов.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Планировщик процессов&lt;/strong&gt; &lt;em&gt;(scheduler)&lt;/em&gt; - виртуальная машина Erlang с
точки зрения операционной системы выглядит как один процесс с
несколькими потоками исполнения &lt;em&gt;(threads)&lt;/em&gt;, каждый из которых имеет
собственный планировщик, управляющий группой Erlang-процессов. Процессы
могут прозрачно перемещаться из одного потока в другой для &lt;em&gt;балансировки
нагрузки&lt;/em&gt;. Помимо этого планировщик берет на себя управление
вводом-выводом, которые на низком уровне реализованы в неблокирующей,
основанной на событиях, манере с использованием&amp;nbsp;&lt;a href="/tag/epoll/"&gt;epoll&lt;/a&gt;&amp;nbsp;или
аналогов, но для конечного разработчика представляется в упрощенном
виде.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Сборщик мусора в памяти&lt;/strong&gt; &lt;em&gt;(garbage collector)&lt;/em&gt; - в отличии от других
виртуальных машин (в частности &lt;a href="/tag/jvm/"&gt;JVM&lt;/a&gt;) сборка мусора в Erlang
не влечет за собой значимых задержек в работе приложений, так как
благодаря изоляции процессов для сборки мусора они останавливаются по
очереди, пока все остальные продолжают работать. Обычно область памяти
выделенная под один процесс очень невелика (для сравнения: под новый
процесс в Erlang выделяется около 1 килобайта, под новый поток
исполнения в &lt;a href="/tag/java/"&gt;Java&lt;/a&gt; - более 512 килобайт в зависимости от
реализации), так что сборка мусора для каждого процесса не занимает
много времени. Планировщик может определить какие процессы нужно
пропустить при очередной сборке мусора, если они не исполнялись с
момента предыдущей сборки. Если процесс создается для выполнения
кратковременной задачи, то он может успеть сделать свое дело и
завершиться без единой сборки мусора, полностью освободив свою память по
окончании работы.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Функциональное программирование&lt;/strong&gt;&amp;nbsp;&lt;em&gt;(functional programming)&lt;/em&gt;&amp;nbsp;-
если рассмотреть один Erlang-процесс внутри, отбросив его связь с
внешним миром (обмен сообщениями), то можно увидеть программу, полностью
соответствующую функциональной парадигме: алгоритмы выражаются в виде
вызовов функций, которые, в свою очередь, являются единицами данных
наравне с числами и сложными структурами. На практике же это означает
другой стиль программирования и используемые абстракции (рекурсия вместо
циклов, поведения вместо интерфейсов и т.п.), по сравнению с более
распространенными &lt;a href="/tag/oop/"&gt;объектно-ориентированными&lt;/a&gt; языками;
подробно это будет интересно лишь программистам, так что оставим это для
другой статьи про &lt;a href="/tag/erlang/"&gt;Erlang&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Доступно три механизма хранения данных вне памяти процессов:&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ETS&lt;/strong&gt; &lt;em&gt;(erlang term storage)&lt;/em&gt; - очень похожий на хранилище пар
ключ-значение механизм, работающий в оперативной памяти самой
виртуальной машины и доступный всем или части её процессов (есть
ограничения доступа). Данные хранятся в пространствах имен (таблицы
без жесткой структуры), а доступ осуществляется по ключу, который
являются частью значения (обычно первым элементом в хранящейся
структуре данных).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DETS&lt;/strong&gt;&amp;nbsp;&lt;em&gt;(disk erlang term storage)&lt;/em&gt;&amp;nbsp;- предоставляется аналогичный
ETS интерфейс и формат хранения данных, с той лишь разницей, что
данные хранятся в файлах на диске, а не в памяти виртуальной машины.
При использовании &lt;strong&gt;не&lt;/strong&gt;твердотельных дисков операции поиска данных
значительно медленнее аналогов из модуля ETS.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mnesia&lt;/strong&gt; - полноценная СУБД на основе ETS/DETS, с поддержкой
атомарных транзакций &lt;em&gt;(atomic transactions)&lt;/em&gt;, репликации
&lt;em&gt;(replication)&lt;/em&gt; и партиционирования &lt;em&gt;(sharding)&lt;/em&gt;. Позволяет
абстрагироваться от физического расположения данных, осуществлять
поиск/выборки данных в реальном времени, а также вносить изменения в
конфигурацию и схему данных без перезапуска.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Горячее обновление кода&lt;/strong&gt; &lt;em&gt;(hot code loading)&lt;/em&gt; - виртуальная машина
может держать в памяти и параллельно выполнять две версии одного и того
же кода (единицей измерения здесь является &lt;em&gt;модуль&lt;/em&gt;, то есть один
скомпилированный файл исходного кода), процесс переключается со старого
кода на новый при выполнении &lt;em&gt;внешнего&lt;/em&gt; вызова к одной из его функций
(что в целом полностью в руках разработчика). Эта возможность позволяет
полностью избежать недоступности приложения при обновлениях, что очень
важно для всех приложений, работающих в реальном времени, к которым
также относятся все сайты и интернет-сервисы.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="primenenie-na-praktike"&gt;Применение на практике&lt;/h2&gt;
&lt;p&gt;Телекоммуникации и Интернет на сегодняшний день хоть и являются
совершенно разными областями &lt;em&gt;информационных технологий&lt;/em&gt;, но все же
глобальная цель у них общая: позволять людям легко общаться удаленно.
Предлагаю вернуться к изначальной теме статьи: в каких конкретно
ситуациях &lt;strong&gt;Erlang&lt;/strong&gt;, вместе со своими изложенными выше особенностями и
ограничениями, может оказаться уместным решением задач интернет-проекта?
Примеры могут показаться субъективными, так что с удовольствием готов
обсудить их и другие ситуации в комментариях.&lt;/p&gt;
&lt;h3 id="vkhodiashchie-polzovatelskie-soedineniia"&gt;Входящие пользовательские соединения&lt;/h3&gt;
&lt;p&gt;Еще в далеком 2002 году в сети часто мелькал
сравнительный&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/669f1a19/" rel="nofollow" target="_blank" title="http://www.sics.se/~joe/apachevsyaws.html"&gt;бенчмарк&lt;/a&gt;&amp;nbsp;&lt;strong&gt;Apache&lt;/strong&gt;
&lt;em&gt;(C)&lt;/em&gt; и &lt;strong&gt;Yaws&lt;/strong&gt; &lt;em&gt;(Erlang)&lt;/em&gt;&amp;nbsp;по обработке HTTP-запросов, где Yaws
представлялся "победителем" с огромным отрывом. С тех пор конечно же
многое поменялось, появился стремительно набирающий обороты
&lt;a href="/tag/nginx/"&gt;nginx&lt;/a&gt; и "популярные в узких кругах" решения вроде
&lt;a href="/tag/node-js/"&gt;node.js&lt;/a&gt; или &lt;a href="/tag/tornado/"&gt;Tornado&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Но &lt;strong&gt;Erlang&lt;/strong&gt; тоже не стоит на месте. Благодаря целенаправленной работе
по оптимизации ERTS в целом и планировщика процессов в частности,
современные реализации HTTP-серверов на Erlang по-прежнему легко &lt;a href="https://www.insight-it.ru/goto/fdb93d75/" rel="nofollow" target="_blank" title="http://www.ostinelli.net/a-comparison-between-misultin-mochiweb-cowboy-nodejs-and-tornadoweb"&gt;дают фору&lt;/a&gt;&amp;nbsp;более распространенным решениям.&lt;/p&gt;
&lt;p&gt;В последние годы появляется все больше интернет-проектов, использующие
постоянные соединения &lt;em&gt;(websocket, long polling, etc.)&lt;/em&gt;&amp;nbsp;между браузером
и HTTP-сервером для обновления страниц сайта в реальном времени. Здесь
также Erlang легко справляется с задачей, так как для поддержания
постоянного соединения обычно используется лишь 1 Erlang-процесс (хотя
иногда 2), которые, как уже упоминалось, потребляют минимум &amp;nbsp;оперативной
памяти и вычислительных ресурсов. Как следствие, HTTP-сервер на Erlang
способен поддерживать очень постоянное соединение с онлайн
пользователями, даже если их количество измеряется десятками тысяч.&lt;/p&gt;
&lt;p&gt;Хочется отметить, что в этом примере речь идет именно об обработке
соединений с пользователями, то есть внутри HTTP-сервера минимум логики,
он просто "разбирает" запрос и, вероятно, передает его дальше внутрь
системы через брокер сообщений или напрямую внутренним сервисам. К
вопросу с сколько-либо сложной бизнес-логикой вернемся чуть позже.&lt;/p&gt;
&lt;h3 id="otdacha-statiki"&gt;Отдача статики&lt;/h3&gt;
&lt;p&gt;Для отдачи статики в Erlang часто используют тот же системный вызов
&lt;strong&gt;sendfile&lt;/strong&gt;, что и в &lt;a href="/tag/nginx/"&gt;nginx&lt;/a&gt;.&amp;nbsp;Но на практике ситуация
здесь неоднозначна:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;прямой доступ к sendfile через встроенные вызовы&amp;nbsp;&lt;em&gt;(BIF, Built-In
    Functions)&lt;/em&gt;&amp;nbsp;появился в Erlang только в самом последнем на
    сегодняшний день релизе - R15B;&lt;/li&gt;
&lt;li&gt;раньше использовалась
    &lt;a href="https://www.insight-it.ru/goto/e9f4e5cf/" rel="nofollow" target="_blank" title="https://github.com/tuncer/sendfile"&gt;обертка&lt;/a&gt;&amp;nbsp;с использованием
    нативных функций &lt;em&gt;(NIF, native implemented functions)&lt;/em&gt;&amp;nbsp;или просто
    чтение файла, что &lt;a href="https://www.insight-it.ru/goto/317549c0/" rel="nofollow" target="_blank" title="http://www.erlang-factory.com/upload/presentations/71/JoeWilliams-Web_Server_Deathmatch.pdf"&gt;работало не очень хорошо&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="card blue lighten-4"&gt;
&lt;p&gt;&lt;div class="card-content"&gt;
На готовые бенчмарки по отдаче статики из последних версий Erlang'а я не
натыкался, так что могу предложить взглянуть на небольшой тест
&lt;strong&gt;cowboy&lt;/strong&gt; vs &lt;strong&gt;nginx&lt;/strong&gt;&amp;nbsp;на обычном домашнем оборудовании: Ubuntu в роли
сервера, iMac в роли клиента (JMeter), 100Мбит между ними. Какого-либо
тюнинга настроек не производилось.
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.1Мб картинка в 10 потоков &lt;em&gt;(нехитрая математика говорит о том, что все
упираются в сеть)&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/images/cowboy-static.jpg"&gt;Cowboy без sendfile&lt;/a&gt;: 853мс. в среднем, 639 запросов в минуту, отклонение 428мс.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/images/cowboyR15B-static.jpg"&gt;Cowboy с sendfile&lt;/a&gt;: 853мс. в среднем, 639 запросов в минуту, отклонение 395мс.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/images/nginx-static.jpg"&gt;Nginx&lt;/a&gt;: 882мс. в среднем, 638 запросов в минуту, отклонение 515мс.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;112б текстовый файл в 1000 потоков:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/images/cowboy-static2.jpg"&gt;Cowboy без sendfile&lt;/a&gt;: 37мс. в среднем (но медиана - 3мс., то есть небольшая часть запросов сильно тормозит, а с остальной все нормально), 259 тыс. запросов в минуту, отклонение 234мс.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/images/cowboyR15B-static.jpg"&gt;Cowboy с sendfile&lt;/a&gt;: 17 мс. в среднем, 267 тыс. запросов в минуту, отклонение 27мс.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.insight-it.ru/images/nginx-static2.jpg"&gt;Nginx&lt;/a&gt;: 2мс. в среднем, 315 тыс. запросов в минуту, отклонение 3мс.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Не претендуя на хоть на какую-либо точность и применимость в боевых
условиях, эти цифры и графики показывают, что&amp;nbsp;в деле отдачи статики
&lt;strong&gt;nginx&lt;/strong&gt;&amp;nbsp;хоть и по-прежнему лидер, но в не-экстремальных ситуациях
особой разницы можно и не заметить. Хотя при использовании решений на
Erlang определенно можно начать "скучать" по нестандартным конфигурациям nginx с какой-нибудь компрессией на лету, rewrite'ами и пр.
В любом случае, для отдачи статики в сколько-либо серьезных
интернет-проектов рекомендую пользоваться услугами&amp;nbsp;&lt;a href="/tag/cdn/"&gt;CDN&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="balansirovka-nagruzki"&gt;Балансировка нагрузки&lt;/h3&gt;
&lt;p&gt;Откровенно говоря, я не слышал о каком-либо проекте на Erlang для
балансировки HTTP и/или TCP запросов, хотя бы отдаленно сравнимом по
возможностям, надежности и производительности с &lt;a href="/tag/haproxy/"&gt;HAProxy&lt;/a&gt;
и "железными" решениями.&lt;/p&gt;
&lt;p&gt;Хотя по мне так сами свойства Erlang прекрасно подходят для решения этой
задачи, но те проекты, на которые я натыкался (&lt;a href="https://www.insight-it.ru/goto/53f5a8f4/" rel="nofollow" target="_blank" title="https://github.com/mdaguete/tcpbalance"&gt;пример&lt;/a&gt;), выглядят просто как "поделки" по сравнению с проверенными временем решениями.&lt;/p&gt;
&lt;p&gt;В любом случае HTTP/TCP балансировщик нагрузки на Erlang - отличная
тема для нового opensource проекта, если вдруг кому-то нечем заняться в
свободное время :)&lt;/p&gt;
&lt;h3 id="broker-soobshchenii"&gt;Брокер сообщений&lt;/h3&gt;
&lt;p&gt;В статье про &lt;strong&gt;&lt;a href="https://www.insight-it.ru/erlang/2012/rabbitmq/"&gt;RabbitMQ&lt;/a&gt;&lt;/strong&gt;&amp;nbsp;я
уже подробно рассказывал о том, как Erlang вписывается в роль &lt;em&gt;брокера
сообщений&lt;/em&gt;, то есть посредника между различными компонентами системы,
обеспечивающего их слабую связанность путем обмена сообщениями.&lt;/p&gt;
&lt;p&gt;В дополнение хочется сказать, что хоть изобретать велосипед и редко
когда оказывается хорошей затеей, Erlang отлично подошел бы и для
реализации собственной схемы обмена сообщениями внутри системы, например
без использования централизованного брокера, как это в итоге получается
с использованием RabbitMQ или аналогов.&lt;/p&gt;
&lt;h3 id="biznes-logika"&gt;Бизнес-логика&lt;/h3&gt;
&lt;p&gt;Этот аспект является практически уникальным от проекта к проекту, так
что здесь придется ограничиться лишь какими-то общими рекомендациями.&lt;/p&gt;
&lt;p&gt;Основной слабой стороной Erlang является &lt;strong&gt;обработка данных&lt;/strong&gt;, в
частности:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Текстовые строки в Erlang реализованы как
    &lt;em&gt;однонаправленный&lt;/em&gt;&amp;nbsp;&lt;em&gt;связанный список целых чисел&lt;/em&gt;, то есть на каждый
    символ выделяется &lt;strong&gt;восемь байт&lt;/strong&gt; памяти: четыре на код символа,
    четыре - на указатель на следующий символ; плюс еще четыре байта для
    указателя на начало списка. Для 64-битных систем эти цифры нужно
    удвоить, так как машинное слово вдвое длиннее. Помимо неоправданных
    расходов памяти, эта схема усложняет различные операции со строками,
    например чтобы посчитать длину строки нужно "пройтись" по ней
    целиком. А чтобы приписать один символ в конец строки, нужно сделать
    её полную копию (для записи в начало это не так, как не трудно
    догадаться).&lt;/li&gt;
&lt;li&gt;Бинарные строки хранятся в памяти последовательно, так что объем не
    удваивается из-за указателей. Изменения в итоге также создают копии
    данных, что для больших строк накладно. В любом случае там где это
    возможно я бы рекомендовал использовать бинарные строки вместо
    текстовых.&lt;/li&gt;
&lt;li&gt;С математическими задачами все не так плачевно: хоть и реализация
    базовых операций в виртуальной машине несколько отстает по
    производительности от чистого &lt;a href="/tag/c/"&gt;С&lt;/a&gt;, при желании его можно
    практически догнать средствами нативной компиляции, грамотной
    реализации алгоритма и отсутствия "палок в колесах" у компилятора.
    Альтернативный сценарий: использование NIF.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для не-англоязычных проектов трудностью может оказаться довольно
сомнительная &lt;a href="https://www.insight-it.ru/goto/2568aa73/" rel="nofollow" target="_blank" title="http://www.erlang.org/doc/apps/stdlib/unicode_usage.html"&gt;поддержка Unicode&lt;/a&gt;:
особого типа данных нет, в тех же текстовых строках код символа может
выходить за пределы таблицы ASCII (не зря же на него 32 или 64 бита
выделили), а в бинарных строках можно хранить что угодно, в т.ч. и
Unicode-текст. Как прореагирует на Unicode тот или иной встроенный
модуль или используемая библиотека никто не гарантирует, но обычно все
более-менее нормально.&lt;/p&gt;
&lt;p&gt;Хоть на самом деле это и является роскошью, но при реализации
бизнес-логики на Erlang порой недостает ORM-подобных механизмов в духе
"вытащил объект из базы, поменял в нем что-нибудь, положил обратно". Не
то чтобы таких библиотек нет, просто эта схема не очень хорошо "ложится"
на функциональную парадигму и реализуется обычно через не особо
предназначенные для этого механизмы словарей &lt;em&gt;(dict)&lt;/em&gt; или именованных
кортежей &lt;em&gt;(record)&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;В качестве резюме хочется сказать, что на &lt;strong&gt;Erlang&lt;/strong&gt; можно реализовать
бизнес-логику практически любого интернет-проекта. Просто если она
сложнее, чем просто передать какие-то данные от одного пользователя
другому, то вероятно из-за&amp;nbsp;искусственных&amp;nbsp;ограничений и недостаточной
выразительности языка для эффективной её разработки на Erlang может
потребоваться существенно больше времени и усилий, чем на более
приспособленных для этого языках вроде &lt;a href="/tag/ruby/"&gt;Ruby&lt;/a&gt;,
&lt;a href="/tag/php/"&gt;PHP&lt;/a&gt; и &lt;a href="/tag/python/"&gt;Python&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="bazy-dannykh"&gt;Базы данных&lt;/h3&gt;
&lt;p&gt;Здесь все довольно просто: обычно &lt;strong&gt;Erlang&lt;/strong&gt; используется как
распределенная надстройка над встраиваемыми &lt;a href="/tag/subd/"&gt;СУБД&lt;/a&gt;&amp;nbsp;или
особыми форматами файлов. Основные
представители:&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/243e6801/" rel="nofollow" target="_blank" title="http://basho.com/products/riak-kv/"&gt;Riak&lt;/a&gt;&amp;ensp;&lt;em&gt;(Google LevelDB)&lt;/em&gt;,&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/4cab48f4/" rel="nofollow" target="_blank" title="http://couchdb.apache.org"&gt;CouchDB&lt;/a&gt;&amp;ensp;&lt;em&gt;(свой
формат)&lt;/em&gt;,&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/5d81862f/" rel="nofollow" target="_blank" title="http://www.erlang.org/doc/man/mnesia.html"&gt;Mnesia&lt;/a&gt;&amp;ensp;&lt;em&gt;(DETS)&lt;/em&gt;,&amp;nbsp;&lt;a href="https://www.insight-it.ru/goto/2d0bf326/" rel="nofollow" target="_blank" title="http://www.couchbase.com"&gt;Couchbase&lt;/a&gt;&amp;ensp;&lt;em&gt;(memcached
и SQLite)&lt;/em&gt; - все совершенно разные, обсуждать и сравнивать можно до
бесконечности, так что оставим это на другой раз.&lt;/p&gt;
&lt;p&gt;Из общих особенностей вышеперечисленных решений можно выделить:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Прозрачная &lt;em&gt;горизонтальная масштабируемость&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;Настраиваемый уровень &lt;em&gt;репликации&lt;/em&gt; данных;&lt;/li&gt;
&lt;li&gt;Обычно &lt;em&gt;доступность&lt;/em&gt; и &lt;em&gt;персистентность&lt;/em&gt; в ущерб строгой целостности
    (AP из CAP-теоремы);&lt;/li&gt;
&lt;li&gt;Поддержка &lt;em&gt;сложных распределенных выборок&lt;/em&gt;
    (&lt;a href="/tag/mapreduce/"&gt;MapReduce&lt;/a&gt;, многокритериальная
    фильтрация,&amp;nbsp;полнотекстный&amp;nbsp;поиск и т.п., за исключением Couchbase)&lt;/li&gt;
&lt;li&gt;Способность легко справляться с большим &lt;em&gt;потоком изменений данных&lt;/em&gt;
    (за исключением, пожалуй, CouchDB);&lt;/li&gt;
&lt;li&gt;Отсутствие строгой схемы данных и SQL-подобного интерфейса.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="podvodim-itogi_1"&gt;Подводим итоги&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Erlang&lt;/strong&gt; в умелых руках может послужить и правда удачным решением для
реализации многих аспектов интернет-проектов, благодаря качественной,
проверенной временем, основе в виде виртуальной машины и OTP, а также
продуманной модели легковесных процессов. &lt;em&gt;В результате получаются
высокопроизводительные, горизонтально масштабируемые приложения,
полностью приспособленные для стабильной бесперебойной работы в боевых
условиях.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Высокий барьер обучения специалистов по-прежнему остается весомым
аргументом "против", но если в проекте команда разработчиков уровня выше
среднего -&amp;nbsp;вряд ли&amp;nbsp;это станет серьезным препятствием. Недостаток
"готовых" квалифицированных специалистов по Erlang на трудовом рынке
также не особо радует, но ситуация определенно постепенно улучшается.&lt;/p&gt;
&lt;p&gt;В комментариях предлагаю обсудить по каким еще причинам на сегодняшний
день Erlang столь редко можно увидеть в технологическом стеке
интернет-проектов? Какие еще вопросы смущают руководство и
разработчиков? В каких ситуациях преодоление сложностей и ограничений,
связанных с Erlang, того стоит?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Эта статья определенно будет далеко не последней про Erlang, так что
если эта тема Вам близка - рекомендую &lt;a href="/feed/"&gt;подписаться на RSS&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sat, 17 Mar 2012 19:43:00 +0400</pubDate><guid>tag:www.insight-it.ru,2012-03-17:erlang/2012/erlang-v-internet-proektakh/</guid><category>Beam</category><category>DETS</category><category>Erlang</category><category>ERTS</category><category>ETS</category><category>EVM</category><category>Mnesia</category><category>OTP</category><category>VM</category></item></channel></rss>
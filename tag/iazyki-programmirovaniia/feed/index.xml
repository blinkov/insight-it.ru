<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Insight IT</title><link>https://www.insight-it.ru/</link><description></description><atom:link href="https://www.insight-it.ru/tag/iazyki-programmirovaniia/feed/index.xml" rel="self"></atom:link><lastBuildDate>Thu, 23 Sep 2010 13:07:00 +0400</lastBuildDate><item><title>ООП или не ООП</title><link>https://www.insight-it.ru//theory/2010/oop-ili-ne-oop/</link><description>&lt;p&gt;Вчера мне на почту пришло письмо от коллеги с просьбой прокомментировать
статью, видимо его же перевода или авторства, о судьбе
объектно-ориентированного программирования в современном мире: &lt;a href="https://www.insight-it.ru/goto/b1bc1932/" rel="nofollow" target="_blank" title="http://blogerator.ru/page/oop_why-objects-have-failed"&gt;Почему объектно-ориентированное программирование провалилось?&lt;/a&gt;.
Собственно говоря, пишу ответ в своем блоге скорее чтобы несколько
растопить образовавшийся здесь лед, да и возможно снова затянет -
продолжу дальше активно писать в &lt;strong class="trebuchet"&gt;Insight IT&lt;/strong&gt;.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Для начала хочу вкратце пересказать саму статью. Написана она по мотивам
мнений различных экспертов в области разработки, в частности &lt;a href="https://www.insight-it.ru/goto/3e292f7c/" rel="nofollow" target="_blank" title="http://www.dreamsongs.com/ObjectsHaveFailedNarrative.html"&gt;Objects Have Failed&lt;/a&gt;
by Richard P. Gabriel, November 6, 2002 и holywar'а на конференции
&lt;a href="https://www.insight-it.ru/goto/f4d45ed5/" rel="nofollow" target="_blank" title="http://en.wikipedia.org/wiki/OOPSLA"&gt;OOPSLA&lt;/a&gt; с участием именитых
специалистов. Аргументы у обоих сторон "за и против" были довольно
странноватыми и по сути были подтверждениями и опровержениями различных
мифов об ООП, например о том, что с использованием парадигмы ООП
разработка идет быстрее/проще/понятнее/удобнее, что ОО языки
программирования не соответствуют требованиям вычислительных процессов
будущего и не адекватно отражают предметную область, что повторное
использование кода есть в любом языке программирование - как минимум в
виде библиотек. Сторонники ООП же в основном настаивают на
справедливости мифов и твердо отстаивают &lt;a href="https://www.insight-it.ru/theory/2008/tri-osnovnyx-komponenta-paradigmy-obektno-orientirovannogo-programmirovaniya/"&gt;три основных столпа их парадигмы&lt;/a&gt;.
На вышеупомянутой конференции по мнению аудитории вверх взяла сторона
"против ООП" из-за натиска сторонников языка Lisp и растерянности
сторонников ООП касательно своей же теории.&lt;/p&gt;
&lt;p&gt;Что же касается моего мнения касательно данного вопроса, то я не являюсь
ни приверженцем, ни противником объектно-ориентированного подхода к
программированию. В целом мой взгляд на ситуацию довольно прост: все
языки программирования - лишь инструмент для решения вполне
определенного круга задач. Выбор инструмента и способа работы с ним
определяется в основном лишь самой конкретной постановкой задачи,
требованиям к ней, а также имеющимися в наличии ресурсами - в первую
очередь человеческими и финансовыми. Не нужно смотреть на
программирование чисто с технической точки зрения - в первую очередь
программисты решают бизнес-задачи и проблемы людей, а каким именно
образом и с использованием каких инструментов - заказчиков и
потребителей программных продуктов волнует меньше всего. Для них намного
важнее итоговые показатели получившегося продукта: себестоимость
разработки и поддержки, сроки исполнения, соответствие требованиям, а
также в зависимости от типа продукта масштабируемость,
производительность, стабильность, безопасность.&lt;/p&gt;
&lt;p&gt;Да, в десятках и сотнях тысяч готовых классов в &lt;a href="/tag/net/"&gt;.NET&lt;/a&gt; или &lt;a href="/tag/java/"&gt;Java&lt;/a&gt; легко
запутаться, но они позволяют не разрабатывать реализуемые ими вещи
самим. Объектно-ориентированные языки программирования дают возможность
оперировать более высокоуровневыми понятиями и не тратить время на возню
с памятью напрямую (от утечек правда это не избавляет, но все же),
указателями, типовыми алгоритмами, реализацией протоколов и прочими
нормальными для низкоуровневых языков программирования вещами. Уделяя
меньше внимания деталям, можно создавать крупные проекты большими
мазками - возможно в ущерб качеству, но для многих ситуаций это
приемлемо.&lt;/p&gt;
&lt;p&gt;Когда речь идет о разработке крупной корпоративной системы с большим
количеством пользователей и разнородной информации, на первый план
выходят чаще всего масштабируемость и сроки реализации, а вовсе не
производительность и эффективность алгоритмов. В таких системах
разработка выглядит скорее как склейка требуемого продукта из различных
готовых компонентов, чем реализация собственных алгоритмов и оптимизация
производительности. Для подобных проектов чаще более уместен
объектно-ориентированный подход с использованием широкого спектра
готовых классов, библиотек и системных компонентов. Да, в данном случае
пострадает производительность, но купить несколько дополнительных
серверов дешевле, чем изобретать велосипед и писать с нуля реализацию
всех необходимых составных частей системы.&lt;/p&gt;
&lt;p&gt;Если же разрабатывается скажем какая-нибудь библиотека для расчета
инверсной кинематики, то скорее всего использование ОО-подхода в ней
будет излишним и после реализации всех алгоритмов на низкоуровневом
языке в функциональном/процедурном стиле будет достаточно создать
обертки для всех требуемых языков программирования.&lt;/p&gt;
&lt;p&gt;Плюс не стоит забывать и о том, какие люди участвуют в разработке:
бывают разработчики, которые фанатеют от ООП, всю жизнь занимаются
"сборкой" проектов из библиотек на Java или C#, являются ярыми
поклонниками
&lt;a href="https://www.insight-it.ru/goto/2d7a0d63/" rel="nofollow" target="_blank" title="http://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"&gt;TDD&lt;/a&gt;
и Agile-разработки, а бывают разработчики, которые предпочитают
Assembler/C/Fortran/Cobol/Lisp/Haskell/Erlang (нужное подчеркнуть),
любят реализовывать очень сложные алгоритмы, оптимизировать их,
добиваясь выиграша в несколько&amp;nbsp;миллисекунд&amp;nbsp;во времени или пару килобайт
в использованной оперативной памяти. Естественно это лишь крайние или
почти крайние случаи, большинство разработчиков скорее всего находятся
где-то посередине (к сожалению, у меня нет такой статистики),
предпочитая универсальные языки программирования, на которых можно
писать код как объектно-ориентированно, так и нет
(C++/Python/PHP/etc). Хочется порекомендовать руководителям не
заставлять имеющихся в наличии людей заниматься тем, что им не по душе,
просто так как Вам кто-то вчера рассказал, что "Ruby on Rails - это
круто" или так как во-о-он тот известный проект реализован с
использованием во-он тех технологий, языков программирования или
парадигм разработки. Используемые технологии и подходы к написанию кода,
должны соответствовать поставленным задачам, а команда должна быть
готова реализовать проект именно так, как это необходимо, при этом очень
большое значение имеет распределение ролей между разработчиками - чтобы
каждый занимался своим любимым делом.&lt;/p&gt;
&lt;p&gt;Коллеги, копайте ямы лопатами и забивайте гвозди молотками, а не
наоборот :)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Thu, 23 Sep 2010 13:07:00 +0400</pubDate><guid>tag:www.insight-it.ru,2010-09-23:theory/2010/oop-ili-ne-oop/</guid><category>ООП</category><category>парадигма</category><category>Программирование</category><category>языки программирования</category></item></channel></rss>
<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Insight IT</title><link>https://www.insight-it.ru/</link><description></description><atom:link href="https://www.insight-it.ru/tag/programmnoe-obespechenie/feed/index.xml" rel="self"></atom:link><lastBuildDate>Fri, 11 Jan 2008 21:37:00 +0300</lastBuildDate><item><title>KDE 4 увидел свет</title><link>https://www.insight-it.ru//linux/2008/kde-4-uvidel-svet/</link><description>&lt;p&gt;&lt;img alt="KDE Icon" class="right" src="https://www.insight-it.ru/images/kde.png" title="K Desktop Environment"/&gt;&lt;/p&gt;
&lt;p&gt;Наконец-то наступил тот самый день, которого так долго ждали многие
пользователи различных дистрибутивов Linux и многих других unix-like
операционных систем. Да-да, сегодня вышла новая major-версия знаменитого
K Desktop Environment под номером 4.0!&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Вкратце перескажу &lt;a href="https://www.insight-it.ru/goto/2bdfca56/" rel="nofollow" target="_blank" title="http://www.kde.org/announcements/4.0/index.php"&gt;оффициальный пресс-релиз&lt;/a&gt;:
- Набор библиотек, лежащих в основе KDE, был кардинальным образом
переделан, изменения произошли в каждой из них. Появилось два новых
framework'а: один мультимедийный.- Phonon, а второй - Solid - для
интеграции интерфейса для работы с используемым оборудованием в рабочее
окружение.
- Рабочий стол KDE приобрел новую оболочку под названием Plasma, которая
поддерживает огромное количество widget'ов, эффектов и прочих
украшательств.
- Все программное обеспечение, входящее в его состав также не осталось без
изменений (немного от себя: лично мне больше всего понравились изменения
в Kopete - единственный icq клиент под *nix, в котором появилась
возможность использования x-status, которой сильно не хватало, успел
заценить его еще некоторое время назад в beta-версии KDE 4). Помимо
Konqueror появился новый файловый менеджер под названием Dolphin и
просмотрщик документов Okular (основанный на KPDF, но поддерживающий
существенно большее количество форматов документов).
- Тема рабочего окружения, используемая по-умолчанию также изменилась и
называется она теперь Oxygen, на вкус и цвет конечно, но я думаю
найдется много людей, которым она прийдется по душе.&lt;/p&gt;
&lt;p&gt;&lt;img alt="KDE4 Screenshot" class="responsive-img" src="https://www.insight-it.ru/images/kde-desktop-thumb.jpg" title="KDE 4.0 Screenshot"/&gt;&lt;/p&gt;
&lt;p&gt;Вот так вот примерно выглядит новинка в стандартном варианте оформления,
естественно практически безграничные возможности по модификации
пользовательского интерфейса не только никуда не делись, а только
преувеличились.&lt;/p&gt;
&lt;p&gt;На личном опыте новый релиз я опробовать еще не успел, но планирую этим
делом заняться в ближайшем будующим, наверное сразу же как появятся
ebuild'ы для Gentoo. После чего несомненно поделюсь с Вами
впечатлениями.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Fri, 11 Jan 2008 21:37:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-01-11:linux/2008/kde-4-uvidel-svet/</guid><category>KDE</category><category>Linux</category><category>Unix</category><category>ПО</category><category>программное обеспечение</category></item><item><title>Unix way</title><link>https://www.insight-it.ru//linux/2008/unix-way/</link><description>&lt;p&gt;На эту тему в Сети можно найти несметное количество статей и обсуждений,
не удивлюсь если Вам уже доводилось читать что-либо подобное в прошлом
или может быть работать в одной из множества операционных систем,
разработанных с использованием этой идеологии. За этим словосочетанием
скрывается целая философия разработки программного обеспечения, начавшая
свое развитие в середине 90-х годов прошлого века и воплощенная в
огромном количестве операционных систем и в еще большем количестве
&lt;a href="/tag/opensource/"&gt;opensource&lt;/a&gt; проектов. В этом тексте я хочу поведать
Вам свой взгляд на эту философию с двух точек зрения: программиста и
пользователя.&lt;/p&gt;
&lt;p&gt;Наиболее точно охарактеризовать то, о чем пойдет речь можно лишь
процитировав одного из основателей традиций &lt;a href="/tag/unix/"&gt;Unix&lt;/a&gt; и
разработчика &lt;a href="/tag/tekhnologiya/"&gt;технологии&lt;/a&gt; под названием "Unix
pipes" - &lt;a href="https://www.insight-it.ru/goto/7c67426e/" rel="nofollow" target="_blank" title="http://www.cs.dartmouth.edu/~doug/"&gt;Douglas'а Mcllroy'а&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"This is the Unix philosophy:
- Write programs that do one thing and do it well.
- Write programs to work together.
- Write programs to handle text streams, because that is a universal interface."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--more--&gt;
&lt;p&gt;Для начала воспроизведу суть цитаты для тех читателей, кто возможно не
знает в достаточной степени английского языка:&lt;/p&gt;
&lt;p&gt;&lt;cite&gt;Философия написания программ для &lt;a href="/tag/unix/"&gt;Unix&lt;/a&gt; заключается в
написании программ, качественно решающих строго одну задачу, но при этом
тесно работающих вместе. В качестве стандартного универсального
интерфейса между ними предлагается использование стандартных потоков
текстовых данных.&lt;/cite&gt;&lt;/p&gt;
&lt;p&gt;Сразу же позволю себе слегка отойти от темы, упомянув что существует
также и абсолютно противоположный подход к написанию программного
обеспечения, который стоит упомянуть для того, чтобы "почувствовать
разницу". Он используется в большинстве
&lt;abbr title="Платное программное обеспечение с закрытым кодом"&gt;проприетарных&lt;/abbr&gt;
программ и заключается в нагромождении максимального количества
функционала внутри одного программного продукта, в большинстве случаев с
целью получения дополнительных возможностей для построения рекламной
компании и, как следствие, более выгодного ведения продаж. К сожалению,
при таком подходе разработчики часто забывают о качестве ПО, о
возможностях расширение, удобстве использования, возможностях
модификации со стороны пользователя и многом другом, но зато в итоге
получают продукт, о котором можно указать "установил - и сразу что-то
как-то работает", но что именно, как оно работает, и как долго еще
сможет работать до тех пор пока не начнутся неполадки, и как с ними
бороться в случае если они появятся - остается загадкой для как для
подавляющего большинства пользователей, так и не редко для самих
разработчиков тоже.&lt;/p&gt;
&lt;p&gt;Закончив лирическое отступление, хочется взглянуть на нашу философию с
точки зрения программиста.&lt;/p&gt;
&lt;h3 id="vzgliad-s-tochki-zreniia-programmista"&gt;Взгляд с точки зрения программиста&lt;/h3&gt;
&lt;p&gt;Философия &lt;a href="/tag/unix/"&gt;Unix&lt;/a&gt; предлагает программисту набор элементарных
правил, соблюдение которых не только упростит работу программиста, но и
позволит расширить сферу применения получившегося программного продукта
с помощью различных вариантов интеграции с другими программами.&lt;/p&gt;
&lt;p&gt;Как же это выглядит?&lt;/p&gt;
&lt;h4&gt;Одна задача - одна программа&lt;/h4&gt;
&lt;p&gt;С помощью этого правила список действий, требуемых от программиста для
написания готовой программы, резко сокращается до двух позиций, одной из
которых является собственно реализация задачи. Задачи эти чаще всего
элементарны до безобразия и заключается в переработки входных данных,
например: вывод содержимого указанного каталога, подсчет длины
указанного файла, фильтрация входных данных, отправка локального
электронного письма на удаленный сервер (да-да, для приема, сортировки,
хранения, чтения, редактирования и отправки электронных писем могут
использоваться отдельные программы).&lt;/p&gt;
&lt;p&gt;Подобное множество программ решающих элементарные задачи делает
количество способов решения какой-либо комплексной задачи стремящимся к
бесконечности, ведь при наличии стандартизованного интерфейса
комбинировать программы можно в любой последовательности. Для расширения
возможностей такого рода комбинирования используются различные
скриптовые языки, которых существует достаточно много, наиболее
распространенным из которых являются bash скрипты, основанные на
командах одноименной оболочки командной строки, используемой
по-умолчанию во всех (хотя возможно стоило не использовать громких слов
и написать "в большинстве") дистрибутивах &lt;a href="/tag/linux/"&gt;Linux&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Unix pipes&lt;/h4&gt;
&lt;p&gt;Этот механизм является основным способом реализации столько раз
упоминавшегося выше интерфейса между элементарными программами.
Реализация его поддержки является как раз второй задачей, которая
ставится перед программистом, идущим по пути &lt;a href="/tag/unix/"&gt;Unix&lt;/a&gt;. С
использованием большинства языков программирования она является
тривиальной, особенно это справедливо для C.&lt;/p&gt;
&lt;p&gt;На подробностях реализации останавливаться не будем, по этому позволю
себе плавно перейти к следующему разделу и продолжить эту тему уже там.&lt;/p&gt;
&lt;h3 id="vzgliad-s-tochki-zreniia-polzovatelia"&gt;Взгляд с точки зрения пользователя&lt;/h3&gt;
&lt;p&gt;Слово pipes можно переводить по-разному, мне больше нравится вариант
&lt;em&gt;потоки&lt;/em&gt;, но также часто используется и дословный перевод - &lt;em&gt;трубы&lt;/em&gt;.
Также имеет смысл сразу сказать, что его реализация полностью
основывается на командной строке и командах различных ее оболочек, а
также тесно интегрирована с устройствами компьютера и файловой системой.&lt;/p&gt;
&lt;p&gt;У каждой элементарной программы, соответствующей этой идеологии, должен
быть входной и выходной стандартные текстовые потоки - &lt;strong&gt;stdin&lt;/strong&gt; и &lt;strong&gt;stdout&lt;/strong&gt; соответственно. Механизм unix pipes позволяет перенаправлять эти потоки любой программы произвольным образом с помощью трех простых операторов: &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;&lt;/code&gt;. Первый из них - &lt;code&gt;|&lt;/code&gt; перенаправляет stdout команды слева от него в stdin команды справа, а &lt;code&gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;&lt;/code&gt; предназначены для перенаправление потоков в/из файлы по схожему принципу.&lt;/p&gt;
&lt;p&gt;Предлагаю рассмотреть этот механизм на примерах. Возьмем несколько
базовых утилит, имеющихся на практически любой unix-like системе:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cat&lt;/code&gt; - вывод содержимого указанного первым параметром файла в
    stdout (по умолчанию stdout в большинстве программ направляется в
    консоль)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;less&lt;/code&gt; - постраничный вывод текста, полученного в stdin в stdout
    (переключение страниц и некоторые другие функции производятся с
    клавиатуры, возможны и другие варианты использования, но они нам не
    нужны)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grep&lt;/code&gt; - построчная фильтрация текста, полученного в stdin, вывод
    только строк, содержащих текст, указанный первым аргументом, и вывод
    результата в stdout.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Начнем с примера, позволяющего прочитать постранично любой файл:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat readme.txt &lt;span class="p"&gt;|&lt;/span&gt; less
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Не смотря на наличие более простых методов достижения той же цели, этот
пример наглядно демонстрирует процесс перенаправления ввода-вывода,
другими словами с помощью оператора &lt;code&gt;|&lt;/code&gt; была создана так называемая pipe,
которая и дала название этому механизму. Пример, демонстрирующий
перенаправление в файл будет столь же элементарным, хотя может быть с
первого взгляда покажется "пострашнее":&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat readme.txt &lt;span class="p"&gt;|&lt;/span&gt; grep unix &amp;gt; readme.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Этот пример должен был бы удалить из файла все строки, где нет слова
"unix". &lt;em&gt;Маленькое замечание:&lt;/em&gt; при использовании такого перенаправления,
перед началом передачи данных файл обнуляется. В этом и заключается
ошибка данного примера: файл очищается до того, как поток данных успел
пройти через фильтрацию &lt;strong&gt;grep&lt;/strong&gt;, что приводит к просто очистке файла.
Если же Вам все же нужен отфильтрованный список строк - стоит разместить
в другом файле (которым можно было бы подменить исходный при
необходимости), просто поменяв его название:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat readme.txt &lt;span class="p"&gt;|&lt;/span&gt; grep unix &amp;gt; meread.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Если же Вы хотите избежать очищения файла, в который производится
запись, необходимо написать символ &lt;code&gt;&amp;gt;&lt;/code&gt; дважды, тогда новые данные
припишутся в конец:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat readme.txt &lt;span class="p"&gt;|&lt;/span&gt; grep unix &amp;gt;&amp;gt; readme.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;В unix-like системах есть еще одна интересная особенность, косвенно
связанная с этим механизмом: &lt;em&gt;все устройства являются файлами&lt;/em&gt; и
соответственно, прикреплены к файловой системе, для них выделена
отдельная директория, по традиции называемая &lt;code&gt;/dev&lt;/code&gt;. Работа с ними также
ведется на тех же правах что и с обычными файлами, например набрав в
консоли:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat readme.txt &amp;gt; /dev/dsp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;в ответ от компьютера Вы услышите некоторый звук, издаваемый из колонок
или наушников.&lt;/p&gt;
&lt;h4&gt;Подводим итоги&lt;/h4&gt;
&lt;p&gt;С точки зрения простого пользователя использование opensource решений,
построенных на базе философии unix, является как минимум нетривиальной
задачей - ведь от него требуется как минимум понимание насколько мощная
и гибкая система попала ему/ей в руки. Отсутствие единственного верного
способа решения той или иной задачи ставит большинство людей попросту в
тупик, у них начинают разбегаться глаза от десятков тысяч программ,
доступа к которым есть у всех пользователей unix-like операционных
систем, с помощью набора простой волшебной команды в консоли, состоящей
не более чем из трех-четырех слов.&lt;/p&gt;
&lt;p&gt;Но если пользователь находит в себе силы понять что за зверь попал ему в
руки, он сможет превратить любой компьютер в универсальное устройство по
решению любых задач именно тем способом, который удобен &lt;em&gt;пользователю&lt;/em&gt;,
а не который навязали ему &lt;em&gt;производители&lt;/em&gt;
&lt;abbr title="Платное программное обеспечение с закрытым кодом"&gt;проприетарного&lt;/abbr&gt;
програмного обеспечения.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sun, 06 Jan 2008 19:30:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-01-06:linux/2008/unix-way/</guid><category>Linux</category><category>opensource</category><category>Unix</category><category>Unix way</category><category>идеология</category><category>Программирование</category><category>программное обеспечение</category><category>философия</category></item><item><title>Три основных компонента парадигмы объектно-ориентированного программирования</title><link>https://www.insight-it.ru//theory/2008/tri-osnovnyx-komponenta-paradigmy-obektno-orientirovannogo-programmirovaniya/</link><description>&lt;p&gt;Представьте: Россия, солнце только-только начинает свой путь по
бескрайним просторам неба, Вы находитесь на одной из самых оживленных
улиц своего города и вокруг Вас нетрудно заметить множество людей,
спешащих по своим делам. И вот, Вы видите как один человек зашел в
большое офисное здание.&lt;/p&gt;
&lt;p&gt;Вы спросите у меня: как это все может быть связано с темой этой
записи? - об этом я и собираюсь Вам поведать.&lt;/p&gt;
&lt;!--more--&gt;
&lt;div class="card blue lighten-4"&gt;
&lt;p&gt;&lt;div class="card-content"&gt;Перед тем как продолжить чтение этой записи, очень рекомендую сначала ознакомиться с &lt;a href="https://www.insight-it.ru/goto/e52e6866/" rel="nofollow" target="_blank" title="{theory}/obektno-orientirovannoe-programmirovanie-a-chto-zhe-eto.md"&gt;введением в объектно-ориентированное програмирование&lt;/a&gt;, если Вы еще не успели этого сделать.
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img alt="Три основных компонента" class="right" src="https://www.insight-it.ru/images/cubes.png"/&gt;&lt;/p&gt;
&lt;p&gt;Человек, которого Вы, надеюсь, успешно представили в процессе прочтения
вступления к этой записи, будет служить нам примером в процессе
обсуждения трех базовых вещей, на которых основывается вся концепция
&lt;strong&gt;ООП&lt;/strong&gt;, которые имеет смысл сразу обозначить прямо сейчас:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;наследование&lt;/li&gt;
&lt;li&gt;инкапсуляция&lt;/li&gt;
&lt;li&gt;полиморфизм&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Все они являются равнозначными и перечислены они просто в порядке их
упоминания в этом посте. Но прежде чем перейти к их рассмотрению по
отдельности было бы не лишним несколько конкретизировать пример,
упомянутый чуть выше. Основной акцент в этой записи делается на теорию,
но для упрощения понимания я буду стараться приводить элементарные
примеры реализации на языке &lt;em&gt;Java&lt;/em&gt; (выбранный как наиболее характерный
представитель языков программирования, приспособленных для ООП), которые
правда будут лишь иллюстрировать повествование, но не будут нести за
собой никакой практической пользы.&lt;/p&gt;
&lt;p&gt;Для начала можно рассматривать этого человека просто "со стороны": с
этой точки зрения можно определить его рост, возраст, пол, цвет волос и
глаз, и возможно какие-либо внешние признаки. Помимо этого можно
предположить, что он обладает элементарными навыками, которые он успел
продемонстрировать, проходя мимо Вас: он умеет ходить и еще, видимо,
работать, правда не ясно кем.&lt;/p&gt;
&lt;p&gt;Теперь посмотрим на него, как на объект, который необходимо
смоделировать внутри программы. Внешние данные, перечисленные в
предыдущем абзаце, станут &lt;em&gt;состоянием&lt;/em&gt;, которое необходимо будет описать
примерно следующим образом в описании класса, экземпляром которого и
будет впоследствии являться наш человек:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Human&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// рост&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// возраст&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;gender&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// пол&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;eyesColor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// цвет глаз&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;hairColor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// цвет волос&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Помимо этого мы говорили о его навыках, которые тоже необходимо здесь же
упомянуть, для простоты не будем ничего сложного придумывать в плане
реализации:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Human&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// рост&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// возраст&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;gender&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// пол&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;eyesColor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// цвет глаз&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;hairColor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// цвет волос&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;walk&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я иду!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю в большом офисном здании"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Пожалуй этого будет достаточно для перехода собственно к обсуждению
первого из трех компонентов парадигмы.&lt;/p&gt;
&lt;h3 id="nasledovanie"&gt;Наследование&lt;/h3&gt;
&lt;p&gt;В отличии от реальной жизни, в рамках данной концепции наследование
относится не к материальным вещам, а к переменным и методам класса. Тот
класс, который передает "наследство", принято называть &lt;strong&gt;базовым&lt;/strong&gt;, а
получателя "наследства", соответственно - &lt;strong&gt;наследующим&lt;/strong&gt;. Наследующий
класс в дополнение к собственным методам и переменным получает еще и
полный доступ ко всем переменным и методам базового класса (за некоторым
исключением, о котором пойдет речь при разговоре об инкапсуляции, но обо
всем по порядку).&lt;/p&gt;
&lt;p&gt;Для иллюстрации этого механизма предлагаю предположить кем же мог
работать наш человек. Для примера возьмем три варианта: менеджер,
программист и директор. Менеджер будет уметь командовать подчиненными,
программист писать код, а директор - ничего не делать. но не будем
забывать, что человек, обладающий каждой из этих трех профессий, все же
остается просто человеком и может выполнять все стандартные действия,
которые мог бы выполнять обычный безработный, и обладать теми же
признаками.&lt;/p&gt;
&lt;p&gt;Конечно же можно было бы написать для каждой из профессии класс, просто
добавив по одному методу, это выглядело бы примерно так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Director&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// рост&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// возраст&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;gender&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// пол&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;eyesColor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// цвет глаз&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;hairColor&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// цвет глаз&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;walk&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я иду!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю в большом офисном здании"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;idle&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я ничего не делаю!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Но такой подход годится только для людей даже краем уха не слышавших об
ООП, ведь он далеко не самый эффективный, особенно с точки зрения
затрачиваемого на написание кода времени. Воспользовавшись механизмом
наследования, можно сократить как объем кода, так и время, затраченное
на его написание. В используемом для примеров языке программирования
Java, для этого достаточно лишь указать в заголовке наследующего класса
ключевое слово &lt;em&gt;extends&lt;/em&gt; и название базового класса. Аналогичный
предыдущему класс с использованием этого механизма существенно
упрощается:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Director&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;idle&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я ничего не делаю!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Как не трудно заметить объем кода существенно сократился, но это далеко
не единственное преимущество. Помимо этого, например, если появится
необходимость произвести изменения во всех профессиях - нужно будет
произвести их один раз в базовом классе, а не три раза, как было бы в
случае не использования наследования. А в некоторых случаях базовый
класс может быть уже написан разработчиками языка программирования и для
того чтобы им воспользоваться останется лишь написать пару волшебных
слов.&lt;/p&gt;
&lt;h3 id="polimorfizm"&gt;Полиморфизм&lt;/h3&gt;
&lt;p&gt;Это слово пришло к нам из греческого языка, понимания этого термина
легко достичь, просто переведя его на русский язык: &lt;code&gt;&amp;pi;&amp;omicron;&amp;lambda;ύ&amp;mu;&amp;omicron;&amp;rho;&amp;phi;&amp;omicron;&amp;sigmaf;&lt;/code&gt; - многоформенность. То есть в наиболее
простом случае подразумевается использование одной и той же переменной
(или массива) для хранения информации об объектах, описываемых разными
классами. Представим, что нам необходим стандартизованный способ узнать
кем же работает тот или иной человек, естественно для этого необходимо
описание соответствующего метода для выполнения этой функции в каждом
классе, причем он должен одинаково называться в каждом из них. Для
реализации этого примера на языке Java нет необходимости использовать
дополнительных ключевых слов (в отличие от, например, C#, где
необходимо использование слова virtual в заголовке метода в базовом
классе и override - в производных). Продолжая приводить примеры на Java
имеем три производных класса (для упрощения опустим дополнительные
методы, которые могли бы присутствовать):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Director&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю директором!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Programmer&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю программистом!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Manager&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю менеджером!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Для того, чтобы воспользоваться механизмом полиморфизма достаточно лишь
написать функцию, которая будет создавать экземпляры наших классов и
"спрашивать" к них кем они работают, выглядит это ничуть не сложнее, чем
и описания классов, хочу лишь обратить Ваще внимание на то, что
полиморфная переменная должна иметь тип базового класса:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AskHuman&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Director&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;work&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Manager&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;work&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Programmer&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;work&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;В ответ на выполнение этого мы метода мы получим каждую фразу из всех
четырех классов, то есть не смотря на то, что у переменной заявлен тип
базового класса, будут вызываться методы производных:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Я работаю директором! Я работаю менеджером! Я работаю программистом!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Этот механизм расширяет возможности использования классов, позволяя
более гибко использовать переменные и методы (да, этот механизм
справедлив и для методов), а также позволяет писать более абстрактные
программы и существенно упрощает работу программ, имеющих модульную
структуру.&lt;/p&gt;
&lt;p&gt;Также имеет смысл упомянуть, что в некоторых языках программирования
существует такое понятие как &lt;strong&gt;интерфейс&lt;/strong&gt;, предназначенное именно для
стандартизации механизма полиморфизма. Смысл интерфейса состоит в том,
что он предоставляет классу список методов, которые класс &lt;em&gt;обязан&lt;/em&gt;
реализовать (ключевое слово в Java - &lt;code&gt;implements&lt;/code&gt;), при этом сам
интерфейс не содержит какой-либо реализации и может быть только
определен. Выглядит примерно следующим образом:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Worker&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Director&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Worker&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю директором!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Programmer&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Worker&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю программистом!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Manager&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Worker&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Я работаю менеджером!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;В этом случае производные классы будут &lt;em&gt;обязаны&lt;/em&gt; иметь метод work, что
даст гарантию классу AskHuman, что он не вызовет несуществующий метод.&lt;/p&gt;
&lt;h3 id="inkapsuliatsiia"&gt;Инкапсуляция&lt;/h3&gt;
&lt;p&gt;Наверняка Вы уже задавались вопросом о том, что же значит слово
&lt;code&gt;public&lt;/code&gt; во всех предыдущих примерах. Это ключевое слово является
частью реализации механизма инкапсуляции в языке Java, суть его состоит
в том, чтобы дать возможность определить &lt;em&gt;область видимости&lt;/em&gt; для
составных частей класса, это очень актуально при написании ПО,
использующего библиотеки, plug-in'ы или при написании программы группой
людей. Ведь если Ваш класс подразумевает какие-либо ограничения для
переменных или методов (например - возраст не может быть отрицательным),
то их легко обойти воспользовавшись прямым доступом к ним из-за пределов
класса или просто выполнив наследование.&lt;/p&gt;
&lt;p&gt;Для предотвращения этого используется система параметров, назначаемых
переменным и методам внутри класса для присвоения им "уровней доступа"
(на примере опять же Java, но в большинстве известных мне
высокоуровневых языков используется та же система):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt; - назначается по-умолчанию - полностью свободный доступ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;private&lt;/code&gt; - доступ предоставляется &lt;em&gt;только&lt;/em&gt; другим компонентам
   класса&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protected&lt;/code&gt; - доступ предоставляется остальным компонентам класса,
   а также всем &lt;em&gt;наследникам&lt;/em&gt; данного класса&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Данный механизм является незаменимым помощником разработчиков любых
более-менее крупных проектов, следующих принципам ООП.&lt;/p&gt;
&lt;h4&gt;Вместо заключения&lt;/h4&gt;
&lt;p&gt;Казалось бы бестолковая история про человека, идущего на работу,
позволила Вам получить базовое представление об основах
объектно-ориентированного программирования. Надеюсь у меня не раз еще
найдется повод вернуться к обсуждению этой парадигмы.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Sat, 05 Jan 2008 22:28:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-01-05:theory/2008/tri-osnovnyx-komponenta-paradigmy-obektno-orientirovannogo-programmirovaniya/</guid><category>инкапсуляция</category><category>интерфейс</category><category>наследование</category><category>объектно-ориентированное программирование</category><category>ООП</category><category>парадигма</category><category>полиморфизм</category><category>Программирование</category><category>программное обеспечение</category></item><item><title>Объектно-ориентированное программирование: а что же это?</title><link>https://www.insight-it.ru//theory/2008/obektno-orientirovannoe-programmirovanie-a-chto-zhe-eto/</link><description>&lt;p&gt;Находишься в поисках способов облегчить свой труд в процессе написания
программного обеспечения? - об одном из них мы сегодня и поговорим.&lt;/p&gt;
&lt;p&gt;Сама концепция &lt;a href="/tag/oop/"&gt;этого подхода&lt;/a&gt; к программированию достаточно
проста для понимания, и заключается она в...&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;...совокупности достаточно большого количества факторов, о которых и
пойдет речь ниже (надеюсь Вы не ожидали увидеть пост, состоящий из двух
предложений).&lt;/p&gt;
&lt;p&gt;Хочется верить, что Вам уже доводилось иметь хоть какой-либо опыт в
программировании, иначе я не могу гарантировать что значения всех слов,
которыми я буду оперировать в процессе написания, будет для Вас
очевидным.&lt;/p&gt;
&lt;p&gt;Для начала напомню тот факт, что в языках высокого уровня простейшими
элементами, доступными программисту, являются:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;переменная&lt;/em&gt; и &lt;em&gt;константа&lt;/em&gt; - указатель на ячейку памяти заранее
    определенной длинны, содержащую какие-либо данные. Различие в том,
    что константа обычно заранее определена, а содержимое переменных
    вычисляется в процессе работы программы.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;функция, процедура и оператор&lt;/em&gt; - по сути представляют собой
    логически обособленную часть программы. Точную границу между этими
    тремя терминами провести сложно, да и не важна она, могу лишь
    упомянуть, что процедуры не возвращают значения и, как следствие,не
    могут использоваться внутри выражений.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ни для кого не секрет, что набор ноликов и единичек, содержащийся в
переменной, должен каким-то образом интерпретироваться программой.
Способы интерпретации данных программой принято называть &lt;strong&gt;тип данных&lt;/strong&gt;.
Помимо базовых типов, которые можно найти в практически любом языке
программирования высокого уровня (в основном числовые и символьные
данные разных видов), большинство из них позволяют программистам
определять собственные типы данных, которые
могут представлять собой практически что угодно, но на одной категории
определяемых программистом типов данных стоит остановиться по-подробнее:&lt;/p&gt;
&lt;h3 id="klass"&gt;Класс&lt;/h3&gt;
&lt;p&gt;У многих из вас это слово наверняка вызывает множество ассоциаций,
связанных как минимум со школой, и возможно с какими-либо науками, ведь
это слово имеет достаточно много значений.&lt;/p&gt;
&lt;p&gt;Если же по смотреть на слово класс с точки зрения программирования, то
он представляет собой тип данных, состоящий из совокупности переменных,
констант, и функций (которые принято называть &lt;em&gt;методами&lt;/em&gt;). Все вместе
они служат общей цели - смоделировать возможное поведение некоторого
&lt;strong&gt;объекта&lt;/strong&gt;. Не сомневаюсь, что у большинства из вас возник вопрос: что
же имеется в виду под этим словом в программировании?&lt;/p&gt;
&lt;h3 id="obekt"&gt;Объект&lt;/h3&gt;
&lt;p&gt;Для простоты понимания это слово можно воспринимать буквально - как
некую сущность, находящуюся в каком-либо состоянии и имеющую возможность
совершать некий набор действий. Также как и реальные объекты, объекты
"компьютерные" живут своей &lt;em&gt;жизнью&lt;/em&gt;: рождением считается создание
объекта (выделение памяти), а смертью - уничтожение (освобождение
памяти). Промежуток между этими двумя событиями принято называть
&lt;em&gt;временем жизни&lt;/em&gt; объекта.&lt;/p&gt;
&lt;p&gt;Если же есть желание взглянуть на объект с технической точки зрения, то
он представляет собой экземпляр какого-либо класса, то есть как раз
указатель на область оперативной памяти, данные по которому подчиняются
"правилам", установленными в соответствующем классе. То есть для него
могут выполняться заранее определенные функции, что будет приводить к
определенным изменениям в его состоянии (то есть совокупности
переменных).&lt;/p&gt;
&lt;p&gt;Все написанное выше можно считать лишь неким подобием введения в ООП,
дающим поверхностное представление о том, что же понимают под этой
странновато звучащей фразой, и на какие же "&lt;a href="/tag/obekt/"&gt;"объекты"&lt;/a&gt;
нужно "ориентироваться". Сама же теория является намного более обширной,
и я собираюсь еще не раз вернуться к ее обсуждению в теории и с более
практической точки. Например, возможно для многих остался не ясным
вопрос: какие же преимущества предоставляет использование ООП перед
более традиционным функциональным программированием? Ответить на него я
и собираюсь в одном из следующих постов, не пропустить публикацию
которого можно с помощью &lt;a href="/feed/"&gt;RSS&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Fri, 04 Jan 2008 21:39:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-01-04:theory/2008/obektno-orientirovannoe-programmirovanie-a-chto-zhe-eto/</guid><category>класс</category><category>объект</category><category>объектно-ориентированное программирование</category><category>ООП</category><category>ПО</category><category>Программирование</category><category>программное обеспечение</category></item></channel></rss>
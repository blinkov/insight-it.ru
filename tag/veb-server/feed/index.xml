<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Insight IT</title><link>https://www.insight-it.ru/</link><description></description><atom:link href="https://www.insight-it.ru/tag/veb-server/feed/index.xml" rel="self"></atom:link><lastBuildDate>Mon, 12 May 2008 09:00:00 +0400</lastBuildDate><item><title>Масштабируемые веб-архитектуры</title><link>https://www.insight-it.ru//theory/2008/masshtabiruemye-veb-arkhitektury/</link><description>&lt;p&gt;&lt;img alt="Масштабируемость" class="right" src="https://www.insight-it.ru/images/display.png"/&gt;
Уже немало слов было сказано по этой теме как в моем блоге, так и за
его пределами. Мне кажется настал подходящий момент для того, чтобы
перейти от частного к общему и попытаться взглянуть на данную тему
отдельно от какой-либо успешной ее реализации.&lt;/p&gt;
&lt;p&gt;Приступим?
&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Для начала имеет смысл определиться с тем, о чем мы вообще будем
говорить. В данном контексте перед веб-приложением ставятся три основные
цели:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;масштабируемость&lt;/strong&gt; - способность своевременно реагировать на
    непрерывный рост нагрузки и непредвиденные наплывы пользователей;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;доступность&lt;/strong&gt; - предоставление доступа к приложению даже в случае
    чрезвычайных обстоятельств;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;производительность&lt;/strong&gt; - даже малейшая задержка в загрузке страницы
    может оставить негативное впечатление у пользователя.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Основной темой разговора будет, как не трудно догадаться,
масштабируемость, но и остальные цели не думаю, что останутся в стороне.
Сразу хочется сказать пару слов про доступность, чтобы не возвращаться к
этому позднее, подразумевая как "само собой разумеется": любой сайт так
или иначе стремится к тому, чтобы функционировать максимально стабильно,
то есть быть доступным абсолютно всем своим потенциальным посетителям в
абсолютно каждый момент времени, но порой случаются всякие
непредвиденные ситуации, которые могут стать причиной временной
недоступности. Для минимизации потенциального ущерба доступности
приложения необходимо избегать наличия компонентов в системе,
потенциальный сбой в которых привел бы к недоступности какой-либо
функциональности или данных (или хотябы сайта в целом). Таким образом
каждый сервер или любой другой компонент системы должен иметь хотябы
одного дублера (не важно в каком режиме они будут работать: параллельно
или один "подстраховывает" другой, находясь при этом в пассивном
режиме), а данные должны быть реплицированы как минимум в двух
экземплярах (причем желательно не на уровне RAID, а на разных физических
машинах). Хранение нескольких резервных копий данных где-то отдельно от
основной системы (например на специальных сервисах или на отдельном
кластере) также поможет избежать многих проблем, если что-то пойдет не
так. Не стоит забывать и о финансовой стороне вопроса: подстраховка на
случай сбоев требует дополнительных существенных вложений в
оборудование, которые имеет смысл стараться минимизировать.&lt;/p&gt;
&lt;p&gt;Масштабируемость принято разделять на два направления:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Вертикальная масштабируемость&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Увеличение производительности каждого компонента системы c целью
повышения общей производительности.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Горизонтальная масштабируемость&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Разбиение системы на более мелкие структурные компоненты и
разнесение их по отдельным физическим машинам (или их группам) и/или
увеличение количества серверов параллельно выполняющих одну и ту же
функцию.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Так или иначе, при разработке стратегии роста системы приходится искать
компромис между ценой, временем разработки, итоговой производительность,
стабильностью и еще массой других критериев. С финансовой точки зрения
вертикальная масштабируемость является далеко не самым привлекательным
решением, ведь цены на сервера с большим количеством процессоров всегда
растут практически экспоненциально относительно количества процессоров.
Именно по-этому наиболее интересен горизонтальный подход, так как именно
он используется в большинстве случаев. Но и вертикальная
масштабируемость порой имеет право на существование, особенно в
ситуациях, когда основную роль играет время и скорость решения задачи, а
не финансовый вопрос: ведь купить БОЛЬШОЙ сервер существенно быстрее,
чем практически заново разрабатывать приложения, адаптируя его к работе
на большом количестве параллельно работающих серверов.&lt;/p&gt;
&lt;p&gt;Закончив с общими словами давайте перейдем к обзору потенциальных
проблем и вариантов их решений при горизонтальном масштабировании.
Просьба особо не критиковать - на абсолютную правильность и
достоверность не претендую, просто "мысли вслух", да и даже упомянуть
все моменты данной темы у меня определенно не получится.&lt;/p&gt;
&lt;h3 id="servery-prilozhenii"&gt;Серверы приложений&lt;/h3&gt;
&lt;p&gt;В процессе масштабирования самих приложений редко возникают проблемы,
если при разработке всегда иметь ввиду, что каждый экземпляр приложения
должен быть непосредственно никак не связан со своими "коллегами" и
должен иметь возможность обработать абсолютно любой запрос пользователя
вне зависимости от того где обрабатывались предыдущие запросы данного
пользователя и что конкретно он хочет от приложения в целом в текущий
момень.&lt;/p&gt;
&lt;p&gt;Далее, обеспечив независимость каждого отдельного запущенного
приложения, можно обрабатывать все большее и большее количество запросов
в единицу времени просто увеличивая количество параллельно
функционирующих серверов приложений, участвующих в системе. Все
достаточно просто (относительно).&lt;/p&gt;
&lt;h3 id="balansirovka-nagruzki"&gt;Балансировка нагрузки&lt;/h3&gt;
&lt;p&gt;Следущая задача - равномерно распределить запросы между доступными
серверами приложений. Существует масса подходов к решению этой задачи и
еще больше продуктов, предлагающих их конкретную реализацию.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Оборудование&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Сетевое оборудование, позволяющее распределять нагрузку между
несколькими серверами, обычно стоит достаточно внушительные суммы,
но среди прочих вариантов обычно именно этот подход предлагает
наивысшую производительность и стабильность (в основном благодаря
качеству, плюс такое оборудование иногда поставляется парами,
работающими по принципу
&lt;a href="https://www.insight-it.ru/goto/a40f2b94/" rel="nofollow" target="_blank" title="http://en.wikipedia.org/wiki/Heartbeat_%28program%29"&gt;HeartBeat&lt;/a&gt;).
В этой индустрии достаточно много серьезных брендов, предлагающих
свои решения - есть из чего выбрать: &lt;em&gt;Cisco&lt;/em&gt;, &lt;em&gt;Foundry&lt;/em&gt;, &lt;em&gt;NetScalar&lt;/em&gt;
и многие другие.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Программное обеспечение&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;В этой области еще большее разнообразие возможных вариантов.
Получить программно производительность сопоставимую с аппаратными
решениями не так-то просто, да и HeartBeat придется обеспечивать
программно, но зато оборудование для функционирования такого решения
представляет собой обычный сервер (возможно не один). Таких
программных продуктов достаточно много, обычно они представляют
собой просто HTTP-серверы, перенаправляющие запросы своим коллегам
на других серверах вместо отправки напрямую на обработку
интерпретатору языка программирования. Для примера можно упомянуть,
скажем, &lt;a href="/tag/nginx/"&gt;nginx&lt;/a&gt; с &lt;code&gt;mod_proxy&lt;/code&gt;. Помимо этого имеют
место более экзотические варианты, основанные на DNS, то есть в
процессе определения клиентом IP-адреса сервера с необходимым ему
интернет-ресурсов адрес выдается с учетом нагрузки на доступные
сервера, а также некоторых географических соображений.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Каждый вариант имеет свой ассортимент положительных и отрицательных
сторон, именно по-этому однозначного решения этой задачи не существует -
каждый вариант хорош в своей конкретной ситуации. Не стоит забывать, что
никто не ограничивает Вас в использовании лишь одного из них, при
необходимости может запросто быть реализована и практически произвольная
комбинация из них.&lt;/p&gt;
&lt;h3 id="resursoemkie-vychisleniia"&gt;Ресурсоемкие вычисления&lt;/h3&gt;
&lt;p&gt;Во многих приложениях используются какие-либо сложные механизмы, это
может быть конвертирование видео, изображений, звука, или просто
выполнение каких-либо ресурсоемких вычислений. Такие задачи требует
отдельного внимания если мы говорим о Сети, так как пользователь
интернет-ресурса врядли будет счастлив наблюдать за загружающейся
несколько минут страницей в ожидании лишь для того, чтобы увидеть
сообщение вроде: "Операция завершена успешно!".&lt;/p&gt;
&lt;p&gt;Для избежания подобных ситуаций стоит постараться минимизировать
выполнение ресурсоемких операций синхронно с генерацией интернет
страниц. Если какая-то конкретная операция не влияет на новую страницу,
отправляемую пользователю, то можно просто организовать &lt;em&gt;очередь&lt;/em&gt;
заданий, которые необходимо выполнить. В таком случае в момент когда
пользователь совершил все действия, необходимые для начала операции,
сервер приложений просто добавляет новое задание в очередь и сразу
начинает генерировать следущую страницу, не дожидаясь результатов. Если
задача на самом деле очень трудоемкая, то такая очередь и обработчики
заданий могут располагаться на отдельном сервере или кластере.&lt;/p&gt;
&lt;p&gt;Если результат выполнения операции задействован в следующей странице,
отправляемой пользователю, то при асинхронном ее выполнении придется
несколько схитрить и как-либо отвлечь пользователя на время ее
выполнения. Например, если речь идет о конвертировании видео в &lt;strong&gt;flv&lt;/strong&gt;,
то например можно быстро сгенерировать скриншот с первым кадром в
процессе составления страницы и подставить его на место видео, а
возможность просмотра динамически добавить на страницу уже после, когда
конвертирование будет завершено.&lt;/p&gt;
&lt;p&gt;Еще один неплохой метод обработки таких ситуаций заключается просто в
том, чтобы попросить пользователя "зайти попозже". Например, если сервис
генерирует скриншоты веб-сайтов из различных браузеров с целью
продемонстрировать правильность их отображения владельцам или просто
интересующимся, то генерация страницы с ними может занимать даже не
секунды, а минуты. Наиболее удобным для пользователя в такой ситуации
будет предложение посетить страницу по указанному адресу через
столько-то минут, а не ждать у моря погоды неопределенный срок.&lt;/p&gt;
&lt;h3 id="sessii"&gt;Сессии&lt;/h3&gt;
&lt;p&gt;Практически все веб-приложения каким-либо образом взаимодействуют со
своими посетителями и в подавляющем большинстве случаев в них
присутствует необходимость отслеживать перемещения пользователей по
страницам сайта. Для решения этой задачи обычно используется механизм
&lt;em&gt;сессий&lt;/em&gt;, который заключается в присвоении каждому посетителю
уникального идентификационного номера, который ему передается для
хранения в cookies или, в случае их отсутствия, для постоянного
"таскания" за собой через GET. Получив от пользователя некий ID вместе с
очередным HTTP-запросом сервер может посмотреть в список уже выданных
номеров и однозначно определить кто его отправил. С каждым ID может
ассоциироваться некий набор данных, который веб-приложение может
использовать по своему усмотрению, эти данные обычно по-умолчанию
хранятся в файле во временной директории на сервере.&lt;/p&gt;
&lt;p&gt;Казалось бы все просто, но... но запросы посетителей одного и того же
сайта могут обрабатывать сразу несколько серверов, как же тогда
определить не был ли выдан полученный ID на другом сервере и где вообще
хранятся его данные?&lt;/p&gt;
&lt;p&gt;Наиболее распространенными решениями является централизация или
децентрализация сессионных данных. Несколько абсурдная фраза, но,
надеюсь, пара примеров сможет прояснить ситуацию:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Централизованное хранение сессий&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Идея проста: создать для всех серверов общую "копилку", куда они
смогут складывать выданные ими сессии и узнавать о сессиях
посетителей других серверов. В роли такой "копилки" теоретически
может выступать и просто примонтированная по сети файловая система,
но по некоторым причинам более перспективным выглядит использование
какой-либо СУБД, так как это избавляет от массы проблем, связанных с
хранением сессионных данных в файлах. Но в варианте с общей базой
данных не стоит забывать, что нагрузка на него будет неуклонно расти
с ростом количества посетителей, а также стоит заранее предусмотреть
варианты выхода из проблематичных ситуаций, связанных с
потенциальными сбоями в работе сервера с этой СУБД.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Децентрализованное хранение сессий&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Наглядный пример - хранение сессий в &lt;a href="/tag/memcached/"&gt;memcached&lt;/a&gt;,
изначально расчитанная на распределенное хранение данных в
оперативной памяти система позволит получать всем серверам быстрый
доступ к любым сессионным данным, но при этом (в отличии от
предыдущего способа) какой-либо единый центр их хранения будет
отсутствовать. Это позволит избежать узких мест с точек зрения
производительности и стабильности в периоды повышенных нагрузок.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;В качестве альтернативы сессиям иногда используют похожие по
предназначению механизмы, построенные на cookies, то есть все
необходимые приложению данные о пользователе хранятся на клиентской
стороне (вероятно в зашифрованном виде) и запрашиваются по мере
необходимости. Но помимо очевидных преимуществ, связанных с отсутствием
необходимости хранить лишние данные на сервере, возникает ряд проблем с
безопасностью. Данные, хранимые на стороне клиента даже в зашифрованном
виде, представляют собой потенциальную угрозу для функционирования
многих приложений, так как любой желающий может попытаться
модифицировать их в своих интересах или с целью навредить приложению.
Такой подход хорош только если есть уверенность, что абсолютно любые
манипуляции с хранимые у пользователей данными безопасны. Но можно ли
быть уверенными на 100%?&lt;/p&gt;
&lt;h3 id="staticheskii-kontent"&gt;Статический контент&lt;/h3&gt;
&lt;p&gt;Пока объемы статических данных невелики - никто не мешает хранить их в
локальной файловой системе и предоставлять доступ к ним просто через
отдельный легковесный веб-сервер вроде &lt;a href="/tag/lighttpd/"&gt;lighttpd&lt;/a&gt; (я
подразумеваю в основном разные формы медиа-данных), но рано или поздно
лимит сервера по дисковому пространству или файловой системы по
количеству файлов в одной директории будет достигнут, и придется думать
о перераспределении контента. Временным решением может стать
распределение данных по их типу на разные сервера, или, возможно,
использование иерархической структуры каталогов.&lt;/p&gt;
&lt;p&gt;Если статический контент играет одну из основных ролей в работе
приложения, то стоит задуматься о применении распределенной файловой
системы для его хранения. Это, пожалуй, один из немногих способов
горизонтально масштабировать объем дискового пространства путем
добавления дополнительных серверов без каких-либо кардинальных изменений
в работе самого приложения. На какой именно кластерной файловой системе
остановить свой выбор ничего сейчас советовать не хочу, я уже
опубликовал далеко не один обзор конкретных реализаций - попробуйте
прочитать их все и сравнить, если этого мало - вся остальная Сеть в
Вашем распоряжении.&lt;/p&gt;
&lt;p&gt;Возможно такой вариант по каким-либо причинам будет нереализуем, тогда
придется "изобретать велосипед" для реализации на уровне приложения
принципов схожих с сегментированием данных в отношении СУБД, о которых я
еще упомяну далее. Этот вариант также вполне эффективен, но требует
модификации логики приложения, а значит и выполнение дополнительной
работы разработчиками.&lt;/p&gt;
&lt;p&gt;Альтернативой этим подходам выступает использование так называемых
&lt;strong&gt;Content Delievery Network&lt;/strong&gt; - внешних сервисов, обеспечивающих
доступность Вашего контента пользователям за определенное материальное
вознаграждение сервису. Преимущество очевидно - нет необходимости
организовывать собственную инфраструктуру для решения этой задачи, но
зато появляется другая дополнительная статья расходов. Список таких
сервисов приводить не буду, если кому-нибудь понадобится - найти будет
не трудно.&lt;/p&gt;
&lt;h3 id="keshirovanie"&gt;Кэширование&lt;/h3&gt;
&lt;p&gt;Кэширование имеет смысл проводить на всех этапах обработки данных, но в
разных типах приложений наиболее эффективными являются лишь некоторые
методы кэширования.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;СУБД&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Практически все современные СУБД предоставляют встроенные механизмы
для кэширования результатов определенных запросов. Этот метод
достаточно эффективен, если Ваша система регулярно делает одни и те
же выборки данных, но также имеет ряд недостатков, основными из
которых является инвалидация кэша всей таблицы при малейшем ее
изменении, а также локальное расположение кэша, что неэффективно при
наличии нескольких серверов в системе хранения данных.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Приложение&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;На уровне приложений обычно производится кэширование объектов любого
языка программирования. Этот метод позволяет вовсе избежать
существенной части запросов к СУБД, сильно снижая нагрузку на нее.
Как и сами приложения такой кэш должен быть независим от конкретного
запроса и сервера, на котором он выполняется, то есть быть доступным
всем серверам приложений одновременно, а еще лучше - быть
распределенным по нескольким машинам для более эффективной
утилизации оперативной памяти. Лидером в этом аспекте кэширования по
праву можно назвать &lt;a href="/tag/memcached/"&gt;memcached&lt;/a&gt;, о котором я в свое
время уже успел &lt;a href="https://www.insight-it.ru/storage/2008/obzor-memcached/"&gt;подробно рассказать&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;HTTP-сервер&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Многие веб-серверы имеют модули для кэширования как статического
контента, так и результатов работы скриптов. Если страница редко
обновляется, то использование этого метода позволяет без каких-либо
видимых для пользователя изменений избегать генерации страницы в
ответ на достаточно большую часть запросов.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Reverse proxy&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Поставив между пользователем и веб-сервером прозрачный
прокси-сервер, можно выдавать пользователю данные из кэша прокси
(который может быть как в оперативной памяти, так и дисковым), не
доводя запросы даже до HTTP-серверов. В большинстве случаев этот
подход актуален только для статического контента, в основном разных
форм медиа-данных: изображений, видео и тому подобного. Это
позволяет веб-серверам сосредоточиться только на работе с самими
страницами.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Кэширование по своей сути практически не требует дополнительных затрат
на оборудование, особенно если внимательно наблюдать за использованием
оперативной памяти остальными компонентами серверами и утилизировать все
доступные "излишки" под наиболее подходящие конкретному приложению формы
кэша.&lt;/p&gt;
&lt;p&gt;Инвалидация кэша в некоторых случаях может стать нетривиальной задачей,
но так или иначе универсального решения всех возможных проблем с ней
связанных написать не представляется возможным (по крайней мере лично
мне), так что оставим этот вопрос до лучших времен. В общем случае
решение этой задачи ложится на само веб-приложение, которое обычно
реализует некий механизм инвалидации средствами удаления объекта кэша
через определенный &lt;em&gt;период времени&lt;/em&gt; после его создания или последнего
использования, либо "вручную" при возникновении определенных &lt;em&gt;событий&lt;/em&gt;
со стороны пользователя или других компонентов системы.&lt;/p&gt;
&lt;h3 id="bazy-dannykh"&gt;Базы данных&lt;/h3&gt;
&lt;p&gt;На закуску я оставил самое интересное, ведь этот неотъемлемый компонент
любого веб-приложения вызывает больше проблем при росте нагрузок, чем
все остальные вместе взятые. Порой даже может показаться, что стоит
вообще отказаться от горизонтального масштабирования системы хранения
данных в пользу вертикального - просто купить тот самый БОЛЬШОЙ сервер
за шести- или семизначную сумму не-рублей и не забивать себе голову
лишними проблемами.&lt;/p&gt;
&lt;p&gt;Но для многих проектов такое кардинальное решение (и то, по большому
счету, временное) не подходит, а значит перед ними осталась лишь одна
дорога - горизонтальное масштабирование. О ней и поговорим.&lt;/p&gt;
&lt;p&gt;Путь практически любого веб проекта с точки зрения баз данных начинался
с одного простого сервера, на котором работал весь проект целиком. Затем
в один прекрасный момент наступает необходимость вынести СУБД на
отдельный сервер, но и он со временем начинает не справляться с
нагрузкой. Подробно останавливаться на этих двух этапах смысла особого
нет - все относительно тривиально.&lt;/p&gt;
&lt;p&gt;Следующим шагом обычно бывает &lt;strong&gt;master-slave&lt;/strong&gt; с асинхронной репликацией
данных, как работает эта схема уже неоднократно упоминалось в блоге, но,
пожалуй, повторюсь: при таком подходе все операции записи выполняются
лишь на одном сервере (master), а остальные сервера (slave) получают
данные напрямую от "мастера", обрабатывая при этом лишь запросы на
чтение данных. Как известно, операции чтения и записи любого веб-проекта
всегда растут пропорционально росту нагрузки, при этом сохраняется почти
фиксированным соотношение между обоими типами запросов: на каждый запрос
на обновление данных обычно приходится в среднем около десятка запросов
на чтение. Со временем нагрузка растет, а значит растет и количество
операций записи в единицу времени, а сервер-то обрабатывает их всего
один, а затем он же еще и обеспечивает создание некоторого количества
копий на других серверах. Рано или поздно издержки операций репликации
данных станут быть настолько высоки, что этот процесс станет занимать
очень большую часть процессорного времени каждого сервера, а каждый
slave сможет обрабатывать лишь сравнительно небольшое количество
операций чтения, и, как следствие, каждый дополнительный slave-сервер
начнет увеличивать суммарную производительность лишь незначительно, тоже
занимаясь по большей части лишь поддержанием своих данных в соответствии
с "мастером".&lt;/p&gt;
&lt;p&gt;Временным решением этой проблемы, возможно, может стать замена
master-сервера на более производительный, но так или иначе не выйдет
бесконечно откладывать переход на следующий "уровень" развития системы
хранения данных: &lt;strong&gt;"sharding"&lt;/strong&gt;, которому я совсем недавно посвятил
&lt;a href="https://www.insight-it.ru/theory/2008/segmentirovanie-bazy-dannykh/"&gt;отдельный пост "Сегментирование баз данных"&lt;/a&gt;.
Так что позволю себе остановиться на нем лишь вкратце: идея заключается
в том, чтобы разделить все данные на части по какому-либо признаку и
хранить каждую часть на отдельном сервере или кластере, такую часть
данных в совокупности с системой хранения данных, в которой она
находится, и называют сегментом или &lt;em&gt;shard&lt;/em&gt;&amp;rsquo;ом. Такой подход позволяет
избежать издержек, связанных с реплицированием данных (или сократить их
во много раз), а значит и &lt;em&gt;существенно&lt;/em&gt; увеличить общую
производительность системы хранения данных. Но, к сожалению, переход к
этой схеме организации данных требует массу издержек другого рода. Так
как готового решения для ее реализации не существует, приходится
модифицировать логику приложения или добавлять дополнительную
"прослойку" между приложением и СУБД, причем все это чаще всего
реализуется силами разработчиков проекта. Готовые продукты способны лишь
облегчить их работу, предоставив некий каркас для построения основной
архитектуры системы хранения данных и ее взаимодействия с остальными
компонентами приложения.&lt;/p&gt;
&lt;p&gt;На этом этапе цепочка обычно заканчивается, так как сегментированные
базы данных могут горизонтально масштабироваться для того, чтобы в
полной мере удовлетворить потребности даже самых высоконагруженных
интернет-ресурсов. К месту было бы сказать пару слов и о собственно
самой структуре данных в рамках баз данных и организации доступа к ним,
но какие-либо решения сильно зависят от конкретного приложения и
реализации, так что позволю себе лишь дать пару общих рекомендаций:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Денормализация&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Запросы, комбинирующие данные из нескольких таблиц, обычно при
прочих равных требуют большего процессорного времени для выполнения,
чем запрос, затрагивающий лишь одну таблицу. А производительность,
как уже упоминалось в начале повествования, чрезвычайно важна на
просторах Сети.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Логическое разбиение данных&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Если какая-то часть данных всегда используется отдельно от основной
массы, то иногда имеет смысл выделить ее в отдельную независимую
систему хранения данных.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Низкоуровневая оптимизация запросов&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Ведя и анализируя логи запросов, можно определить наиболее медленные
из них. Замена найденных запросов на более эффективные с той же
функциональностью может помочь более рационально использовать
вычислительные мощности.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;В этом разделе стоит упомянуть еще один, более специфический, тип
интернет-проектов. Такие проекты оперируют данными, не имеющими четко
формализованную структуру, в таких ситуациях использование реляционных
СУБД в качестве хранилища данных, мягко говоря, нецелесообразно. В этих
случаях обычно используют менее строгие базы данных, с более примитивной
функциональностью в плане обработки данных, но зато они способны
обрабатывать огромные объемы информации не придираясь к его качеству и
соответствию формату. В качестве основы для такого хранилища данных
может служить кластерная файловая система, а для анализа же данных в
таком случае используется механизм под названием
&lt;a href="/tag/mapreduce/"&gt;MapReduce&lt;/a&gt;, принцип его работы я расскажу лишь вкратце,
так как в полном своем масштабе он несколько выходит за рамки данного
повествования.&lt;/p&gt;
&lt;p&gt;Итак, мы имеем на входе некие произвольные данные в не факт что
правильно соблюденном формате. В результате нужно получить некое
итоговое значение или информацию. Согласно данному механизму практически
любой анализ данных можно провести в следующие два этапа:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Основной целью данного этапа является представление произвольных
входных данных в виде промежуточных пар ключ-значение, имеющих
определенный смысл и формально оформленных. Результаты подвергаются
сортировке и группированию по ключу, а после чего передаются на
следующий этап.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Reduce&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Полученные после &lt;strong&gt;map&lt;/strong&gt; значения используются для финального
вычисления требуемых итоговых данных.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Каждый этап каждого конкретного вычисления реализуется в виде
независимого мини-приложения. Такой подход позволяет практически
неограниченно распараллеливать вычисления на огромном количестве машин,
что позволяет в мгновения обрабатывать объемы практически произвольных
данных. Для этого достаточно лишь запустить эти приложения на каждом
доступном сервере одновременно, а затем собрать воедино все результаты.&lt;/p&gt;
&lt;p&gt;Примером готового каркаса для реализации работы с данными по такому
принципу служит opensource проект Apache Foundation под названием
&lt;a href="https://www.insight-it.ru/storage/2008/hadoop/"&gt;&lt;em&gt;Hadoop&lt;/em&gt;&lt;/a&gt;, о котором я уже неоднократно
рассказывал ранее, да и &lt;a href="https://www.insight-it.ru/goto/1a5b89d0/" rel="nofollow" target="_blank" title="http://ru.wikipedia.org/wiki/Hadoop"&gt;статейку в Википедию&lt;/a&gt; написал в свое время.&lt;/p&gt;
&lt;h3 id="vmesto-zakliucheniia"&gt;Вместо заключения&lt;/h3&gt;
&lt;p&gt;Если честно, мне с трудом верится, что я смог написать настолько
всеобъемлющий пост и сил на подведение итогов уже практически не
осталось. Хочется лишь сказать, что в разработке крупных проектов важна
каждая деталь, а неучтенная мелочь может стать причиной провала. Именно
по-этому в этом деле учиться стоит не на своих ошибках, а на чужих.&lt;/p&gt;
&lt;p&gt;Хоть может быть этот текст и выглядит как некое обобщение всех постов из
серии &lt;a href="https://www.insight-it.ru/highload/"&gt;"Архитектуры высоконагруженных систем"&lt;/a&gt;, но врядли он
станет финальной точкой, надеюсь мне &lt;a href="/feed/"&gt;найдется что сказать&lt;/a&gt; по
этой теме и в будущем, может быть однажды это будет основано и на личном
опыте, а не просто будет результатом переработки массы полученной мной
информации. Кто знает?...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Mon, 12 May 2008 09:00:00 +0400</pubDate><guid>tag:www.insight-it.ru,2008-05-12:theory/2008/masshtabiruemye-veb-arkhitektury/</guid><category>online</category><category>архитектура</category><category>веб-приложение</category><category>веб-проект</category><category>веб-сервер</category><category>геораспределение</category><category>информационные технологии</category><category>кэширование</category><category>Масштабируемость</category><category>распределенные вычисления</category><category>сегментирование баз данных</category></item><item><title>Веб-сервер за два вечера</title><link>https://www.insight-it.ru//linux/2008/web-server-za-dva-vechera/</link><description>&lt;p&gt;&lt;img alt="Beastie" class="left" src="https://www.insight-it.ru/images/beastie.png" title="Beastie: The BSD Daemon"/&gt;
Многие из вас наверняка все еще помнят те времена, когда компьютерная
техника находилась лишь на ранней стадии своего развития. Позволить себе
иметь в личном распоряжении персональный компьютер мог далеко не каждый,
а о серверном оборудовании и вовсе не могло быть и речи.&lt;/p&gt;
&lt;p&gt;Но, к счастью, времена меняются, и на сегодняшний день покупка даже
серверного оборудования связана с достаточно скромными затратами,
сопоставимыми с бюджетом покупки настольного компьютера или ноутбука. Но
возникает другой вопрос - а что же с этим оборудованием делать? Вполне
логичным ответом было бы: "использовать по прямому назначению", о чем мы
с Вами сегодня и поговорим в компании с замечательным персонажем по
имени &lt;em&gt;&lt;a href="/tag/beastie/"&gt;Beastie&lt;/a&gt;&lt;/em&gt; и операционной системой
&lt;strong&gt;&lt;a href="/tag/freebsd/"&gt;FreeBSD&lt;/a&gt;&lt;/strong&gt;, с которой он частенько ассоциируется.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Под "использованием по прямому назначению" конечно же можно было
подразумевать множество разных применений, но я хотел все-таки
остановиться на варианте использования в роли веб-сервера, как
альтернативу многочисленным услугам по предоставлению shared и VPS
хостинга.&lt;/p&gt;
&lt;h3 id="predistoriia"&gt;Предистория&lt;/h3&gt;
&lt;p&gt;Некоторое время назад ко мне в руки попал простенький сервер, который
как раз предполагалось использовать как хостинг для одного из проектов.
Оставалось лишь сделать его пригодным для выполнения этой задачи.
Казалось бы дело это как минимум не тривиальное, но буквально через пару
дней мне довелось убедиться в обратном.&lt;/p&gt;
&lt;p&gt;Ассортимент оборудования, спрятанного внутри &lt;strong&gt;1U&lt;/strong&gt; корпуса, был вполне
стандартным, ничего особенного: процессор &lt;strong&gt;Intel Xeon 5335&lt;/strong&gt;,
оперативная память &lt;strong&gt;Kingston 2х2 GB ECC Full-buffered&lt;/strong&gt;, жесткий диск
изначально только один - &lt;strong&gt;WD 150 GB 10000rpm SATA&lt;/strong&gt;, а вот модель
материнской платы, к сожалению, на память назвать не могу, вроде что-то
от &lt;strong&gt;SuperMicro&lt;/strong&gt;, с простенькой встроенной видеокартой, сетевой картой
с двумя гигабитными Ethernet портами и встроенным же видимо software
RAID-контроллером. Опытный глаз наверняка заметил бы в этом списке
сильную недоукомплектацию, особенно проявляющуюся при упоминании
процессора в единственном числе, отсутствии RAID, и скромным объемам
оперативной памяти. Объясняется это достаточно просто - проект еще
предстоит тестировать перед запуском, а этой платформы для этого будет
более чем достаточно.&lt;/p&gt;
&lt;p&gt;Перед запуском проекта в открытое плавание естественно предстоит upgrade
оборудования.&lt;/p&gt;
&lt;h3 id="den-pervyi"&gt;День первый&lt;/h3&gt;
&lt;h4&gt;Подготовка&lt;/h4&gt;
&lt;p&gt;Если верить бумажкам, идущим в комплекте с сервером, на единственный
жестком диск в магазине установили демо-версию одной из серверных
операционных систем от одной мало кому известной корпорации. Смотреть
что это за зверь такой у меня особого желания не было, по-этому я не
долго думая пошел искать среди своей коллекции дистрибутивов болванку с
заранее выбранным &lt;a href="/tag/opensource/"&gt;opensource&lt;/a&gt; решением вопроса об
&lt;a href="/tag/os/"&gt;операционной системе&lt;/a&gt; - &lt;strong&gt;&lt;a href="/tag/freebsd/"&gt;FreeBSD 6.2&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Почему выбор пал именно на эту &lt;a href="/tag/os/"&gt;ОС&lt;/a&gt; объяснить не так уж и
просто, но я все же попробую. Выбор был достаточно классический:
&lt;em&gt;&lt;a href="/tag/unix/"&gt;Unix&lt;/a&gt; vs &lt;a href="/tag/linux/"&gt;Linux&lt;/a&gt;&lt;/em&gt;, возникали еще некоторые
сомнения насчет решений от &lt;em&gt;Sun&lt;/em&gt; в виде &lt;em&gt;Solaris&lt;/em&gt; и &lt;em&gt;OpenSolaris&lt;/em&gt;, но от
них я отказался достаточно быстро в основном из-за более чем скромной
документации и проприетарного происхождения, попутно закрыв глаза на все
положительные отзывы, которые я видел в Сети.&lt;/p&gt;
&lt;p&gt;Так как мне хотелось иметь иметь перед собой &lt;em&gt;конструктор&lt;/em&gt; для сбора
системы именно таким образом, как было бы удобно мне, а не разработчикам
дистрибутива, то список вариантов, выступавших на стороне
&lt;a href="/tag/linux/"&gt;Linux&lt;/a&gt; быстро начал сокращаться, начиная с &lt;strong&gt;CentOS&lt;/strong&gt;.
Предпоследним вычеркнутым из списка дистрибутивов &lt;a href="/tag/linux/"&gt;Linux&lt;/a&gt;
был &lt;strong&gt;Debian&lt;/strong&gt;, что оставило в нем лишь &lt;a href="/tag/gentoo/"&gt;Gentoo Linux&lt;/a&gt;.
Финальный выбор между &lt;a href="/tag/freebsd/"&gt;FreeBSD&lt;/a&gt; и &lt;a href="/tag/gentoo/"&gt;Gentoo&lt;/a&gt;
был сделан уже легче: во-первых, по &lt;a href="https://www.insight-it.ru/linux/2008/gentoo-linux-sony-vaio/"&gt;своему опыту с ноутбуком&lt;/a&gt; я уже понял, что с
&lt;a href="/tag/gentoo/"&gt;Gentoo&lt;/a&gt; предстояло бы немало хлопот, а, во-вторых, в новый
&lt;em&gt;конструктор&lt;/em&gt;, как ни крути, "играть" намного интереснее, чем в старый,
так что долго думать не пришлось :)&lt;/p&gt;
&lt;h4&gt;Установка&lt;/h4&gt;
&lt;p&gt;Найдя наконец диск с &lt;a href="/tag/freebsd/"&gt;FreeBSD&lt;/a&gt;, я попытался решить
следующий возникший вопрос: а как же установить операционную систему с
компакт-диска на компьютер, не имеющий соответствующего привода? Так как
сервер был запломбирован и находился на гарантии, вариант частично
разобрать и подключить обычный привод отпал сразу же, ровно как и
вариант с подключением внешнего привода по причине его отсутствия.
Подходящее решение было найдено практически сразу же, благо жесткие
диски подключались по принципу hotswap: вытащив жесткий диск без
развинчивания корпуса, я подключил его к подвернувшемуся под руку
настольному компьютеру, обладающему DVD-приводом. Загрузка прошла
успешно и я приступил к установке, руководствуясь &lt;a href="https://www.insight-it.ru/goto/358a772c/" rel="nofollow" target="_blank" title="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/book.html"&gt;FreeBSD Handbook&lt;/a&gt;,
пересказывать его особого желания у меня нет, остановлюсь лишь на
некоторых особенностях этого процесса.&lt;/p&gt;
&lt;p&gt;Первым этапом установки, где пришлось задуматься, был &lt;strong&gt;fdisk&lt;/strong&gt;
(разбиение диска на так называемые &lt;em&gt;slice&lt;/em&gt;). Для избежания путаницы для
самого себя, я решил, что размещу рабочие директории http-сервера и базы
данных в &lt;strong&gt;/var&lt;/strong&gt;, которую и выделил в отдельный &lt;em&gt;slice&lt;/em&gt;, занимающий
б&lt;em&gt;о&lt;/em&gt;льшую часть доступного дискового пространства. В ассортимент
доступного при установке программного обеспечения я особо вникать не
стал, так как знал, что у меня всегда будет возможность заняться им
позже, и как следствие этого выбрал что-то очень близкое к стандартному
набору &lt;a href="/tag/po/"&gt;ПО&lt;/a&gt;.
Подтвердив установку и подождав достаточно непродолжительный период
времени, я перезагрузил систему, вытащив установочный диск в процессе.
Установка оказалась на удивление элементарной, что привело к полученной
с первой попытки работоспособной системе. Увидев долгожданное
приглашение к вводу логина и пароля я убедился, что могу
беспрепятственно получить доступ к консоли и сразу же выключил систему,
чтобы перенести жесткий диск обратно на сервер.&lt;/p&gt;
&lt;p&gt;Так как сетевое подключение еще только предстояло настроить, то на
сервер переносить пришлось не только жесткий диск, но и монитор с
клавиатурой. На новом оборудовании все так же прекрасно запустилось, и я
принялся за настройку подключения. Особых проблем не возникло - в
&lt;a href="https://www.insight-it.ru/goto/ecbcc1a6/" rel="nofollow" target="_blank" title="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/book.html#NETWORK-COMMUNICATION"&gt;Handbook&lt;/a&gt;'е
все более чем качественно задокументировано, самым сложным был процесс
выбора драйвера, вернее осознавание того, что он изначально правильно
сам установился. Следующей маленькой проблемой было угадывание какой же
из &lt;em&gt;Ethernet&lt;/em&gt;-портов был только что настроен, и, соответственно,
подключение кабеля именно в него, а не в его соседа. После завершения
всех манипуляций я с радостью обнаружил, что &lt;strong&gt;ping&lt;/strong&gt; от сервера до
gateway'а успешно проходит, что по сути и означало окончание настройки
сетевого подключения.
Следущей целью было избавить себя от необходимости пользоваться
позаимствованными у другого компьютера клавиатурой и монитором. Дело
тоже оказалось достаточно нехитрым, &lt;strong&gt;sshd&lt;/strong&gt; установился и настроился
вполне самостоятельно где-то в процессе установки, от меня потребовалось
лишь создать дополнительного пользователя, написать нехитрую строчку в
&lt;strong&gt;rc.conf&lt;/strong&gt;: &lt;code&gt;sshd_enable="YES"&lt;/code&gt; и собственно запустить daemon'а. Этого
было вполне достаточно, чтобы набрав на своем &lt;a href="/tag/noutbuk/"&gt;ноутбуке&lt;/a&gt;
&lt;strong&gt;ssh&lt;/strong&gt; в консоли, с указанием необходимых параметров, получить
удаленный доступ к серверу по протоколу &lt;strong&gt;SSH&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Решив, что для начала этого будет вполне достаточно, я отправился по
другим делам, так как тот вечер еще даже не успел подойти к своему
завершению.&lt;/p&gt;
&lt;h3 id="den-vtoroi"&gt;День второй&lt;/h3&gt;
&lt;h4&gt;Программное обеспечение&lt;/h4&gt;
&lt;p&gt;Хорошо, вполне работоспособную &lt;a href="/tag/os/"&gt;операционную систему&lt;/a&gt; мы
получили. Осталось снабдить ее необходимым &lt;a href="/tag/po/"&gt;программным обеспечением&lt;/a&gt; для выполнения своих обязанностей, определенных
нами заранее.&lt;/p&gt;
&lt;p&gt;Прежде чем что-либо устанавливать, очень не пожалел, что ознакомился как
с соответствующим &lt;a href="https://www.insight-it.ru/goto/6ffb90d6/" rel="nofollow" target="_blank" title="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/book.html#PORTS"&gt;разделом handbook'a&lt;/a&gt;,
так и с &lt;a href="https://www.insight-it.ru/goto/a3e92771/" rel="nofollow" target="_blank" title="http://www.freebsd.org/ports/"&gt;доступным ассортиментом ПО&lt;/a&gt;.
После этого я перешел-таки собственно к выбору и установке
&lt;a href="/tag/po/"&gt;ПО&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Так как одной из основных составных частей практически любого
    веб-сервера является http-daemon, именно с его выбора я и решил
    начать. Причем начал еще задолго до описываемых событий, вся
    многофункциональность &lt;a href="/tag/apache/"&gt;Apache&lt;/a&gt; мне была не нужна, а
    аналоги &lt;code&gt;mod_auth&lt;/code&gt; и &lt;code&gt;mod_rewrite&lt;/code&gt; есть и в более легких
    http-серверах. Cамо веб-приложение, которое там предполагалось
    располагать, работает по большей части на &lt;a href="/tag/php/"&gt;PHP&lt;/a&gt;, так что
    ничего особенного от httpd совсем не требовалось. В итоге финальный
    выбор был между &lt;em&gt;быстрыми&lt;/em&gt; и &lt;em&gt;легкими&lt;/em&gt; вариантами: &lt;strong&gt;&lt;a href="/tag/nginx/"&gt;nginx&lt;/a&gt;&lt;/strong&gt; и &lt;strong&gt;&lt;a href="/tag/lighttpd/"&gt;lighttpd&lt;/a&gt;&lt;/strong&gt;, какой-либо весомой причины по которой я выбрал &lt;strong&gt;&lt;a href="/tag/lighttpd/"&gt;lighttpd&lt;/a&gt;&lt;/strong&gt; с &lt;code&gt;mod\_fastcgi&lt;/code&gt; привести
    не могу, основным фактором был мой некоторый опыт работы с ним в
    прошлом, и отсутствие такового в отношении &lt;strong&gt;&lt;a href="/tag/nginx/"&gt;nginx&lt;/a&gt;&lt;/strong&gt;. Установка
    прошла легко и непринужденно с помощью в сжатые сроки найденного в
    &lt;a href="/tag/google/"&gt;Google&lt;/a&gt;
&lt;a href="https://www.insight-it.ru/goto/14d0519d/" rel="nofollow" target="_blank" title="http://www.cyberciti.biz/faq/howto-setup-lighttpd-fastcgi-php-server/"&gt;мануала&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Другим немаловажным компонентом сервера является &lt;strong&gt;ftpd&lt;/strong&gt;, как
    известно используемый для передачи файлов. Собственно говоря, если
    активное его использование не планируется, то особого значения какой
    именно сервер будет использоваться значения не имеет: любой из
    доступных устанавливается настраивается в пару простых шагов без
    каких-либо проблем (если это имеет значение - я выбрал &lt;strong&gt;vsftpd&lt;/strong&gt;,
    так как мне уже далеко не один раз доводилось его настраивать на
    домашних компьютерах, и, как следствие, даже инструкция не
    понадобилась). Но при потенциальной возможности работы через
    Интернет, этот протокол является достаточно уязвимым, так как не
    использует никакого шифрования. Эта проблема решается с помощью
    механизма &lt;em&gt;FTP over SSH&lt;/em&gt;, который представляет собой использование
    &lt;strong&gt;SSH&lt;/strong&gt; в роли туннеля для передачи файлов по &lt;strong&gt;FTP&lt;/strong&gt;. О том, как
    воспользоваться этим механизмом вам подскажет &lt;strong&gt;man ssh&lt;/strong&gt;,
    какой-либо дополнительной конфигурации он не требует, разве что
    настройки соответствующим образом firewall'а, но об этом я расскажу
    позже.&lt;/li&gt;
&lt;li&gt;Сам &lt;a href="/tag/php/"&gt;PHP&lt;/a&gt; установлен последней доступной в
    &lt;a href="https://www.insight-it.ru/goto/a3e92771/" rel="nofollow" target="_blank" title="http://www.freebsd.org/ports/"&gt;ports&lt;/a&gt; версии и , как уже
    упоминалось, был подключен к &lt;a href="/tag/lighttpd/"&gt;lighttpd&lt;/a&gt; с помощью
    &lt;code&gt;mod_fastcgi&lt;/code&gt;, какой-либо дополнительной конфигурации с моей
    стороны не потребовалось, я разве что выбрал список модулей (в
    общем-то тоже занятие не сложное, достаточно лишь осознавать какие
    именно используются, плюс я еще решил
    &lt;strong&gt;&lt;a href="https://www.insight-it.ru/goto/41a25ac6/" rel="nofollow" target="_blank" title="http://www.hardened-php.net/suhosin/"&gt;Suhosin&lt;/a&gt;&lt;/strong&gt; установить) и
    просто просмотрел по диагонали все конфиги (в основном сам
    &lt;strong&gt;php.ini&lt;/strong&gt; и &lt;strong&gt;lighttpd.conf&lt;/strong&gt;) на предмет их соответствия
    потребностям моего приложения. Отдельная история возникла с лишь
    одним модулем - &lt;em&gt;&lt;a href="/tag/blitz/"&gt;Blitz&lt;/a&gt;&lt;/em&gt;, который на данный момент все
    еще отсутствует в репозиториях как &lt;a href="/tag/freebsd/"&gt;FreeBSD&lt;/a&gt;, так и
    подавляющего большинства (если не всех) дистрибутивов
    &lt;a href="/tag/linux/"&gt;Linux&lt;/a&gt;. Его пришлось устанавливать вручную из
    исходников по &lt;a href="https://www.insight-it.ru/goto/1e985790/" rel="nofollow" target="_blank" title="http://alexeyrybak.com/blitz/blitz_ru.html#install_config.install"&gt;соответствующему мануалу&lt;/a&gt;,
    что правда тоже дело не хитрое и заняло всего несколько минут.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="/tag/subd/"&gt;СУБД&lt;/a&gt;&lt;/strong&gt; особо выбирать не пришлось - приложение
    написано было с расчетом на &lt;strong&gt;&lt;a href="/tag/postgresql/"&gt;PostrgeSQL&lt;/a&gt;&lt;/strong&gt;, ее
    соответственно и прикручивал к &lt;strong&gt;&lt;a href="/tag/php/"&gt;PHP&lt;/a&gt;.&lt;/strong&gt; Этот этап был
    пожалуй одним из самых проблематичных, так как сразу после
    классического &lt;code&gt;make install clean&lt;/code&gt; соответствующий daemon
    запускаться отказался. Какого-либо осознанного сообщения об ошибке
    &lt;code&gt;/usr/local/etc/rc.d/postgresqld start&lt;/code&gt; не выводило как в консоль,
    так и в логи, но тем не менее консольный клиент &lt;strong&gt;psql&lt;/strong&gt; и само
    веб-приложение жаловались на отсутствие запущенной
    &lt;a href="/tag/subd/"&gt;СУБД&lt;/a&gt;. Этот факт сильно затруднял поиск возможных
    вариантов решения на просторах &lt;a href="/tag/internet/"&gt;Сети&lt;/a&gt;, так что не
    найдя ничего полезного я решил заняться диагностикой проблемы и
    поиском решения для нее самостоятельно. Методом проб и ошибок,
    перебрав множество возможных вариантов запуска daemon'а, я пришел к
    выводу, что у пользователя от имени которого он должен был
    запускаться явно проблемы с доступом к файловой системе. Видимо так
    получилось из-за нестандартного расположения самой базы данных - в
    директории &lt;strong&gt;/var&lt;/strong&gt;. Не смотря на тот факт, что &lt;strong&gt;chown&lt;/strong&gt; и
    &lt;strong&gt;chmod&lt;/strong&gt; были использованы по прямому назначению в отношении
    соответствующих директорий для установления прав доступа. В итоге
    оказалось, что директория указанная для этого пользователя как
    домашняя (по памяти пишу, могу ошибиться, но вроде
    &lt;strong&gt;/usr/local/pgsql&lt;/strong&gt;) по каким-то причинам не создалась и
    соответственно именно этот факт и мешал запуску daemon'а.
    Восстановив справедливость в отношении этого пользователя, я
    обнаружил, что &lt;strong&gt;&lt;a href="/tag/postgresql/"&gt;PostrgeSQL&lt;/a&gt;&lt;/strong&gt; успешно
    запустился-таки, а мое приложение тоже стало функционировать именно
    так, как ему было положено. Проверив содержимое соответствующего
    конфига, я решил его больше не трогать, а то как говорится
    "premature optimization is the root of all evil"&amp;amp;copyright;. За
    компанию решил установить веб-интерфейс к
    &lt;a href="/tag/postgresql/"&gt;PostrgeSQL&lt;/a&gt; - &lt;strong&gt;phppgadmin&lt;/strong&gt;. Собравшись из
    &lt;a href="https://www.insight-it.ru/goto/a3e92771/" rel="nofollow" target="_blank" title="http://www.freebsd.org/ports/"&gt;портов&lt;/a&gt;, он повел себя как-то не
    очень адекватно, совсем не так каким я привык его видеть у себя на
    &lt;a href="/tag/noutbuk/"&gt;ноутбуке&lt;/a&gt;, разбираться в причинах было не охота -
    простое копирование и замена соответствующей директории по &lt;em&gt;ftp&lt;/em&gt;
    буквально за минуту решило проблему.&lt;/li&gt;
&lt;li&gt;Вариантов фильтров сетевого трафика в &lt;a href="/tag/freebsd/"&gt;FreeBSD&lt;/a&gt;
    имеется предостаточно:
    &lt;a href="https://www.insight-it.ru/goto/b7a4c2f7/" rel="nofollow" target="_blank" title="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/book.html#FIREWALLS-PF"&gt;pf&lt;/a&gt;,
    &lt;a href="https://www.insight-it.ru/goto/963bd5ec/" rel="nofollow" target="_blank" title="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/book.html#FIREWALLS-IPF"&gt;ipf&lt;/a&gt;,
    &lt;a href="https://www.insight-it.ru/goto/aee50277/" rel="nofollow" target="_blank" title="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/book.html#FIREWALLS-IPFW%22"&gt;ipfw&lt;/a&gt;.
    Опыта работы ни с одним из них у меня не было, так что выбор
    происходил из достаточно субъективных критериев - очевидности
    принципов работы правил и достаточности документации. Так как я был
    уверен, что каждый из них сможет обеспечить достаточный уровень
    безопасности, основываясь на указанных выше критериях в итоге я
    выбрал &lt;strong&gt;ipf&lt;/strong&gt;. Документация позволила легко и непринужденно все
    установить и настроить, правда за компанию пришлось разбираться и с
    &lt;a href="https://www.insight-it.ru/goto/420d629d/" rel="nofollow" target="_blank" title="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/book.html#KERNELCONFIG"&gt;пересборкой ядра&lt;/a&gt;.
    В качестве базы для построения собственного списка правил я
    использовал приведенный все там же, в документации, пример. Само
    собой пришлось доработать его под конкретную систему, но методом
    проб и ошибок эта задача выполняется достаточно быстро &lt;em&gt;(будте
    осторожны с 22 портом, используемым для SSH - очень легко на этом
    этапе случайно заблокировать самому себе доступ к серверу)&lt;/em&gt;.
    Получившийся в итоге список правил приводить не буду, так как его
    еще предстоит довести до ума на активно работающей системе.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="zakliuchenie"&gt;Заключение&lt;/h3&gt;
&lt;p&gt;Не прошло и двух дней, как из простого набора оборудования получился
вполне готовый к работе веб-сервер, конечно же доводить до ума его
придется еще достаточно долго, но просто стабильно работать он был в
состоянии уже тогда. Дальше его отвезли в место постоянного его
прибывания, подключили к более-менее приличному интернет-каналу, с моей
стороны при этом потребовалось лишь слегка поменять настройки сетевого
подключения, и вот - он уже доступен из Сети. Практически сразу
же обнаружился один мой недочет в плане выбора &lt;a href="/tag/po/"&gt;ПО&lt;/a&gt; - буквально
в первую же ночь после открытия публичного доступа к серверу нашлась
масса желающих попытаться подобрать по словарю логин и пароль для
доступа к серверу по SSH, но он был открыт лишь для одной учетной
записи, у которой было мягко говоря нестандартное имя пользователя, даже
его никто за ночь не смог угадать, а до более чем 20-символьного пароля
дело так и не дошло. На следующее утро я, не долго думая, установил
программу под названием &lt;strong&gt;&lt;a href="https://www.insight-it.ru/goto/d4707261/" rel="nofollow" target="_blank" title="http://www.freebsd.org/cgi/url.cgi?ports/security/sshguard/pkg-descr"&gt;sshguard&lt;/a&gt;&lt;/strong&gt;, которая сразу же предотвратила все последующие попытки подобным образом издеваться над сервером. Дальше надо было настроить запись на
DNS-сервере для ассоциации домена с IP нашего сервера, настроить почту,
закончить работу над самим веб-приложением и много чего еще, но это уже
совсем другая история.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Иван Блинков</dc:creator><pubDate>Thu, 14 Feb 2008 15:59:00 +0300</pubDate><guid>tag:www.insight-it.ru,2008-02-14:linux/2008/web-server-za-dva-vechera/</guid><category>Beastie</category><category>FreeBSD</category><category>lighttpd</category><category>PostgreSQL</category><category>Unix</category><category>веб-сервер</category><category>операционная система</category><category>сервер</category><category>системное администрирование</category></item></channel></rss>